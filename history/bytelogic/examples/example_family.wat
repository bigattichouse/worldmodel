(module
;; Generated ByteLog WebAssembly module
;; Math function imports
  (import "Math" "sin" (func $sin (param f64) (result f64)))
  (import "Math" "cos" (func $cos (param f64) (result f64)))
  (import "Math" "tan" (func $tan (param f64) (result f64)))
  (import "Math" "log" (func $log (param f64) (result f64)))
  (import "Math" "pow" (func $pow (param f64) (param f64) (result f64)))

  (memory 1)
;; Data section with atom names
;; Fact database functions
  (func $hash_fact (param $rel i32) (param $a i32) (param $b i32) (result i32)
    ;; Simple hash: (rel * 31 + a) * 31 + b
    local.get $rel
    i32.const 31
    i32.mul
    local.get $a
    i32.add
    i32.const 31
    i32.mul
    local.get $b
    i32.add
    i32.const 1000
    i32.rem_u
  )

  (func $add_fact (param $rel i32) (param $a i32) (param $b i32)
    (local $offset i32)
    ;; Calculate memory offset for fact
    local.get $rel
    local.get $a
    local.get $b
    call $hash_fact
    i32.const 12
    i32.mul
    local.set $offset
    ;; Store fact in memory
    local.get $offset
    local.get $rel
    i32.store
    local.get $offset
    i32.const 4
    i32.add
    local.get $a
    i32.store
    local.get $offset
    i32.const 8
    i32.add
    local.get $b
    i32.store
  )

  (func $has_fact (param $rel i32) (param $a i32) (param $b i32) (result i32)
    (local $offset i32)
    (local $stored_rel i32)
    (local $stored_a i32)
    (local $stored_b i32)
    ;; Calculate memory offset
    local.get $rel
    local.get $a
    local.get $b
    call $hash_fact
    i32.const 12
    i32.mul
    local.set $offset
    ;; Load stored values
    local.get $offset
    i32.load
    local.set $stored_rel
    local.get $offset
    i32.const 4
    i32.add
    i32.load
    local.set $stored_a
    local.get $offset
    i32.const 8
    i32.add
    i32.load
    local.set $stored_b
    ;; Compare values
    local.get $stored_rel
    local.get $rel
    i32.eq
    local.get $stored_a
    local.get $a
    i32.eq
    i32.and
    local.get $stored_b
    local.get $b
    i32.eq
    i32.and
  )

;; Rule evaluation functions
  (func $rule_grandparent_0
    ;; Rule evaluation stub
    ;; TODO: Implement actual rule logic
  )

  (func $rule_sibling_1
    ;; Rule evaluation stub
    ;; TODO: Implement actual rule logic
  )

  (func $rule_ancestor_2
    ;; Rule evaluation stub
    ;; TODO: Implement actual rule logic
  )

  (func $rule_ancestor_3
    ;; Rule evaluation stub
    ;; TODO: Implement actual rule logic
  )

;; Query functions
  (func $query_0 (result i32)
    ;; Query: parent(0, ?)
    i32.const 1
  )

  (func $query_1 (result i32)
    ;; Query: grandparent(0, ?)
    i32.const 1
  )

  (func $query_2 (result i32)
    ;; Query: sibling(1, ?)
    i32.const 1
  )

  (func $query_3 (result i32)
    ;; Query: ancestor(0, ?)
    i32.const 1
  )

;; Main execution function
  (func $main
    ;; Add fact: parent(0, 1)
    i32.const 6
    i32.const 0
    i32.const 1
    call $add_fact

    ;; Add fact: parent(0, 2)
    i32.const 6
    i32.const 0
    i32.const 2
    call $add_fact

    ;; Add fact: parent(1, 3)
    i32.const 6
    i32.const 1
    i32.const 3
    call $add_fact

    ;; Add fact: parent(2, 4)
    i32.const 6
    i32.const 2
    i32.const 4
    call $add_fact

    ;; Add fact: parent(3, 5)
    i32.const 6
    i32.const 3
    i32.const 5
    call $add_fact

    ;; Add fact: parent(4, 6)
    i32.const 6
    i32.const 4
    i32.const 6
    call $add_fact

;; TODO: Evaluate rules here
  )

;; Exports for JavaScript interface
  (export "main" (func $main))
  (export "memory" (memory 0))
  (export "add_fact" (func $add_fact))
  (export "has_fact" (func $has_fact))

)
