{
  "dataset_info": {
    "name": "blueprint_bytelogic_dataset",
    "description": "Complete training data with Blueprint-style pseudocode planning and ByteLogic implementation",
    "size": 20,
    "format": "user_query -> <thinking> -> <pseudocode> -> <computation>",
    "phases": ["abstract_planning", "blueprint_design", "implementation_translation", "integrated_training"]
  },
  "examples": [
    {
      "id": 1,
      "user_query": "Who are Alice's children?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for Alice's children\n- Need to find all people who have Alice as their parent\n- This is a direct lookup in a parent-child relationship\n\nAPPROACH STRATEGY:\n- Store parent-child relationships\n- Query for all children where Alice is the parent\n- This is a basic fact lookup operation\n\nCONNECTION TO BYTELOGIC:\n- Need parent relation to store relationships\n- Need query to extract specific results\n</thinking>\n\n<pseudocode>\n; Problem: Find children of a specific person\n; Input: Parent name (Alice)\n; Goal: Find all children of Alice\n\nREL parent\n\n; Facts: Parent-child relationships\nFACT parent alice bob\nFACT parent alice charlie\nFACT parent bob dave\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY parent alice ?\n</pseudocode>\n\n<computation>\nREL parent\n\nFACT parent alice bob\nFACT parent alice charlie\nFACT parent bob dave\n\nSOLVE\nQUERY parent alice ?\n</computation>"
    },
    {
      "id": 2,
      "user_query": "Who are Alice's grandchildren?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for Alice's grandchildren\n- This requires finding children of Alice's children\n- Need a transitive relationship: parent of parent\n- This is a classic transitive closure problem\n\nAPPROACH STRATEGY:\n- First find Alice's children\n- Then find children of those children\n- Need to create a derived relationship\n- This requires rule-based inference\n\nCONNECTION TO BYTELOGIC:\n- Need parent relation for base facts\n- Need grandparent relation for derived facts\n- Need rule to create transitive relationship\n</thinking>\n\n<pseudocode>\n; Problem: Find grandchildren of a specific person\n; Input: Grandparent name (Alice)\n; Goal: Find all grandchildren of Alice\n\nREL parent\nREL grandparent\n\n; Facts: Direct parent-child relationships\nFACT parent alice bob\nFACT parent bob charlie\nFACT parent alice diana\nFACT parent diana eve\n\n; Rules: Create grandparent-grandchild relationship\n; Base case: Direct parent-child\nRULE grandparent: SCAN parent MATCH $0, JOIN parent $0, EMIT grandparent $1 $2\n\nSOLVE\nQUERY grandparent alice ?\n</pseudocode>\n\n<computation>\nREL parent\nREL grandparent\n\nFACT parent alice bob\nFACT parent bob charlie\nFACT parent alice diana\nFACT parent diana eve\n\nRULE grandparent: SCAN parent MATCH $0, JOIN parent $0, EMIT grandparent $1 $2\n\nSOLVE\nQUERY grandparent alice ?\n</computation>"
    },
    {
      "id": 3,
      "user_query": "Who are friends of Alice's friends?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for friends of Alice's friends (friends-of-friends)\n- This is a graph traversal problem\n- Need to find connections through one intermediate person\n- This requires finding mutual connections\n\nAPPROACH STRATEGY:\n- Find Alice's direct friends\n- For each friend, find their friends\n- Exclude Alice herself from the results\n- This requires joining the friend relation with itself\n\nCONNECTION TO BYTELOGIC:\n- Need friend relation to store connections\n- Need rule to find friend-of-friend relationships\n- Need query to extract specific results\n</thinking>\n\n<pseudocode>\n; Problem: Find friends of friends (foaf) for a specific person\n; Input: Person name (Alice)\n; Goal: Find all people who are friends of Alice's friends\n\nREL friend\nREL friend_of_friend\n\n; Facts: Direct friend relationships\nFACT friend alice bob\nFACT friend bob charlie\nFACT friend alice diana\nFACT friend diana eve\nFACT friend bob frank\n\n; Rules: Find friend of friend relationships\n; Connect through intermediate person\nRULE friend_of_friend: SCAN friend MATCH $0, JOIN friend $0, EMIT friend_of_friend $1 $2\n\nSOLVE\nQUERY friend_of_friend alice ?\n</pseudocode>\n\n<computation>\nREL friend\n\nFACT friend alice bob\nFACT friend bob charlie\nFACT friend alice diana\nFACT friend diana eve\nFACT friend bob frank\n\nRULE friend_of_friend: SCAN friend MATCH $0, JOIN friend $0, EMIT friend_of_friend $1 $2\n\nSOLVE\nQUERY friend_of_friend alice ?\n</computation>"
    },
    {
      "id": 4,
      "user_query": "What animals can fly?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for animals with the flying capability\n- Need to connect animals to their capabilities\n- May involve hierarchical relationships (species, genus, family)\n- This is a capability lookup problem\n\nAPPROACH STRATEGY:\n- Store animal-capability relationships\n- Query for all animals with flying capability\n- May need to traverse classification hierarchies\n- This is a reverse lookup operation\n\nCONNECTION TO BYTELOGIC:\n- Need has_capability relation to store capability facts\n- Need species_is_a relation for hierarchies if needed\n- Need query to extract animals by capability\n</thinking>\n\n<pseudocode>\n; Problem: Find all animals with a specific capability\n; Input: Capability (fly)\n; Goal: Find all animals that can fly\n\nREL has_capability\n\n; Facts: Animal-capability relationships\nFACT has_capability eagle fly\nFACT has_capability sparrow fly\nFACT has_capability ostrich run\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY has_capability ? fly\n</pseudocode>\n\n<computation>\nREL has_capability\n\nFACT has_capability eagle fly\nFACT has_capability sparrow fly\nFACT has_capability ostrich run\n\nSOLVE\nQUERY has_capability ? fly\n</computation>"
    },
    {
      "id": 5,
      "user_query": "Who are Bob's siblings?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for Bob's siblings\n- Siblings share the same parent\n- Need to find all people who have the same parent as Bob\n- This is a common parent relationship problem\n\nAPPROACH STRATEGY:\n- Find Bob's parents\n- Find all children of those parents\n- Exclude Bob from the results\n- This requires finding common parent relationships\n\nCONNECTION TO BYTELOGIC:\n- Need parent relation to store parent-child facts\n- Need sibling relation for derived facts\n- Need rule to find people with common parents\n</thinking>\n\n<pseudocode>\n; Problem: Find siblings of a specific person\n; Input: Person name (Bob)\n; Goal: Find all siblings of Bob\n\nREL parent\nREL sibling\n\n; Facts: Parent-child relationships\nFACT parent alice bob\nFACT parent alice charlie\nFACT parent alice diana\n\n; Rules: Find people with common parents\nRULE sibling: SCAN parent MATCH $0, JOIN parent $0, EMIT sibling $1 $2\n\nSOLVE\nQUERY sibling bob ?\n</pseudocode>\n\n<computation>\nREL parent\nREL sibling\n\nFACT parent alice bob\nFACT parent alice charlie\nFACT parent alice diana\n\nRULE sibling: SCAN parent MATCH $0, JOIN parent $0, EMIT sibling $1 $2\n\nSOLVE\nQUERY sibling bob ?\n</computation>"
    },
    {
      "id": 6,
      "user_query": "Who reports to the same manager as Charlie?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for people who report to Charlie's manager(s)\n- This is a co-worker relationship\n- Need to find Charlie's manager, then others who report to the same manager\n- This is a common supervisor problem\n\nAPPROACH STRATEGY:\n- Find Charlie's manager(s)\n- Find all people who report to those same managers\n- Exclude Charlie from the results\n- This requires finding common reporting relationships\n\nCONNECTION TO BYTELOGIC:\n- Need reports_to relation to store reporting facts\n- Need coworker relation for derived facts\n- Need rule to find people with common managers\n</thinking>\n\n<pseudocode>\n; Problem: Find coworkers of a specific person\n; Input: Employee name (Charlie)\n; Goal: Find all employees who report to the same manager as Charlie\n\nREL reports_to\nREL coworker\n\n; Facts: Reporting relationships\nFACT reports_to bob alice\nFACT reports_to charlie alice\nFACT reports_to diana alice\nFACT reports_to eve frank\n\n; Rules: Find employees with common managers\nRULE coworker: SCAN reports_to MATCH $1, JOIN reports_to $1, EMIT coworker $0 $2\n\nSOLVE\nQUERY coworker charlie ?\n</pseudocode>\n\n<computation>\nREL reports_to\nREL coworker\n\nFACT reports_to bob alice\nFACT reports_to charlie alice\nFACT reports_to diana alice\nFACT reports_to eve frank\n\nRULE coworker: SCAN reports_to MATCH $1, JOIN reports_to $1, EMIT coworker $0 $2\n\nSOLVE\nQUERY coworker charlie ?\n</computation>"
    },
    {
      "id": 7,
      "user_query": "Which cities are connected to Boston by a direct route?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for cities directly connected to Boston\n- This is a graph connectivity problem\n- Looking for direct edges from Boston to other cities\n- This is a direct lookup in a connection graph\n\nAPPROACH STRATEGY:\n- Identify the connection relation\n- Find all facts where Boston is the source\n- Extract destination cities from those facts\n- This is a simple adjacency lookup\n\nCONNECTION TO BYTELOGIC:\n- Need connected relation to store connection facts\n- Need query to extract destinations from source\n</thinking>\n\n<pseudocode>\n; Problem: Find directly connected cities to a specific city\n; Input: Source city (Boston)\n; Goal: Find all cities directly connected to Boston\n\nREL connected\n\n; Facts: City connection relationships\nFACT connected boston new_york\nFACT connected boston chicago\nFACT connected new_york washington\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY connected boston ?\n</pseudocode>\n\n<computation>\nREL connected\n\nFACT connected boston new_york\nFACT connected boston chicago\nFACT connected new_york washington\n\nSOLVE\nQUERY connected boston ?\n</computation>"
    },
    {
      "id": 8,
      "user_query": "Which courses can I take if I've completed CS101?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for courses available after completing CS101\n- This involves prerequisite relationships\n- Need to find courses that have CS101 as a prerequisite\n- This is a reverse prerequisite lookup\n\nAPPROACH STRATEGY:\n- Identify the prerequisite relation\n- Find all courses that have CS101 as a prerequisite\n- Return those course codes\n- This is a reverse dependency lookup\n\nCONNECTION TO BYTELOGIC:\n- Need prerequisite relation to store prerequisite facts\n- Need query to find courses by prerequisite\n</thinking>\n\n<pseudocode>\n; Problem: Find courses with a specific prerequisite\n; Input: Prerequisite course (CS101)\n; Goal: Find all courses that have CS101 as a prerequisite\n\nREL prerequisite\n\n; Facts: Course prerequisite relationships\nFACT prerequisite cs101 cs201\nFACT prerequisite cs101 cs202\nFACT prerequisite math101 cs201\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY prerequisite cs101 ?\n</pseudocode>\n\n<computation>\nREL prerequisite\n\nFACT prerequisite cs101 cs201\nFACT prerequisite cs101 cs202\nFACT prerequisite math101 cs201\n\nSOLVE\nQUERY prerequisite cs101 ?\n</computation>"
    },
    {
      "id": 9,
      "user_query": "Who are the team members that Alice manages directly or indirectly?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for all people in Alice's management tree\n- This is a hierarchical management relationship\n- Need to find direct reports and their reports recursively\n- This is a transitive management relationship\n\nAPPROACH STRATEGY:\n- Find Alice's direct reports\n- For each direct report, find their reports\n- Continue recursively until no more levels\n- This is a transitive closure problem\n\nCONNECTION TO BYTELOGIC:\n- Need reports_to relation for base facts\n- Need manages relation for transitive facts\n- Need rules for direct and indirect management\n</thinking>\n\n<pseudocode>\n; Problem: Find all people in a manager's hierarchy\n; Input: Manager name (Alice)\n; Goal: Find all people managed by Alice directly or indirectly\n\nREL reports_to\nREL manages\n\n; Facts: Direct reporting relationships\nFACT reports_to bob alice\nFACT reports_to charlie alice\nFACT reports_to dave bob\nFACT reports_to eve charlie\n\n; Rules: Direct management and transitive management\nRULE manages: SCAN reports_to, EMIT manages $1 $0\nRULE manages: SCAN reports_to, JOIN manages $0, EMIT manages $2 $1\n\nSOLVE\nQUERY manages alice ?\n</pseudocode>\n\n<computation>\nREL reports_to\nREL manages\n\nFACT reports_to bob alice\nFACT reports_to charlie alice\nFACT reports_to dave bob\nFACT reports_to eve charlie\n\nRULE manages: SCAN reports_to, EMIT manages $1 $0\nRULE manages: SCAN reports_to, JOIN manages $0, EMIT manages $2 $1\n\nSOLVE\nQUERY manages alice ?\n</computation>"
    },
    {
      "id": 10,
      "user_query": "Which products are in the same category as laptop?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for products in the same category as 'laptop'\n- This involves product categorization\n- Need to find the category of laptop, then other products in that category\n- This is a category-based grouping problem\n\nAPPROACH STRATEGY:\n- Find the category of laptop\n- Find all products in that same category\n- Return those products\n- This is a category lookup and grouping operation\n\nCONNECTION TO BYTELOGIC:\n- Need belongs_to_category relation to store category facts\n- Need query to find products by category\n</thinking>\n\n<pseudocode>\n; Problem: Find products in the same category as a specific product\n; Input: Product name (laptop)\n; Goal: Find all products in the same category as laptop\n\nREL belongs_to_category\n\n; Facts: Product-category relationships\nFACT belongs_to_category laptop electronics\nFACT belongs_to_category phone electronics\nFACT belongs_to_category tablet electronics\nFACT belongs_to_category chair furniture\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY belongs_to_category ? electronics\n</pseudocode>\n\n<computation>\nREL belongs_to_category\n\nFACT belongs_to_category laptop electronics\nFACT belongs_to_category phone electronics\nFACT belongs_to_category tablet electronics\nFACT belongs_to_category chair furniture\n\nSOLVE\nQUERY belongs_to_category ? electronics\n</computation>"
    },
    {
      "id": 11,
      "user_query": "Who are the friends that both Alice and Bob have?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for mutual friends of Alice and Bob\n- This is an intersection problem\n- Need to find friends of Alice, friends of Bob, then the intersection\n- This is a common connection problem\n\nAPPROACH STRATEGY:\n- Find all friends of Alice\n- Find all friends of Bob\n- Find the intersection of these two sets\n- This requires finding common connections\n\nCONNECTION TO BYTELOGIC:\n- Need friend relation to store friendship facts\n- Need mutual_friend relation for derived facts\n- Need rule to find mutual friends\n</thinking>\n\n<pseudocode>\n; Problem: Find mutual friends of two people\n; Input: Two person names (Alice, Bob)\n; Goal: Find all friends that both Alice and Bob have\n\nREL friend\nREL mutual_friend\n\n; Facts: Friendship relationships\nFACT friend alice bob\nFACT friend alice charlie\nFACT friend alice diana\nFACT friend bob charlie\nFACT friend bob eve\n\n; Rules: Find mutual friends by common connections\nRULE mutual_friend: SCAN friend MATCH $0, JOIN friend $0, EMIT mutual_friend $1 $2\n\nSOLVE\nQUERY mutual_friend alice bob\n</pseudocode>\n\n<computation>\nREL friend\nREL mutual_friend\n\nFACT friend alice bob\nFACT friend alice charlie\nFACT friend alice diana\nFACT friend bob charlie\nFACT friend bob eve\n\nRULE mutual_friend: SCAN friend MATCH $0, JOIN friend $0, EMIT mutual_friend $1 $2\n\nSOLVE\nQUERY mutual_friend alice bob\n</computation>"
    },
    {
      "id": 12,
      "user_query": "Which employees have worked on the same projects as David?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for employees who worked on projects with David\n- This is a collaboration relationship\n- Need to find projects David worked on, then other employees on those projects\n- This is a common project collaboration problem\n\nAPPROACH STRATEGY:\n- Find projects that David worked on\n- For each project, find other employees\n- Collect all such employees\n- This requires finding common project participants\n\nCONNECTION TO BYTELOGIC:\n- Need works_on relation to store employee-project facts\n- Need collaborator relation for derived facts\n- Need rule to find collaborators\n</thinking>\n\n<pseudocode>\n; Problem: Find collaborators of a specific employee\n; Input: Employee name (David)\n; Goal: Find all employees who worked on the same projects as David\n\nREL works_on\nREL collaborator\n\n; Facts: Employee-project relationships\nFACT works_on david project_a\nFACT works_on bob project_a\nFACT works_on charlie project_a\nFACT works_on david project_b\nFACT works_on eve project_b\n\n; Rules: Find collaborators by common projects\nRULE collaborator: SCAN works_on MATCH $1, JOIN works_on $1, EMIT collaborator $0 $2\n\nSOLVE\nQUERY collaborator david ?\n</pseudocode>\n\n<computation>\nREL works_on\nREL collaborator\n\nFACT works_on david project_a\nFACT works_on bob project_a\nFACT works_on charlie project_a\nFACT works_on david project_b\nFACT works_on eve project_b\n\nRULE collaborator: SCAN works_on MATCH $1, JOIN works_on $1, EMIT collaborator $0 $2\n\nSOLVE\nQUERY collaborator david ?\n</computation>"
    },
    {
      "id": 13,
      "user_query": "Who are the descendants of Eve?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for all descendants of Eve\n- This is a full transitive closure of the parent relation\n- Need to find children, grandchildren, great-grandchildren, etc.\n- This is a full transitive closure problem\n\nAPPROACH STRATEGY:\n- Find Eve's children\n- For each child, find their children\n- Continue recursively through all generations\n- This is a full transitive closure operation\n\nCONNECTION TO BYTELOGIC:\n- Need parent relation for base facts\n- Need descendant relation for transitive facts\n- Need rules for direct and transitive descendant relationships\n</thinking>\n\n<pseudocode>\n; Problem: Find all descendants of a specific person\n; Input: Ancestor name (Eve)\n; Goal: Find all descendants of Eve across all generations\n\nREL parent\nREL descendant\n\n; Facts: Direct parent-child relationships\nFACT parent eve alice\nFACT parent alice bob\nFACT parent bob charlie\nFACT parent eve diana\nFACT parent diana eve2\n\n; Rules: Direct and transitive descendant relationships\nRULE descendant: SCAN parent, EMIT descendant $1 $0\nRULE descendant: SCAN parent, JOIN descendant $0, EMIT descendant $2 $1\n\nSOLVE\nQUERY descendant eve ?\n</pseudocode>\n\n<computation>\nREL parent\nREL descendant\n\nFACT parent eve alice\nFACT parent alice bob\nFACT parent bob charlie\nFACT parent eve diana\nFACT parent diana eve2\n\nRULE descendant: SCAN parent, EMIT descendant $1 $0\nRULE descendant: SCAN parent, JOIN descendant $0, EMIT descendant $2 $1\n\nSOLVE\nQUERY descendant eve ?\n</computation>"
    },
    {
      "id": 14,
      "user_query": "Which classes inherit from the Vehicle class?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for classes that inherit from Vehicle\n- This is an inheritance hierarchy problem\n- Need to find direct and indirect inheritance relationships\n- This is a class inheritance lookup\n\nAPPROACH STRATEGY:\n- Find classes that directly inherit from Vehicle\n- Find classes that inherit from those classes (indirect inheritance)\n- Continue for full inheritance tree\n- This is a reverse inheritance lookup\n\nCONNECTION TO BYTELOGIC:\n- Need inherits_from relation to store inheritance facts\n- Need query to find classes by parent class\n</thinking>\n\n<pseudocode>\n; Problem: Find classes that inherit from a specific parent class\n; Input: Parent class name (Vehicle)\n; Goal: Find all classes that inherit from Vehicle\n\nREL inherits_from\n\n; Facts: Class inheritance relationships\nFACT inherits_from car vehicle\nFACT inherits_from truck vehicle\nFACT inherits_from sports_car car\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY inherits_from ? vehicle\n</pseudocode>\n\n<computation>\nREL inherits_from\n\nFACT inherits_from car vehicle\nFACT inherits_from truck vehicle\nFACT inherits_from sports_car car\n\nSOLVE\nQUERY inherits_from ? vehicle\n</computation>"
    },
    {
      "id": 15,
      "user_query": "Who are the neighbors of node X in the network?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for nodes directly connected to node X\n- This is an undirected graph neighbor problem\n- Need to find all nodes connected by an edge to X\n- This is a direct adjacency lookup\n\nAPPROACH STRATEGY:\n- Find all edges where X is one endpoint\n- Extract the other endpoint from each edge\n- This represents bidirectional connections\n- This is a simple adjacency lookup\n\nCONNECTION TO BYTELOGIC:\n- Need connected relation to store connection facts\n- Need query to extract adjacent nodes\n</thinking>\n\n<pseudocode>\n; Problem: Find neighbors of a specific node in a network\n; Input: Node name (X)\n; Goal: Find all nodes directly connected to X\n\nREL connected\n\n; Facts: Node connection relationships\nFACT connected x y\nFACT connected x z\nFACT connected y w\nFACT connected z a\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY connected x ?\n</pseudocode>\n\n<computation>\nREL connected\n\nFACT connected x y\nFACT connected x z\nFACT connected y w\nFACT connected z a\n\nSOLVE\nQUERY connected x ?\n</computation>"
    },
    {
      "id": 16,
      "user_query": "Which departments are under the same division as HR?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for departments in the same division as HR\n- This involves organizational hierarchy\n- Need to find HR's division, then other departments in that division\n- This is an organizational grouping problem\n\nAPPROACH STRATEGY:\n- Find which division HR belongs to\n- Find all departments in that same division\n- Return those departments\n- This is a division-based grouping lookup\n\nCONNECTION TO BYTELOGIC:\n- Need department_of relation to store department-division facts\n- Need query to find departments by division\n</thinking>\n\n<pseudocode>\n; Problem: Find departments in the same division as a specific department\n; Input: Department name (HR)\n; Goal: Find all departments in the same division as HR\n\nREL department_of\n\n; Facts: Department-division relationships\nFACT department_of hr finance_division\nFACT department_of accounting finance_division\nFACT department_of legal legal_division\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY department_of ? finance_division\n</pseudocode>\n\n<computation>\nREL department_of\n\nFACT department_of hr finance_division\nFACT department_of accounting finance_division\nFACT department_of legal legal_division\n\nSOLVE\nQUERY department_of ? finance_division\n</computation>"
    },
    {
      "id": 17,
      "user_query": "Who are the suppliers that provide materials to the same factories as supplier A?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for suppliers that share factory relationships with supplier A\n- This is a supplier-factory bipartite graph problem\n- Need to find factories supplied by A, then other suppliers of those factories\n- This is a common supplier relationship problem\n\nAPPROACH STRATEGY:\n- Find factories that receive supplies from supplier A\n- For each of those factories, find other suppliers\n- Return all such suppliers\n- This requires finding common factory suppliers\n\nCONNECTION TO BYTELOGIC:\n- Need supplies_to relation to store supplier-factory facts\n- Need shared_factory_supplier relation for derived facts\n- Need rule to find suppliers with common factories\n</thinking>\n\n<pseudocode>\n; Problem: Find suppliers with common factory relationships\n; Input: Supplier name (A)\n; Goal: Find all suppliers that provide materials to the same factories as A\n\nREL supplies_to\nREL shared_factory_supplier\n\n; Facts: Supplier-factory relationships\nFACT supplies_to a factory_x\nFACT supplies_to b factory_x\nFACT supplies_to c factory_y\nFACT supplies_to a factory_y\n\n; Rules: Find suppliers with shared factories\nRULE shared_factory_supplier: SCAN supplies_to MATCH $1, JOIN supplies_to $1, EMIT shared_factory_supplier $0 $2\n\nSOLVE\nQUERY shared_factory_supplier a ?\n</pseudocode>\n\n<computation>\nREL supplies_to\nREL shared_factory_supplier\n\nFACT supplies_to a factory_x\nFACT supplies_to b factory_x\nFACT supplies_to c factory_y\nFACT supplies_to a factory_y\n\nRULE shared_factory_supplier: SCAN supplies_to MATCH $1, JOIN supplies_to $1, EMIT shared_factory_supplier $0 $2\n\nSOLVE\nQUERY shared_factory_supplier a ?\n</computation>"
    },
    {
      "id": 18,
      "user_query": "Which genes are associated with the same disease as gene BRCA1?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for genes linked to diseases that BRCA1 is also linked to\n- This is a gene-disease association problem\n- Need to find diseases of BRCA1, then other genes associated with those diseases\n- This is a common disease association problem\n\nAPPROACH STRATEGY:\n- Find diseases associated with BRCA1\n- For each disease, find other genes associated with it\n- Return all such genes\n- This requires finding genes with common disease associations\n\nCONNECTION TO BYTELOGIC:\n- Need associated_with relation to store gene-disease facts\n- Need query to find genes by disease\n</thinking>\n\n<pseudocode>\n; Problem: Find genes associated with the same diseases\n; Input: Gene name (BRCA1)\n; Goal: Find all genes associated with the same diseases as BRCA1\n\nREL associated_with\n\n; Facts: Gene-disease associations\nFACT associated_with brca1 cancer\nFACT associated_with p53 cancer\nFACT associated_with apoe alzheimers\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY associated_with ? cancer\n</pseudocode>\n\n<computation>\nREL associated_with\n\nFACT associated_with brca1 cancer\nFACT associated_with p53 cancer\nFACT associated_with apoe alzheimers\n\nSOLVE\nQUERY associated_with ? cancer\n</computation>"
    },
    {
      "id": 19,
      "user_query": "Who are the students in the same study group as John?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for students in John's study groups\n- This is a group membership problem\n- Need to find groups John belongs to, then other members of those groups\n- This is a group membership lookup\n\nAPPROACH STRATEGY:\n- Find study groups that John is a member of\n- For each group, find other members\n- Return all such students\n- This is a group membership lookup\n\nCONNECTION TO BYTELOGIC:\n- Need member_of relation to store student-group facts\n- Need query to find members by group\n</thinking>\n\n<pseudocode>\n; Problem: Find members of the same group as a specific person\n; Input: Person name (John)\n; Goal: Find all students in the same study group as John\n\nREL member_of\n\n; Facts: Student-group memberships\nFACT member_of john group_a\nFACT member_of mary group_a\nFACT member_of bob group_a\nFACT member_of alice group_b\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY member_of ? group_a\n</pseudocode>\n\n<computation>\nREL member_of\n\nFACT member_of john group_a\nFACT member_of mary group_a\nFACT member_of bob group_a\nFACT member_of alice group_b\n\nSOLVE\nQUERY member_of ? group_a\n</computation>"
    },
    {
      "id": 20,
      "user_query": "Which books are in the same series as 'Harry Potter'?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for books in the same series as 'Harry Potter'\n- This is a book-series categorization problem\n- Need to find the series of Harry Potter, then other books in that series\n- This is a series-based grouping problem\n\nAPPROACH STRATEGY:\n- Find which series 'Harry Potter' belongs to\n- Find all books in that same series\n- Return those books\n- This is a series-based grouping lookup\n\nCONNECTION TO BYTELOGIC:\n- Need part_of_series relation to store book-series facts\n- Need query to find books by series\n</thinking>\n\n<pseudocode>\n; Problem: Find books in the same series as a specific book\n; Input: Book name ('Harry Potter')\n; Goal: Find all books in the same series as Harry Potter\n\nREL part_of_series\n\n; Facts: Book-series relationships\nFACT part_of_series harry_potter_and_the_sorcerers_stone harry_potter\nFACT part_of_series harry_potter_and_the_chamber_of_secrets harry_potter\nFACT part_of_series lord_of_the_rings fellowship_of_the_ring\n\n; Rules: None needed for direct lookup\n\nSOLVE\nQUERY part_of_series ? harry_potter\n</pseudocode>\n\n<computation>\nREL part_of_series\n\nFACT part_of_series harry_potter_and_the_sorcerers_stone harry_potter\nFACT part_of_series harry_potter_and_the_chamber_of_secrets harry_potter\nFACT part_of_series lord_of_the_rings fellowship_of_the_ring\n\nSOLVE\nQUERY part_of_series ? harry_potter\n</computation>"
    }
  ]
}