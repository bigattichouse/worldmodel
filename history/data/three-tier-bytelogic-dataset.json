{
  "dataset_info": {
    "name": "three_tier_bytelogic_dataset",
    "description": "Complete training data with three-tier planning: abstract thinking, formal pseudocode, and ByteLogic implementation",
    "size": 50,
    "format": "user_query -> <thinking> -> <pseudocode> -> <computation>",
    "phases": ["abstract_planning", "algorithm_design", "implementation_translation", "integrated_training"]
  },
  "examples": [
    {
      "id": 1,
      "user_query": "Who are Alice's children?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for Alice's children\n- Need to find all people who have Alice as their parent\n- This is a direct lookup in a parent-child relationship\n\nAPPROACH STRATEGY:\n- Store parent-child relationships\n- Query for all children where Alice is the parent\n- This is a basic fact lookup operation\n\nCONNECTION TO BYTELOGIC:\n- Need parent relation to store relationships\n- Need query to extract specific results\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: parent relation to store parent-child facts\n2. INPUT PROCESSING: add parent-child facts to the database\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query parent relation with Alice as parent\n5. OUTPUT FORMATTING: return all matching children\n</pseudocode>\n\n<computation>\nREL parent\n\nFACT parent alice bob\nFACT parent alice charlie\nFACT parent bob dave\n\nSOLVE\nQUERY parent alice ?\n</computation>"
    },
    {
      "id": 2,
      "user_query": "Who are Alice's grandchildren?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for Alice's grandchildren\n- This requires finding children of Alice's children\n- Need a transitive relationship: parent of parent\n- This is a classic transitive closure problem\n\nAPPROACH STRATEGY:\n- First find Alice's children\n- Then find children of those children\n- Need to create a derived relationship\n- This requires rule-based inference\n\nCONNECTION TO BYTELOGIC:\n- Need parent relation for base facts\n- Need grandparent relation for derived facts\n- Need rule to create transitive relationship\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: parent (base), grandparent (derived)\n2. INPUT PROCESSING: add parent-child facts\n3. LOGICAL RULES:\n   - Rule 1: Find parent of parent relationship using scan and join\n   - SCAN parent where first arg matches Alice\n   - JOIN parent where first arg matches second of previous scan\n   - EMIT grandparent with first parent and final child\n4. QUERY EXECUTION: query grandparent relation with Alice\n5. OUTPUT FORMATTING: return all matching grandchildren\n</pseudocode>\n\n<computation>\nREL parent\nREL grandparent\n\nFACT parent alice bob\nFACT parent bob charlie\nFACT parent alice diana\nFACT parent diana eve\n\nRULE grandparent: SCAN parent MATCH $0, JOIN parent $0, EMIT grandparent $1 $2\n\nSOLVE\nQUERY grandparent alice ?\n</computation>"
    },
    {
      "id": 3,
      "user_query": "Who are friends of Alice's friends?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for friends of Alice's friends (friends-of-friends)\n- This is a graph traversal problem\n- Need to find connections through one intermediate person\n- This requires finding mutual connections\n\nAPPROACH STRATEGY:\n- Find Alice's direct friends\n- For each friend, find their friends\n- Exclude Alice herself from the results\n- This requires joining the friend relation with itself\n\nCONNECTION TO BYTELOGIC:\n- Need friend relation to store connections\n- Need rule to find friend-of-friend relationships\n- Need query to extract specific results\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: friend relation for connections\n2. INPUT PROCESSING: add friend-friend facts\n3. LOGICAL RULES:\n   - Rule 1: Find friend-of-friend by matching intermediate person\n   - SCAN friend where first arg is Alice\n   - JOIN friend where first arg matches second of previous scan\n   - EMIT friend_of_friend with Alice and final friend\n4. QUERY EXECUTION: query friend_of_friend relation with Alice\n5. OUTPUT FORMATTING: return all matching friend-of-friends\n</pseudocode>\n\n<computation>\nREL friend\n\nFACT friend alice bob\nFACT friend bob charlie\nFACT friend alice diana\nFACT friend diana eve\nFACT friend bob frank\n\nRULE friend_of_friend: SCAN friend MATCH $0, JOIN friend $0, EMIT friend_of_friend $1 $2\n\nSOLVE\nQUERY friend_of_friend alice ?\n</computation>"
    },
    {
      "id": 4,
      "user_query": "What animals can fly?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for animals with the flying capability\n- Need to connect animals to their capabilities\n- May involve hierarchical relationships (species, genus, family)\n- This is a capability lookup problem\n\nAPPROACH STRATEGY:\n- Store animal-capability relationships\n- Query for all animals with flying capability\n- May need to traverse classification hierarchies\n- This is a reverse lookup operation\n\nCONNECTION TO BYTELOGIC:\n- Need has_capability relation to store capability facts\n- Need species_is_a relation for hierarchies if needed\n- Need query to extract animals by capability\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: has_capability relation for animal-capability facts\n2. INPUT PROCESSING: add animal-capability facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query has_capability with 'fly' as capability\n5. OUTPUT FORMATTING: return all matching animals\n</pseudocode>\n\n<computation>\nREL has_capability\n\nFACT has_capability eagle fly\nFACT has_capability sparrow fly\nFACT has_capability ostrich run\n\nSOLVE\nQUERY has_capability ? fly\n</computation>"
    },
    {
      "id": 5,
      "user_query": "Who are Bob's siblings?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for Bob's siblings\n- Siblings share the same parent\n- Need to find all people who have the same parent as Bob\n- This is a common parent relationship problem\n\nAPPROACH STRATEGY:\n- Find Bob's parents\n- Find all children of those parents\n- Exclude Bob from the results\n- This requires finding common parent relationships\n\nCONNECTION TO BYTELOGIC:\n- Need parent relation to store parent-child facts\n- Need sibling relation for derived facts\n- Need rule to find people with common parents\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: parent (base), sibling (derived)\n2. INPUT PROCESSING: add parent-child facts\n3. LOGICAL RULES:\n   - Rule 1: Find siblings by matching common parent\n   - SCAN parent where second arg is Bob\n   - JOIN parent where first arg matches parent from previous scan\n   - EMIT sibling with Bob and other child\n4. QUERY EXECUTION: query sibling relation with Bob\n5. OUTPUT FORMATTING: return all matching siblings\n</pseudocode>\n\n<computation>\nREL parent\nREL sibling\n\nFACT parent alice bob\nFACT parent alice charlie\nFACT parent alice diana\n\nRULE sibling: SCAN parent MATCH $0, JOIN parent $0, EMIT sibling $1 $2\n\nSOLVE\nQUERY sibling bob ?\n</computation>"
    },
    {
      "id": 6,
      "user_query": "Who reports to the same manager as Charlie?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for people who report to Charlie's manager(s)\n- This is a co-worker relationship\n- Need to find Charlie's manager, then others who report to the same manager\n- This is a common supervisor problem\n\nAPPROACH STRATEGY:\n- Find Charlie's manager(s)\n- Find all people who report to those same managers\n- Exclude Charlie from the results\n- This requires finding common reporting relationships\n\nCONNECTION TO BYTELOGIC:\n- Need reports_to relation to store reporting facts\n- Need coworker relation for derived facts\n- Need rule to find people with common managers\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: reports_to (base), coworker (derived)\n2. INPUT PROCESSING: add reports_to facts\n3. LOGICAL RULES:\n   - Rule 1: Find coworkers by matching common manager\n   - SCAN reports_to where second arg is Charlie\n   - JOIN reports_to where first arg matches manager from previous scan\n   - EMIT coworker with Charlie and other employee\n4. QUERY EXECUTION: query coworker relation with Charlie\n5. OUTPUT FORMATTING: return all matching coworkers\n</pseudocode>\n\n<computation>\nREL reports_to\nREL coworker\n\nFACT reports_to bob alice\nFACT reports_to charlie alice\nFACT reports_to diana alice\nFACT reports_to eve frank\n\nRULE coworker: SCAN reports_to MATCH $1, JOIN reports_to $1, EMIT coworker $0 $2\n\nSOLVE\nQUERY coworker charlie ?\n</computation>"
    },
    {
      "id": 7,
      "user_query": "Which cities are connected to Boston by a direct route?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for cities directly connected to Boston\n- This is a graph connectivity problem\n- Looking for direct edges from Boston to other cities\n- This is a direct lookup in a connection graph\n\nAPPROACH STRATEGY:\n- Identify the connection relation\n- Find all facts where Boston is the source\n- Extract destination cities from those facts\n- This is a simple adjacency lookup\n\nCONNECTION TO BYTELOGIC:\n- Need connected relation to store connection facts\n- Need query to extract destinations from source\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: connected relation for city connections\n2. INPUT PROCESSING: add city connection facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query connected relation with Boston as source\n5. OUTPUT FORMATTING: return all connected destination cities\n</pseudocode>\n\n<computation>\nREL connected\n\nFACT connected boston new_york\nFACT connected boston chicago\nFACT connected new_york washington\n\nSOLVE\nQUERY connected boston ?\n</computation>"
    },
    {
      "id": 8,
      "user_query": "Which courses can I take if I've completed CS101?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for courses available after completing CS101\n- This involves prerequisite relationships\n- Need to find courses that have CS101 as a prerequisite\n- This is a reverse prerequisite lookup\n\nAPPROACH STRATEGY:\n- Identify the prerequisite relation\n- Find all courses that have CS101 as a prerequisite\n- Return those course codes\n- This is a reverse dependency lookup\n\nCONNECTION TO BYTELOGIC:\n- Need prerequisite relation to store prerequisite facts\n- Need query to find courses by prerequisite\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: prerequisite relation for course prerequisites\n2. INPUT PROCESSING: add prerequisite facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query prerequisite relation with CS101 as prerequisite\n5. OUTPUT FORMATTING: return all matching courses\n</pseudocode>\n\n<computation>\nREL prerequisite\n\nFACT prerequisite cs101 cs201\nFACT prerequisite cs101 cs202\nFACT prerequisite math101 cs201\n\nSOLVE\nQUERY prerequisite cs101 ?\n</computation>"
    },
    {
      "id": 9,
      "user_query": "Who are the team members that Alice manages directly or indirectly?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for all people in Alice's management tree\n- This is a hierarchical management relationship\n- Need to find direct reports and their reports recursively\n- This is a transitive management relationship\n\nAPPROACH STRATEGY:\n- Find Alice's direct reports\n- For each direct report, find their reports\n- Continue recursively until no more levels\n- This is a transitive closure problem\n\nCONNECTION TO BYTELOGIC:\n- Need reports_to relation for base facts\n- Need manages relation for transitive facts\n- Need rules for direct and indirect management\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: reports_to (base), manages (transitive)\n2. INPUT PROCESSING: add reporting facts\n3. LOGICAL RULES:\n   - Rule 1: Direct management - propagate immediate reports\n   - SCAN reports_to and EMIT manages with manager and report\n   - Rule 2: Indirect management - propagate through hierarchy\n   - SCAN reports_to and JOIN manages to find deeper reports\n   - EMIT manages with original manager and distant reports\n4. QUERY EXECUTION: query manages relation with Alice\n5. OUTPUT FORMATTING: return all managed team members\n</pseudocode>\n\n<computation>\nREL reports_to\nREL manages\n\nFACT reports_to bob alice\nFACT reports_to charlie alice\nFACT reports_to dave bob\nFACT reports_to eve charlie\n\nRULE manages: SCAN reports_to, EMIT manages $1 $0\nRULE manages: SCAN reports_to, JOIN manages $0, EMIT manages $2 $1\n\nSOLVE\nQUERY manages alice ?\n</computation>"
    },
    {
      "id": 10,
      "user_query": "Which products are in the same category as laptop?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for products in the same category as 'laptop'\n- This involves product categorization\n- Need to find the category of laptop, then other products in that category\n- This is a category-based grouping problem\n\nAPPROACH STRATEGY:\n- Find the category of laptop\n- Find all products in that same category\n- Return those products\n- This is a category lookup and grouping operation\n\nCONNECTION TO BYTELOGIC:\n- Need belongs_to_category relation to store category facts\n- Need query to find products by category\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: belongs_to_category relation for product-category facts\n2. INPUT PROCESSING: add product-category facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query belongs_to_category with laptop's category\n5. OUTPUT FORMATTING: return all products in the same category\n</pseudocode>\n\n<computation>\nREL belongs_to_category\n\nFACT belongs_to_category laptop electronics\nFACT belongs_to_category phone electronics\nFACT belongs_to_category tablet electronics\nFACT belongs_to_category chair furniture\n\nSOLVE\nQUERY belongs_to_category ? electronics\n</computation>"
    },
    {
      "id": 11,
      "user_query": "Who are the friends that both Alice and Bob have?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for mutual friends of Alice and Bob\n- This is an intersection problem\n- Need to find friends of Alice, friends of Bob, then the intersection\n- This is a common connection problem\n\nAPPROACH STRATEGY:\n- Find all friends of Alice\n- Find all friends of Bob\n- Find the intersection of these two sets\n- This requires finding common connections\n\nCONNECTION TO BYTELOGIC:\n- Need friend relation to store friendship facts\n- Need mutual_friend relation for derived facts\n- Need rule to find mutual friends\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: friend (base), mutual_friend (derived)\n2. INPUT PROCESSING: add friendship facts\n3. LOGICAL RULES:\n   - Rule 1: Find mutual friends by matching common connections\n   - SCAN friend where first arg is Alice\n   - JOIN friend where first arg matches Alice's friends\n   - EMIT mutual_friend with Alice, Bob, and common friend\n4. QUERY EXECUTION: query mutual_friend relation with Alice and Bob\n5. OUTPUT FORMATTING: return all mutual friends\n</pseudocode>\n\n<computation>\nREL friend\nREL mutual_friend\n\nFACT friend alice bob\nFACT friend alice charlie\nFACT friend alice diana\nFACT friend bob charlie\nFACT friend bob eve\n\nRULE mutual_friend: SCAN friend MATCH $0, JOIN friend $0, EMIT mutual_friend $1 $2\n\nSOLVE\nQUERY mutual_friend alice bob\n</computation>"
    },
    {
      "id": 12,
      "user_query": "Which employees have worked on the same projects as David?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for employees who worked on projects with David\n- This is a collaboration relationship\n- Need to find projects David worked on, then other employees on those projects\n- This is a common project collaboration problem\n\nAPPROACH STRATEGY:\n- Find projects that David worked on\n- For each project, find other employees\n- Collect all such employees\n- This requires finding common project participants\n\nCONNECTION TO BYTELOGIC:\n- Need works_on relation to store employee-project facts\n- Need collaborator relation for derived facts\n- Need rule to find collaborators\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: works_on (base), collaborator (derived)\n2. INPUT PROCESSING: add employee-project facts\n3. LOGICAL RULES:\n   - Rule 1: Find collaborators by matching common projects\n   - SCAN works_on where first arg is David\n   - JOIN works_on where second arg matches David's projects\n   - EMIT collaborator with David and other employee\n4. QUERY EXECUTION: query collaborator relation with David\n5. OUTPUT FORMATTING: return all collaborators\n</pseudocode>\n\n<computation>\nREL works_on\nREL collaborator\n\nFACT works_on david project_a\nFACT works_on bob project_a\nFACT works_on charlie project_a\nFACT works_on david project_b\nFACT works_on eve project_b\n\nRULE collaborator: SCAN works_on MATCH $1, JOIN works_on $1, EMIT collaborator $0 $2\n\nSOLVE\nQUERY collaborator david ?\n</computation>"
    },
    {
      "id": 13,
      "user_query": "Who are the descendants of Eve?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for all descendants of Eve\n- This is a full transitive closure of the parent relation\n- Need to find children, grandchildren, great-grandchildren, etc.\n- This is a full transitive closure problem\n\nAPPROACH STRATEGY:\n- Find Eve's children\n- For each child, find their children\n- Continue recursively through all generations\n- This is a full transitive closure operation\n\nCONNECTION TO BYTELOGIC:\n- Need parent relation for base facts\n- Need descendant relation for transitive facts\n- Need rules for direct and transitive descendant relationships\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: parent (base), descendant (transitive)\n2. INPUT PROCESSING: add parent-child facts\n3. LOGICAL RULES:\n   - Rule 1: Direct descendants - immediate children\n   - SCAN parent and EMIT descendant with parent and child\n   - Rule 2: Transitive descendants - propagate through generations\n   - SCAN parent and JOIN descendant to find deeper descendants\n   - EMIT descendant with original ancestor and distant descendant\n4. QUERY EXECUTION: query descendant relation with Eve\n5. OUTPUT FORMATTING: return all descendants\n</pseudocode>\n\n<computation>\nREL parent\nREL descendant\n\nFACT parent eve alice\nFACT parent alice bob\nFACT parent bob charlie\nFACT parent eve diana\nFACT parent diana eve2\n\nRULE descendant: SCAN parent, EMIT descendant $1 $0\nRULE descendant: SCAN parent, JOIN descendant $0, EMIT descendant $2 $1\n\nSOLVE\nQUERY descendant eve ?\n</computation>"
    },
    {
      "id": 14,
      "user_query": "Which classes inherit from the Vehicle class?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for classes that inherit from Vehicle\n- This is an inheritance hierarchy problem\n- Need to find direct and indirect inheritance relationships\n- This is a class inheritance lookup\n\nAPPROACH STRATEGY:\n- Find classes that directly inherit from Vehicle\n- Find classes that inherit from those classes (indirect inheritance)\n- Continue for full inheritance tree\n- This is a reverse inheritance lookup\n\nCONNECTION TO BYTELOGIC:\n- Need inherits_from relation to store inheritance facts\n- Need query to find classes by parent class\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: inherits_from relation for class inheritance facts\n2. INPUT PROCESSING: add inheritance facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query inherits_from with Vehicle as parent\n5. OUTPUT FORMATTING: return all inheriting classes\n</pseudocode>\n\n<computation>\nREL inherits_from\n\nFACT inherits_from car vehicle\nFACT inherits_from truck vehicle\nFACT inherits_from sports_car car\n\nSOLVE\nQUERY inherits_from ? vehicle\n</computation>"
    },
    {
      "id": 15,
      "user_query": "Who are the neighbors of node X in the network?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for nodes directly connected to node X\n- This is an undirected graph neighbor problem\n- Need to find all nodes connected by an edge to X\n- This is a direct adjacency lookup\n\nAPPROACH STRATEGY:\n- Find all edges where X is one endpoint\n- Extract the other endpoint from each edge\n- This represents bidirectional connections\n- This is a simple adjacency lookup\n\nCONNECTION TO BYTELOGIC:\n- Need connected relation to store connection facts\n- Need query to extract adjacent nodes\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: connected relation for node connections\n2. INPUT PROCESSING: add connection facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query connected relation with X as one endpoint\n5. OUTPUT FORMATTING: return all connected neighbors\n</pseudocode>\n\n<computation>\nREL connected\n\nFACT connected x y\nFACT connected x z\nFACT connected y w\nFACT connected z a\n\nSOLVE\nQUERY connected x ?\n</computation>"
    },
    {
      "id": 16,
      "user_query": "Which departments are under the same division as HR?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for departments in the same division as HR\n- This involves organizational hierarchy\n- Need to find HR's division, then other departments in that division\n- This is an organizational grouping problem\n\nAPPROACH STRATEGY:\n- Find which division HR belongs to\n- Find all departments in that same division\n- Return those departments\n- This is a division-based grouping lookup\n\nCONNECTION TO BYTELOGIC:\n- Need department_of relation to store department-division facts\n- Need query to find departments by division\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: department_of relation for department-division facts\n2. INPUT PROCESSING: add department-division facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query department_of with HR's division\n5. OUTPUT FORMATTING: return all departments in the same division\n</pseudocode>\n\n<computation>\nREL department_of\n\nFACT department_of hr finance_division\nFACT department_of accounting finance_division\nFACT department_of legal legal_division\n\nSOLVE\nQUERY department_of ? finance_division\n</computation>"
    },
    {
      "id": 17,
      "user_query": "Who are the suppliers that provide materials to the same factories as supplier A?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for suppliers that share factory relationships with supplier A\n- This is a supplier-factory bipartite graph problem\n- Need to find factories supplied by A, then other suppliers of those factories\n- This is a common supplier relationship problem\n\nAPPROACH STRATEGY:\n- Find factories that receive supplies from supplier A\n- For each of those factories, find other suppliers\n- Return all such suppliers\n- This requires finding common factory suppliers\n\nCONNECTION TO BYTELOGIC:\n- Need supplies_to relation to store supplier-factory facts\n- Need shared_factory_supplier relation for derived facts\n- Need rule to find suppliers with common factories\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: supplies_to (base), shared_factory_supplier (derived)\n2. INPUT PROCESSING: add supplier-factory facts\n3. LOGICAL RULES:\n   - Rule 1: Find suppliers with shared factories\n   - SCAN supplies_to where first arg is supplier A\n   - JOIN supplies_to where second arg matches A's factories\n   - EMIT shared_factory_supplier with A and other supplier\n4. QUERY EXECUTION: query shared_factory_supplier with supplier A\n5. OUTPUT FORMATTING: return all suppliers with shared factories\n</pseudocode>\n\n<computation>\nREL supplies_to\nREL shared_factory_supplier\n\nFACT supplies_to a factory_x\nFACT supplies_to b factory_x\nFACT supplies_to c factory_y\nFACT supplies_to a factory_y\n\nRULE shared_factory_supplier: SCAN supplies_to MATCH $1, JOIN supplies_to $1, EMIT shared_factory_supplier $0 $2\n\nSOLVE\nQUERY shared_factory_supplier a ?\n</computation>"
    },
    {
      "id": 18,
      "user_query": "Which genes are associated with the same disease as gene BRCA1?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for genes linked to diseases that BRCA1 is also linked to\n- This is a gene-disease association problem\n- Need to find diseases of BRCA1, then other genes associated with those diseases\n- This is a common disease association problem\n\nAPPROACH STRATEGY:\n- Find diseases associated with BRCA1\n- For each disease, find other genes associated with it\n- Return all such genes\n- This requires finding genes with common disease associations\n\nCONNECTION TO BYTELOGIC:\n- Need associated_with relation to store gene-disease facts\n- Need query to find genes by disease\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: associated_with relation for gene-disease facts\n2. INPUT PROCESSING: add gene-disease association facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query associated_with with BRCA1's diseases\n5. OUTPUT FORMATTING: return all genes with common disease associations\n</pseudocode>\n\n<computation>\nREL associated_with\n\nFACT associated_with brca1 cancer\nFACT associated_with p53 cancer\nFACT associated_with apoe alzheimers\n\nSOLVE\nQUERY associated_with ? cancer\n</computation>"
    },
    {
      "id": 19,
      "user_query": "Who are the students in the same study group as John?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for students in John's study groups\n- This is a group membership problem\n- Need to find groups John belongs to, then other members of those groups\n- This is a group membership lookup\n\nAPPROACH STRATEGY:\n- Find study groups that John is a member of\n- For each group, find other members\n- Return all such students\n- This is a group membership lookup\n\nCONNECTION TO BYTELOGIC:\n- Need member_of relation to store student-group facts\n- Need query to find members by group\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: member_of relation for student-group membership\n2. INPUT PROCESSING: add membership facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query member_of with John's groups\n5. OUTPUT FORMATTING: return all members in John's groups\n</pseudocode>\n\n<computation>\nREL member_of\n\nFACT member_of john group_a\nFACT member_of mary group_a\nFACT member_of bob group_a\nFACT member_of alice group_b\n\nSOLVE\nQUERY member_of ? group_a\n</computation>"
    },
    {
      "id": 20,
      "user_query": "Which books are in the same series as 'Harry Potter'?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for books in the same series as 'Harry Potter'\n- This is a book-series categorization problem\n- Need to find the series of Harry Potter, then other books in that series\n- This is a series-based grouping problem\n\nAPPROACH STRATEGY:\n- Find which series 'Harry Potter' belongs to\n- Find all books in that same series\n- Return those books\n- This is a series-based grouping lookup\n\nCONNECTION TO BYTELOGIC:\n- Need part_of_series relation to store book-series facts\n- Need query to find books by series\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: part_of_series relation for book-series facts\n2. INPUT PROCESSING: add book-series facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query part_of_series with Harry Potter's series\n5. OUTPUT FORMATTING: return all books in the same series\n</pseudocode>\n\n<computation>\nREL part_of_series\n\nFACT part_of_series harry_potter_and_the_sorcerers_stone harry_potter\nFACT part_of_series harry_potter_and_the_chamber_of_secrets harry_potter\nFACT part_of_series lord_of_the_rings fellowship_of_the_ring\n\nSOLVE\nQUERY part_of_series ? harry_potter\n</computation>"
    },
    {
      "id": 21,
      "user_query": "Who are the actors that appeared in the same movies as Tom Hanks?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for actors who co-starred with Tom Hanks\n- This is a collaboration network problem\n- Need to find movies Tom Hanks appeared in, then other actors in those movies\n- This is a common movie collaboration problem\n\nAPPROACH STRATEGY:\n- Find movies that Tom Hanks appeared in\n- For each movie, find other actors\n- Return all such actors\n- This requires finding actors with common movie appearances\n\nCONNECTION TO BYTELOGIC:\n- Need acted_in relation to store actor-movie facts\n- Need co_actor relation for derived facts\n- Need rule to find co-actors\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: acted_in (base), co_actor (derived)\n2. INPUT PROCESSING: add actor-movie facts\n3. LOGICAL RULES:\n   - Rule 1: Find co-actors by matching common movies\n   - SCAN acted_in where first arg is Tom Hanks\n   - JOIN acted_in where second arg matches Hanks' movies\n   - EMIT co_actor with Hanks and other actor\n4. QUERY EXECUTION: query co_actor relation with Tom Hanks\n5. OUTPUT FORMATTING: return all co-actors\n</pseudocode>\n\n<computation>\nREL acted_in\nREL co_actor\n\nFACT acted_in tom_hanks cast_away\nFACT acted_in helen_hunt cast_away\nFACT acted_in tom_hanks forrest_gump\nFACT acted_in robin_wright forrest_gump\n\nRULE co_actor: SCAN acted_in MATCH $1, JOIN acted_in $1, EMIT co_actor $0 $2\n\nSOLVE\nQUERY co_actor tom_hanks ?\n</computation>"
    },
    {
      "id": 22,
      "user_query": "Which proteins interact with the same proteins as protein P53?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for proteins that share interaction partners with P53\n- This is a protein-protein interaction network problem\n- Need to find proteins that P53 interacts with, then proteins that interact with those\n- This is a common interaction partner problem\n\nAPPROACH STRATEGY:\n- Find proteins that P53 interacts with\n- For each of those proteins, find their interaction partners\n- Return all such proteins\n- This requires finding proteins with common interactors\n\nCONNECTION TO BYTELOGIC:\n- Need interacts_with relation to store protein-protein facts\n- Need query to find proteins by interaction partners\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: interacts_with relation for protein-protein interactions\n2. INPUT PROCESSING: add interaction facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query interacts_with with P53's interaction partners\n5. OUTPUT FORMATTING: return all proteins with common interactors\n</pseudocode>\n\n<computation>\nREL interacts_with\n\nFACT interacts_with p53 mdm2\nFACT interacts_with akt1 mtor\nFACT interacts_with mtor p53\n\nSOLVE\nQUERY interacts_with ? p53\n</computation>"
    },
    {
      "id": 23,
      "user_query": "Who are the customers that purchased the same products as customer ID 12345?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for customers who bought products that customer 12345 bought\n- This is a market basket analysis problem\n- Need to find products bought by 12345, then other customers who bought those\n- This is a common purchase pattern problem\n\nAPPROACH STRATEGY:\n- Find products purchased by customer 12345\n- For each product, find other customers who bought it\n- Return all such customers\n- This requires finding customers with common purchases\n\nCONNECTION TO BYTELOGIC:\n- Need purchased relation to store customer-product facts\n- Need similar_customer relation for derived facts\n- Need rule to find customers with common purchases\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: purchased (base), similar_customer (derived)\n2. INPUT PROCESSING: add customer-product facts\n3. LOGICAL RULES:\n   - Rule 1: Find similar customers by matching common purchases\n   - SCAN purchased where first arg is customer 12345\n   - JOIN purchased where second arg matches 12345's products\n   - EMIT similar_customer with 12345 and other customer\n4. QUERY EXECUTION: query similar_customer relation with customer 12345\n5. OUTPUT FORMATTING: return all similar customers\n</pseudocode>\n\n<computation>\nREL purchased\nREL similar_customer\n\nFACT purchased customer_12345 product_a\nFACT purchased customer_67890 product_a\nFACT purchased customer_12345 product_b\nFACT purchased customer_abcde product_a\n\nRULE similar_customer: SCAN purchased MATCH $1, JOIN purchased $1, EMIT similar_customer $0 $2\n\nSOLVE\nQUERY similar_customer customer_12345 ?\n</computation>"
    },
    {
      "id": 24,
      "user_query": "Which countries share borders with the same countries as France?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for countries that share borders with France's neighbors\n- This is a geographic adjacency problem\n- Need to find France's neighbors, then countries bordering those neighbors\n- This is a common geographic adjacency problem\n\nAPPROACH STRATEGY:\n- Find countries that border France\n- For each neighbor, find its other bordering countries\n- Return all such countries\n- This requires finding countries with common neighbors\n\nCONNECTION TO BYTELOGIC:\n- Need borders relation to store country-country facts\n- Need query to find countries by common neighbors\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: borders relation for country-country borders\n2. INPUT PROCESSING: add border facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query borders with France's neighbors\n5. OUTPUT FORMATTING: return all countries with common neighbors\n</pseudocode>\n\n<computation>\nREL borders\n\nFACT borders france germany\nFACT borders france spain\nFACT borders germany poland\nFACT borders spain portugal\n\nSOLVE\nQUERY borders france ?\n</computation>"
    },
    {
      "id": 25,
      "user_query": "Who are the researchers collaborating with the same institutions as Dr. Smith?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for researchers affiliated with institutions where Dr. Smith also collaborates\n- This is a researcher-institution collaboration problem\n- Need to find institutions Dr. Smith works with, then other researchers there\n- This is a common institutional collaboration problem\n\nAPPROACH STRATEGY:\n- Find institutions where Dr. Smith collaborates\n- For each institution, find other researchers\n- Return all such researchers\n- This requires finding researchers with common institutions\n\nCONNECTION TO BYTELOGIC:\n- Need affiliated_with relation to store researcher-institution facts\n- Need query to find researchers by common institutions\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: affiliated_with relation for researcher-institution facts\n2. INPUT PROCESSING: add affiliation facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query affiliated_with with Smith's institutions\n5. OUTPUT FORMATTING: return all researchers with common affiliations\n</pseudocode>\n\n<computation>\nREL affiliated_with\n\nFACT affiliated_with dr_smith mit\nFACT affiliated_with dr_jones mit\nFACT affiliated_with dr_brown stanford\nFACT affiliated_with dr_smith stanford\n\nSOLVE\nQUERY affiliated_with ? mit\n</computation>"
    },
    {
      "id": 26,
      "user_query": "Which software packages depend on the same libraries as package X?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for packages that share library dependencies with package X\n- This is a software dependency graph problem\n- Need to find libraries that X depends on, then other packages depending on those\n- This is a common dependency problem\n\nAPPROACH STRATEGY:\n- Find libraries that package X depends on\n- For each library, find other packages that depend on it\n- Return all such packages\n- This requires finding packages with common dependencies\n\nCONNECTION TO BYTELOGIC:\n- Need depends_on relation to store package-library facts\n- Need similar_package relation for derived facts\n- Need rule to find packages with common dependencies\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: depends_on (base), similar_package (derived)\n2. INPUT PROCESSING: add dependency facts\n3. LOGICAL RULES:\n   - Rule 1: Find similar packages by matching common dependencies\n   - SCAN depends_on where first arg is package X\n   - JOIN depends_on where second arg matches X's libraries\n   - EMIT similar_package with X and other package\n4. QUERY EXECUTION: query similar_package relation with package X\n5. OUTPUT FORMATTING: return all similar packages\n</pseudocode>\n\n<computation>\nREL depends_on\nREL similar_package\n\nFACT depends_on package_x library_a\nFACT depends_on package_y library_a\nFACT depends_on package_z library_b\nFACT depends_on package_x library_b\n\nRULE similar_package: SCAN depends_on MATCH $1, JOIN depends_on $1, EMIT similar_package $0 $2\n\nSOLVE\nQUERY similar_package package_x ?\n</computation>"
    },
    {
      "id": 27,
      "user_query": "Who are the teachers in the same department as Professor Johnson?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for teachers in Professor Johnson's department\n- This is an organizational structure problem\n- Need to find Johnson's department, then other teachers in that department\n- This is a department-based grouping problem\n\nAPPROACH STRATEGY:\n- Find which department Professor Johnson belongs to\n- Find all teachers in that same department\n- Return those teachers\n- This is a department membership lookup\n\nCONNECTION TO BYTELOGIC:\n- Need teacher_in_dept relation to store teacher-department facts\n- Need query to find teachers by department\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: teacher_in_dept relation for teacher-department assignment\n2. INPUT PROCESSING: add assignment facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query teacher_in_dept with Johnson's department\n5. OUTPUT FORMATTING: return all teachers in the same department\n</pseudocode>\n\n<computation>\nREL teacher_in_dept\n\nFACT teacher_in_dept prof_johnson computer_science\nFACT teacher_in_dept dr_smith computer_science\nFACT teacher_in_dept prof_williams mathematics\n\nSOLVE\nQUERY teacher_in_dept ? computer_science\n</computation>"
    },
    {
      "id": 28,
      "user_query": "Which genes regulate the same target genes as transcription factor TF1?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for transcription factors that regulate genes regulated by TF1\n- This is a gene regulatory network problem\n- Need to find target genes of TF1, then other regulators of those genes\n- This is a common target gene regulator problem\n\nAPPROACH STRATEGY:\n- Find genes regulated by transcription factor TF1\n- For each target gene, find other transcription factors regulating it\n- Return all such transcription factors\n- This requires finding TFs with common targets\n\nCONNECTION TO BYTELOGIC:\n- Need regulates relation to store TF-target facts\n- Need query to find TFs by common targets\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: regulates relation for TF-target gene facts\n2. INPUT PROCESSING: add regulation facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query regulates with TF1's target genes\n5. OUTPUT FORMATTING: return all TFs with common targets\n</pseudocode>\n\n<computation>\nREL regulates\n\nFACT regulates tf1 gene_a\nFACT regulates tf2 gene_a\nFACT regulates tf1 gene_b\nFACT regulates tf3 gene_c\n\nSOLVE\nQUERY regulates ? gene_a\n</computation>"
    },
    {
      "id": 29,
      "user_query": "Who are the players on teams that compete in the same league as Team A?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for players on teams in the same league as Team A\n- This is a sports league hierarchy problem\n- Need to find Team A's league, then other teams in that league, then their players\n- This is a league-based grouping problem\n\nAPPROACH STRATEGY:\n- Find which league Team A competes in\n- Find all teams in that same league\n- For each team, find all players\n- Return all such players\n- This requires finding players via league connection\n\nCONNECTION TO BYTELOGIC:\n- Need team_in_league and player_on_team relations to store league-team-player facts\n- Need query to find players by league\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: team_in_league and player_on_team for league-team-player facts\n2. INPUT PROCESSING: add league-team and team-player facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query team_in_league with Team A's league\n5. OUTPUT FORMATTING: return all players on teams in Team A's league\n</pseudocode>\n\n<computation>\nREL team_in_league\nREL player_on_team\n\nFACT team_in_league team_a nba\nFACT team_in_league team_b nba\nFACT player_on_team player_x team_a\nFACT player_on_team player_y team_b\n\nSOLVE\nQUERY team_in_league team_a ?\n</computation>"
    },
    {
      "id": 30,
      "user_query": "Which compounds have similar molecular pathways to compound C123?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for compounds that affect the same biological pathways as C123\n- This is a bioinformatics similarity problem\n- Need to find pathways affected by C123, then other compounds affecting those\n- This is a common pathway compound problem\n\nAPPROACH STRATEGY:\n- Find biological pathways affected by compound C123\n- For each pathway, find other compounds that affect it\n- Return all such compounds\n- This requires finding compounds with common pathways\n\nCONNECTION TO BYTELOGIC:\n- Need affects_pathway relation to store compound-pathway facts\n- Need query to find compounds by common pathways\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: affects_pathway relation for compound-pathway facts\n2. INPUT PROCESSING: add compound-pathway facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query affects_pathway with C123's pathways\n5. OUTPUT FORMATTING: return all compounds with common pathways\n</pseudocode>\n\n<computation>\nREL affects_pathway\n\nFACT affects_pathway c123 pathway_a\nFACT affects_pathway c456 pathway_a\nFACT affects_pathway c123 pathway_b\n\nSOLVE\nQUERY affects_pathway ? pathway_a\n</computation>"
    },
    {
      "id": 31,
      "user_query": "Who are the users that belong to the same groups as user U456?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for users in the same groups as user U456\n- This is a user-group membership problem\n- Need to find groups U456 belongs to, then other users in those groups\n- This is a common group membership problem\n\nAPPROACH STRATEGY:\n- Find groups that user U456 belongs to\n- For each group, find other members\n- Return all such users\n- This requires finding users with common group memberships\n\nCONNECTION TO BYTELOGIC:\n- Need member_of_group relation to store user-group facts\n- Need query to find users by common groups\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: member_of_group relation for user-group membership\n2. INPUT PROCESSING: add membership facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query member_of_group with U456's groups\n5. OUTPUT FORMATTING: return all users with common group memberships\n</pseudocode>\n\n<computation>\nREL member_of_group\n\nFACT member_of_group u456 group_alpha\nFACT member_of_group u789 group_alpha\nFACT member_of_group u123 group_beta\n\nSOLVE\nQUERY member_of_group ? group_alpha\n</computation>"
    },
    {
      "id": 32,
      "user_query": "Which proteins are expressed in the same tissues as protein ACTN1?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for proteins expressed in tissues where ACTN1 is also expressed\n- This is a proteomics co-expression problem\n- Need to find tissues where ACTN1 is expressed, then other proteins there\n- This is a common tissue expression problem\n\nAPPROACH STRATEGY:\n- Find tissues where protein ACTN1 is expressed\n- For each tissue, find other proteins expressed there\n- Return all such proteins\n- This requires finding proteins with common tissue expressions\n\nCONNECTION TO BYTELOGIC:\n- Need expressed_in relation to store protein-tissue facts\n- Need query to find proteins by common tissues\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: expressed_in relation for protein-tissue expression\n2. INPUT PROCESSING: add expression facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query expressed_in with ACTN1's tissues\n5. OUTPUT FORMATTING: return all proteins with common tissue expressions\n</pseudocode>\n\n<computation>\nREL expressed_in\n\nFACT expressed_in actn1 muscle\nFACT expressed_in myh1 muscle\nFACT expressed_in actn1 heart\n\nSOLVE\nQUERY expressed_in ? muscle\n</computation>"
    },
    {
      "id": 33,
      "user_query": "Who are the vendors that supply to the same clients as vendor V789?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for vendors that share clients with vendor V789\n- This is a business relationship problem\n- Need to find clients of V789, then other vendors serving those clients\n- This is a common client vendor problem\n\nAPPROACH STRATEGY:\n- Find clients that vendor V789 supplies to\n- For each client, find other vendors\n- Return all such vendors\n- This requires finding vendors with common clients\n\nCONNECTION TO BYTELOGIC:\n- Need supplies_to_client relation to store vendor-client facts\n- Need competitor relation for derived facts\n- Need rule to find vendors with common clients\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: supplies_to_client (base), competitor (derived)\n2. INPUT PROCESSING: add vendor-client facts\n3. LOGICAL RULES:\n   - Rule 1: Find competitors by matching common clients\n   - SCAN supplies_to_client where first arg is vendor V789\n   - JOIN supplies_to_client where second arg matches V789's clients\n   - EMIT competitor with V789 and other vendor\n4. QUERY EXECUTION: query competitor relation with vendor V789\n5. OUTPUT FORMATTING: return all competitors\n</pseudocode>\n\n<computation>\nREL supplies_to_client\nREL competitor\n\nFACT supplies_to_client v789 client_a\nFACT supplies_to_client v123 client_a\nFACT supplies_to_client v789 client_b\n\nRULE competitor: SCAN supplies_to_client MATCH $1, JOIN supplies_to_client $1, EMIT competitor $0 $2\n\nSOLVE\nQUERY competitor v789 ?\n</computation>"
    },
    {
      "id": 34,
      "user_query": "Which diseases are associated with the same symptoms as disease D001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for diseases that share symptoms with D001\n- This is a medical symptom-disease association problem\n- Need to find symptoms of D001, then other diseases with those symptoms\n- This is a common symptom association problem\n\nAPPROACH STRATEGY:\n- Find symptoms associated with disease D001\n- For each symptom, find other diseases that have it\n- Return all such diseases\n- This requires finding diseases with common symptoms\n\nCONNECTION TO BYTELOGIC:\n- Need has_symptom relation to store disease-symptom facts\n- Need query to find diseases by common symptoms\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: has_symptom relation for disease-symptom facts\n2. INPUT PROCESSING: add disease-symptom facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query has_symptom with D001's symptoms\n5. OUTPUT FORMATTING: return all diseases with common symptoms\n</pseudocode>\n\n<computation>\nREL has_symptom\n\nFACT has_symptom d001 fever\nFACT has_symptom d002 fever\nFACT has_symptom d001 cough\n\nSOLVE\nQUERY has_symptom ? fever\n</computation>"
    },
    {
      "id": 35,
      "user_query": "Who are the developers that contribute to the same repositories as dev X?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for developers who contribute to repositories where dev X contributes\n- This is a software collaboration network problem\n- Need to find repos dev X contributes to, then other contributors to those repos\n- This is a common repository contributor problem\n\nAPPROACH STRATEGY:\n- Find repositories that developer X contributes to\n- For each repository, find other contributors\n- Return all such developers\n- This requires finding developers with common repositories\n\nCONNECTION TO BYTELOGIC:\n- Need contributes_to_repo relation to store developer-repository facts\n- Need query to find developers by common repositories\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: contributes_to_repo relation for developer-repository facts\n2. INPUT PROCESSING: add contribution facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query contributes_to_repo with X's repositories\n5. OUTPUT FORMATTING: return all developers with common repositories\n</pseudocode>\n\n<computation>\nREL contributes_to_repo\n\nFACT contributes_to_repo dev_x repo_a\nFACT contributes_to_repo dev_y repo_a\nFACT contributes_to_repo dev_x repo_b\n\nSOLVE\nQUERY contributes_to_repo ? repo_a\n</computation>"
    },
    {
      "id": 36,
      "user_query": "Which drugs target the same receptors as drug DRUG001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for drugs that target the same receptors as DRUG001\n- This is a pharmacology target prediction problem\n- Need to find receptors targeted by DRUG001, then other drugs targeting those\n- This is a common target receptor problem\n\nAPPROACH STRATEGY:\n- Find receptors that drug DRUG001 targets\n- For each receptor, find other drugs that target it\n- Return all such drugs\n- This requires finding drugs with common targets\n\nCONNECTION TO BYTELOGIC:\n- Need targets_receptor relation to store drug-receptor facts\n- Need query to find drugs by common targets\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: targets_receptor relation for drug-receptor facts\n2. INPUT PROCESSING: add drug-receptor facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query targets_receptor with DRUG001's receptors\n5. OUTPUT FORMATTING: return all drugs with common targets\n</pseudocode>\n\n<computation>\nREL targets_receptor\n\nFACT targets_receptor drug001 receptor_a\nFACT targets_receptor drug002 receptor_a\nFACT targets_receptor drug001 receptor_b\n\nSOLVE\nQUERY targets_receptor ? receptor_a\n</computation>"
    },
    {
      "id": 37,
      "user_query": "Who are the artists featured on albums with artist ARTIST01?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for artists who appear on albums with ARTIST01\n- This is a music collaboration problem\n- Need to find albums ARTIST01 is on, then other artists on those albums\n- This is a common album collaboration problem\n\nAPPROACH STRATEGY:\n- Find albums that feature artist ARTIST01\n- For each album, find other featured artists\n- Return all such artists\n- This requires finding artists with common album appearances\n\nCONNECTION TO BYTELOGIC:\n- Need featured_on_album relation to store artist-album facts\n- Need query to find artists by common albums\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: featured_on_album relation for artist-album facts\n2. INPUT PROCESSING: add artist-album facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query featured_on_album with ARTIST01's albums\n5. OUTPUT FORMATTING: return all artists with common album appearances\n</pseudocode>\n\n<computation>\nREL featured_on_album\n\nFACT featured_on_album artist01 album_a\nFACT featured_on_album artist02 album_a\nFACT featured_on_album artist01 album_b\n\nSOLVE\nQUERY featured_on_album ? album_a\n</computation>"
    },
    {
      "id": 38,
      "user_query": "Which companies operate in the same markets as company COMP01?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for companies operating in markets where COMP01 also operates\n- This is a business competition analysis problem\n- Need to find markets of COMP01, then other companies in those markets\n- This is a common market competition problem\n\nAPPROACH STRATEGY:\n- Find markets where company COMP01 operates\n- For each market, find other operating companies\n- Return all such companies\n- This requires finding companies with common markets\n\nCONNECTION TO BYTELOGIC:\n- Need operates_in_market relation to store company-market facts\n- Need query to find companies by common markets\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: operates_in_market relation for company-market facts\n2. INPUT PROCESSING: add company-market facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query operates_in_market with COMP01's markets\n5. OUTPUT FORMATTING: return all companies with common markets\n</pseudocode>\n\n<computation>\nREL operates_in_market\n\nFACT operates_in_market comp01 market_a\nFACT operates_in_market comp02 market_a\nFACT operates_in_market comp01 market_b\n\nSOLVE\nQUERY operates_in_market ? market_a\n</computation>"
    },
    {
      "id": 39,
      "user_query": "Who are the authors that have written for the same publishers as author AUTHOR01?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for authors who publish with the same publishers as AUTHOR01\n- This is a publishing industry relationship problem\n- Need to find publishers of AUTHOR01, then other authors published there\n- This is a common publisher author problem\n\nAPPROACH STRATEGY:\n- Find publishers that have published AUTHOR01's works\n- For each publisher, find other authors they publish\n- Return all such authors\n- This requires finding authors with common publishers\n\nCONNECTION TO BYTELOGIC:\n- Need published_by relation to store author-publisher facts\n- Need query to find authors by common publishers\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: published_by relation for author-publisher facts\n2. INPUT PROCESSING: add author-publisher facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query published_by with AUTHOR01's publishers\n5. OUTPUT FORMATTING: return all authors with common publishers\n</pseudocode>\n\n<computation>\nREL published_by\n\nFACT published_by author01 publisher_a\nFACT published_by author02 publisher_a\nFACT published_by author01 publisher_b\n\nSOLVE\nQUERY published_by ? publisher_a\n</computation>"
    },
    {
      "id": 40,
      "user_query": "Which enzymes participate in the same metabolic pathways as enzyme ENZ001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for enzymes in the same metabolic pathways as ENZ001\n- This is a biochemical pathway analysis problem\n- Need to find pathways ENZ001 participates in, then other enzymes in those\n- This is a common pathway enzyme problem\n\nAPPROACH STRATEGY:\n- Find metabolic pathways that enzyme ENZ001 participates in\n- For each pathway, find other participating enzymes\n- Return all such enzymes\n- This requires finding enzymes with common pathways\n\nCONNECTION TO BYTELOGIC:\n- Need participates_in_pathway relation to store enzyme-pathway facts\n- Need query to find enzymes by common pathways\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: participates_in_pathway relation for enzyme-pathway facts\n2. INPUT PROCESSING: add enzyme-pathway facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query participates_in_pathway with ENZ001's pathways\n5. OUTPUT FORMATTING: return all enzymes with common pathways\n</pseudocode>\n\n<computation>\nREL participates_in_pathway\n\nFACT participates_in_pathway enz001 glycolysis\nFACT participates_in_pathway enz002 glycolysis\nFACT participates_in_pathway enz001 tca_cycle\n\nSOLVE\nQUERY participates_in_pathway ? glycolysis\n</computation>"
    },
    {
      "id": 41,
      "user_query": "Who are the pilots that fly for the same airlines as pilot PILOT01?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for pilots who work for the same airlines as PILOT01\n- This is an employment relationship problem\n- Need to find airlines PILOT01 works for, then other pilots there\n- This is a common employer pilot problem\n\nAPPROACH STRATEGY:\n- Find airlines that employ pilot PILOT01\n- For each airline, find other pilots employed there\n- Return all such pilots\n- This requires finding pilots with common employers\n\nCONNECTION TO BYTELOGIC:\n- Need pilot_for_airline relation to store pilot-airline facts\n- Need query to find pilots by common airlines\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: pilot_for_airline relation for pilot-airline facts\n2. INPUT PROCESSING: add pilot-airline facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query pilot_for_airline with PILOT01's airlines\n5. OUTPUT FORMATTING: return all pilots with common airlines\n</pseudocode>\n\n<computation>\nREL pilot_for_airline\n\nFACT pilot_for_airline pilot01 airline_a\nFACT pilot_for_airline pilot02 airline_a\nFACT pilot_for_airline pilot01 airline_b\n\nSOLVE\nQUERY pilot_for_airline ? airline_a\n</computation>"
    },
    {
      "id": 42,
      "user_query": "Which diseases have the same genetic causes as disease GENETIC01?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for diseases with the same genetic causes as GENETIC01\n- This is a genetic disease association problem\n- Need to find genetic causes of GENETIC01, then other diseases with those\n- This is a common genetic cause problem\n\nAPPROACH STRATEGY:\n- Find genetic causes associated with disease GENETIC01\n- For each genetic cause, find other diseases caused by it\n- Return all such diseases\n- This requires finding diseases with common genetic causes\n\nCONNECTION TO BYTELOGIC:\n- Need caused_by_gene relation to store disease-genetic facts\n- Need query to find diseases by common genetic causes\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: caused_by_gene relation for disease-genetic facts\n2. INPUT PROCESSING: add disease-genetic facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query caused_by_gene with GENETIC01's genes\n5. OUTPUT FORMATTING: return all diseases with common genetic causes\n</pseudocode>\n\n<computation>\nREL caused_by_gene\n\nFACT caused_by_gene genetic01 gene_a\nFACT caused_by_gene genetic02 gene_a\nFACT caused_by_gene genetic01 gene_b\n\nSOLVE\nQUERY caused_by_gene ? gene_a\n</computation>"
    },
    {
      "id": 43,
      "user_query": "Who are the designers that work for the same fashion houses as designer FASH01?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for designers working at fashion houses where FASH01 also works\n- This is a creative industry employment problem\n- Need to find fashion houses employing FASH01, then other designers there\n- This is a common employer designer problem\n\nAPPROACH STRATEGY:\n- Find fashion houses that employ designer FASH01\n- For each house, find other designers employed there\n- Return all such designers\n- This requires finding designers with common employers\n\nCONNECTION TO BYTELOGIC:\n- Need designer_for_house relation to store designer-fashion facts\n- Need query to find designers by common fashion houses\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: designer_for_house relation for designer-fashion facts\n2. INPUT PROCESSING: add designer-fashion facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query designer_for_house with FASH01's houses\n5. OUTPUT FORMATTING: return all designers with common employers\n</pseudocode>\n\n<computation>\nREL designer_for_house\n\nFACT designer_for_house fash01 gucci\nFACT designer_for_house fash02 gucci\nFACT designer_for_house fash01 chanel\n\nSOLVE\nQUERY designer_for_house ? gucci\n</computation>"
    },
    {
      "id": 44,
      "user_query": "Which proteins have similar domain structures to protein DOM001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for proteins with similar domain structures to DOM001\n- This is a structural bioinformatics problem\n- Need to find domains of DOM001, then other proteins with those domains\n- This is a common domain structure problem\n\nAPPROACH STRATEGY:\n- Find protein domains present in protein DOM001\n- For each domain, find other proteins containing it\n- Return all such proteins\n- This requires finding proteins with common domains\n\nCONNECTION TO BYTELOGIC:\n- Need has_domain relation to store protein-domain facts\n- Need query to find proteins by common domains\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: has_domain relation for protein-domain facts\n2. INPUT PROCESSING: add protein-domain facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query has_domain with DOM001's domains\n5. OUTPUT FORMATTING: return all proteins with common domains\n</pseudocode>\n\n<computation>\nREL has_domain\n\nFACT has_domain dom001 sh2_domain\nFACT has_domain prot002 sh2_domain\nFACT has_domain dom001 kinase_domain\n\nSOLVE\nQUERY has_domain ? sh2_domain\n</computation>"
    },
    {
      "id": 45,
      "user_query": "Who are the athletes competing in the same sports as athlete ATH001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for athletes in the same sports as ATH001\n- This is a sports participation problem\n- Need to find sports ATH001 competes in, then other athletes in those sports\n- This is a common sport athlete problem\n\nAPPROACH STRATEGY:\n- Find sports that athlete ATH001 competes in\n- For each sport, find other competing athletes\n- Return all such athletes\n- This requires finding athletes with common sports\n\nCONNECTION TO BYTELOGIC:\n- Need competes_in_sport relation to store athlete-sport facts\n- Need query to find athletes by common sports\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: competes_in_sport relation for athlete-sport facts\n2. INPUT PROCESSING: add athlete-sport facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query competes_in_sport with ATH001's sports\n5. OUTPUT FORMATTING: return all athletes with common sports\n</pseudocode>\n\n<computation>\nREL competes_in_sport\n\nFACT competes_in_sport ath001 tennis\nFACT competes_in_sport ath002 tennis\nFACT competes_in_sport ath001 swimming\n\nSOLVE\nQUERY competes_in_sport ? tennis\n</computation>"
    },
    {
      "id": 46,
      "user_query": "Which drugs have similar side effects to drug SIDE001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for drugs with similar side effects to SIDE001\n- This is a pharmaceutical similarity problem\n- Need to find side effects of SIDE001, then other drugs causing those\n- This is a common side effect problem\n\nAPPROACH STRATEGY:\n- Find side effects associated with drug SIDE001\n- For each side effect, find other drugs that cause it\n- Return all such drugs\n- This requires finding drugs with common side effects\n\nCONNECTION TO BYTELOGIC:\n- Need causes_side_effect relation to store drug-side facts\n- Need query to find drugs by common side effects\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: causes_side_effect relation for drug-side facts\n2. INPUT PROCESSING: add drug-side effect facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query causes_side_effect with SIDE001's side effects\n5. OUTPUT FORMATTING: return all drugs with common side effects\n</pseudocode>\n\n<computation>\nREL causes_side_effect\n\nFACT causes_side_effect side001 nausea\nFACT causes_side_effect side002 nausea\nFACT causes_side_effect side001 headache\n\nSOLVE\nQUERY causes_side_effect ? nausea\n</computation>"
    },
    {
      "id": 47,
      "user_query": "Who are the musicians that perform in the same genres as musician MUS001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for musicians performing in genres where MUS001 also performs\n- This is a music genre classification problem\n- Need to find genres of MUS001, then other musicians in those genres\n- This is a common genre musician problem\n\nAPPROACH STRATEGY:\n- Find musical genres that musician MUS001 performs in\n- For each genre, find other musicians performing in it\n- Return all such musicians\n- This requires finding musicians with common genres\n\nCONNECTION TO BYTELOGIC:\n- Need performs_in_genre relation to store musician-genre facts\n- Need query to find musicians by common genres\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: performs_in_genre relation for musician-genre facts\n2. INPUT PROCESSING: add musician-genre facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query performs_in_genre with MUS001's genres\n5. OUTPUT FORMATTING: return all musicians with common genres\n</pseudocode>\n\n<computation>\nREL performs_in_genre\n\nFACT performs_in_genre mus001 rock\nFACT performs_in_genre mus002 rock\nFACT performs_in_genre mus001 pop\n\nSOLVE\nQUERY performs_in_genre ? rock\n</computation>"
    },
    {
      "id": 48,
      "user_query": "Which plants are found in the same ecosystems as plant PLANT001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for plants in the same ecosystems as PLANT001\n- This is an ecological co-occurrence problem\n- Need to find ecosystems where PLANT001 grows, then other plants there\n- This is a common ecosystem plant problem\n\nAPPROACH STRATEGY:\n- Find ecosystems where plant PLANT001 is found\n- For each ecosystem, find other plants growing there\n- Return all such plants\n- This requires finding plants with common ecosystems\n\nCONNECTION TO BYTELOGIC:\n- Need found_in_ecosystem relation to store plant-ecosystem facts\n- Need query to find plants by common ecosystems\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: found_in_ecosystem relation for plant-ecosystem facts\n2. INPUT PROCESSING: add plant-ecosystem facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query found_in_ecosystem with PLANT001's ecosystems\n5. OUTPUT FORMATTING: return all plants with common ecosystems\n</pseudocode>\n\n<computation>\nREL found_in_ecosystem\n\nFACT found_in_ecosystem plant001 forest\nFACT found_in_ecosystem plant002 forest\nFACT found_in_ecosystem plant001 grassland\n\nSOLVE\nQUERY found_in_ecosystem ? forest\n</computation>"
    },
    {
      "id": 49,
      "user_query": "Who are the writers that have collaborated with the same editors as writer WRITE001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for writers who collaborate with editors that WRITE001 also works with\n- This is a publishing collaboration problem\n- Need to find editors of WRITE001, then other writers they edit\n- This is a common editor writer problem\n\nAPPROACH STRATEGY:\n- Find editors that have worked with writer WRITE001\n- For each editor, find other writers they work with\n- Return all such writers\n- This requires finding writers with common editors\n\nCONNECTION TO BYTELOGIC:\n- Need edited_by relation to store writer-editor facts\n- Need query to find writers by common editors\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: edited_by relation for writer-editor facts\n2. INPUT PROCESSING: add writer-editor facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query edited_by with WRITE001's editors\n5. OUTPUT FORMATTING: return all writers with common editors\n</pseudocode>\n\n<computation>\nREL edited_by\n\nFACT edited_by write001 editor_a\nFACT edited_by write002 editor_a\nFACT edited_by write001 editor_b\n\nSOLVE\nQUERY edited_by ? editor_a\n</computation>"
    },
    {
      "id": 50,
      "user_query": "Which bacteria share the same antibiotic resistances as bacterium BAC001?",
      "complete_response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Query asks for bacteria with the same antibiotic resistances as BAC001\n- This is a microbiology resistance profile problem\n- Need to find resistances of BAC001, then other bacteria with those resistances\n- This is a common resistance profile problem\n\nAPPROACH STRATEGY:\n- Find antibiotic resistances possessed by bacterium BAC001\n- For each resistance, find other bacteria that have it\n- Return all such bacteria\n- This requires finding bacteria with common resistances\n\nCONNECTION TO BYTELOGIC:\n- Need resistant_to_antibiotic relation to store bacteria-antibiotic facts\n- Need query to find bacteria by common resistances\n</thinking>\n\n<pseudocode>\nALGORITHM DESIGN:\n1. DECLARE RELATIONS: resistant_to_antibiotic relation for bacteria-antibiotic facts\n2. INPUT PROCESSING: add bacteria-antibiotic resistance facts\n3. LOGICAL RULES: none needed for direct lookup\n4. QUERY EXECUTION: query resistant_to_antibiotic with BAC001's antibiotics\n5. OUTPUT FORMATTING: return all bacteria with common resistances\n</pseudocode>\n\n<computation>\nREL resistant_to_antibiotic\n\nFACT resistant_to_antibiotic bac001 penicillin\nFACT resistant_to_antibiotic bac002 penicillin\nFACT resistant_to_antibiotic bac001 streptomycin\n\nSOLVE\nQUERY resistant_to_antibiotic ? penicillin\n</computation>"
    }
  ]
}