{"id": "crud_016", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Design a simple user profile management system with basic CRUD operations", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need to create a user profile management system\n- Should support Create, Read, Update, Delete operations\n- Must handle user data like name, email, profile info\n- Should include basic validation and error handling\n\nSTRATEGIC APPROACH:\n- Create user profile service with standard CRUD methods\n- Design simple data model for user profiles\n- Include validation for required fields\n- Add error handling for common scenarios\n\nDESIGN PREPARATION:\n- User profile data model\n- CRUD operation methods\n- Validation requirements\n- Error handling patterns\n</thinking>\n\n<blueprint>\nService UserProfileService {\n  description: \"Manages user profile information with CRUD operations\",\n  \n  dependencies: {\n    storage: UserProfileDatabase\n  },\n  \n  methods: {\n    createUser(profile: UserProfileInput) -> UserProfile {\n      preconditions: [profile data is valid],\n      postconditions: [user profile created with unique ID],\n      errors: [InvalidProfileData, DuplicateEmail]\n    },\n    \n    getUser(userId: string) -> UserProfile {\n      preconditions: [userId is valid],\n      postconditions: [returns user profile or null if not found],\n      errors: [UserNotFound]\n    },\n    \n    updateUser(userId: string, updates: UserProfileInput) -> UserProfile {\n      preconditions: [userId valid, updates valid],\n      postconditions: [user profile updated with new values],\n      errors: [UserNotFound, InvalidUpdates]\n    },\n    \n    deleteUser(userId: string) -> bool {\n      preconditions: [userId is valid],\n      postconditions: [user profile deleted, returns success status],\n      errors: [UserNotFound]\n    },\n    \n    listUsers(limit: int, offset: int) -> UserProfile[] {\n      preconditions: [limit and offset are valid],\n      postconditions: [returns list of user profiles]\n    }\n  }\n}\n\nType UserProfile {\n  id: string,\n  name: string,\n  email: string,\n  bio: string?,\n  avatarUrl: string?,\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType UserProfileInput {\n  name: string,\n  email: string,\n  bio: string?,\n  avatarUrl: string?\n}\n\nDatabase UserProfileDatabase {\n  Table UserProfiles {\n    columns: {\n      id: {type: String, primaryKey: true},\n      name: {type: String, required: true},\n      email: {type: String, required: true, unique: true},\n      bio: {type: String},\n      avatarUrl: {type: String},\n      createdAt: {type: Timestamp},\n      updatedAt: {type: Timestamp}\n    },\n    indexes: [\n      {name: \"idx_email\", columns: [\"email\"]}\n    ]\n  }\n}\n\nValidation ProfileValidation {\n  name: {minLength: 1, maxLength: 100},\n  email: {pattern: \"^[\\\\w.-]+@[\\\\w.-]+\\\\.[a-zA-Z]{2,}$\"},\n  bio: {maxLength: 500}\n}\n</blueprint>"}
{"id": "crud_017", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Create a simple todo list system with add, view, update, delete functionality", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need to create a todo list management system\n- Should support Create, Read, Update, Delete operations\n- Must handle todo items with title, description, completion status\n- Should include basic validation and error handling\n\nSTRATEGIC APPROACH:\n- Create todo list service with standard CRUD methods\n- Design simple data model for todo items\n- Include validation for required fields\n- Add error handling for common scenarios\n\nDESIGN PREPARATION:\n- Todo item data model\n- CRUD operation methods\n- Validation requirements\n- Error handling patterns\n</thinking>\n\n<blueprint>\nService TodoListService {\n  description: \"Manages todo list items with CRUD operations\",\n  \n  dependencies: {\n    storage: TodoListDatabase\n  },\n  \n  methods: {\n    createTodo(todo: TodoInput) -> TodoItem {\n      preconditions: [todo data is valid],\n      postconditions: [todo item created with unique ID and defaults],\n      errors: [InvalidTodoData]\n    },\n    \n    getTodo(todoId: string) -> TodoItem {\n      preconditions: [todoId is valid],\n      postconditions: [returns todo item or null if not found],\n      errors: [TodoNotFound]\n    },\n    \n    updateTodo(todoId: string, updates: TodoUpdate) -> TodoItem {\n      preconditions: [todoId valid, updates valid],\n      postconditions: [todo item updated with new values],\n      errors: [TodoNotFound, InvalidUpdates]\n    },\n    \n    deleteTodo(todoId: string) -> bool {\n      preconditions: [todoId is valid],\n      postconditions: [todo item deleted, returns success status],\n      errors: [TodoNotFound]\n    },\n    \n    listTodos(completed: bool?) -> TodoItem[] {\n      preconditions: [],\n      postconditions: [returns list of todo items, optionally filtered by completion status]\n    }\n  }\n}\n\nType TodoItem {\n  id: string,\n  title: string,\n  description: string?,\n  completed: bool,\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType TodoInput {\n  title: string,\n  description: string?\n}\n\nType TodoUpdate {\n  title?: string,\n  description?: string?,\n  completed?: bool\n}\n\nDatabase TodoListDatabase {\n  Table TodoItems {\n    columns: {\n      id: {type: String, primaryKey: true},\n      title: {type: String, required: true},\n      description: {type: String},\n      completed: {type: Bool, default: false},\n      createdAt: {type: Timestamp},\n      updatedAt: {type: Timestamp}\n    },\n    indexes: [\n      {name: \"idx_completed\", columns: [\"completed\"]}\n    ]\n  }\n}\n\nValidation TodoValidation {\n  title: {minLength: 1, maxLength: 200},\n  description: {maxLength: 1000}\n}\n</blueprint>"}
{"id": "crud_018", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Design a simple note-taking application with basic CRUD operations", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need to create a note-taking application\n- Should support Create, Read, Update, Delete operations\n- Must handle note content, title, tags, creation/modification dates\n- Should include basic validation and error handling\n\nSTRATEGIC APPROACH:\n- Create note-taking service with standard CRUD methods\n- Design simple data model for notes\n- Include validation for required fields\n- Add error handling for common scenarios\n\nDESIGN PREPARATION:\n- Note data model\n- CRUD operation methods\n- Validation requirements\n- Error handling patterns\n</thinking>\n\n<blueprint>\nService NoteTakingService {\n  description: \"Manages notes with CRUD operations\",\n  \n  dependencies: {\n    storage: NotesDatabase\n  },\n  \n  methods: {\n    createNote(note: NoteInput) -> Note {\n      preconditions: [note data is valid],\n      postconditions: [note created with unique ID and timestamps],\n      errors: [InvalidNoteData]\n    },\n    \n    getNote(noteId: string) -> Note {\n      preconditions: [noteId is valid],\n      postconditions: [returns note or null if not found],\n      errors: [NoteNotFound]\n    },\n    \n    updateNote(noteId: string, updates: NoteUpdate) -> Note {\n      preconditions: [noteId valid, updates valid],\n      postconditions: [note updated with new values],\n      errors: [NoteNotFound, InvalidUpdates]\n    },\n    \n    deleteNote(noteId: string) -> bool {\n      preconditions: [noteId is valid],\n      postconditions: [note deleted, returns success status],\n      errors: [NoteNotFound]\n    },\n    \n    listNotes(tagFilter: string?) -> Note[] {\n      preconditions: [],\n      postconditions: [returns list of notes, optionally filtered by tag]\n    }\n  }\n}\n\nType Note {\n  id: string,\n  title: string,\n  content: string,\n  tags: string[],\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType NoteInput {\n  title: string,\n  content: string,\n  tags: string[]\n}\n\nType NoteUpdate {\n  title?: string,\n  content?: string,\n  tags?: string[]\n}\n\nDatabase NotesDatabase {\n  Table Notes {\n    columns: {\n      id: {type: String, primaryKey: true},\n      title: {type: String, required: true},\n      content: {type: String, required: true},\n      createdAt: {type: Timestamp},\n      updatedAt: {type: Timestamp}\n    },\n    indexes: [\n      {name: \"idx_title\", columns: [\"title\"]}\n    ]\n  },\n  \n  Table NoteTags {\n    columns: {\n      noteId: {type: String, foreignKey: \"Notes.id\"},\n      tag: {type: String}\n    },\n    indexes: [\n      {name: \"idx_note_tag\", columns: [\"noteId\", \"tag\"]}\n    ]\n  }\n}\n\nValidation NoteValidation {\n  title: {minLength: 1, maxLength: 200},\n  content: {maxLength: 10000},\n  tags: {maxCount: 10, maxLength: 50}\n}\n</blueprint>"}
{"id": "crud_019", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Build a simple bookmark management system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need to create a bookmark management system\n- Should support Create, Read, Update, Delete operations\n- Must handle URLs, titles, descriptions, and tags\n- Should include URL validation and error handling\n\nSTRATEGIC APPROACH:\n- Create bookmark service with standard CRUD methods\n- Design simple data model for bookmarks\n- Include URL validation\n- Add error handling for common scenarios\n\nDESIGN PREPARATION:\n- Bookmark data model\n- CRUD operation methods\n- URL validation requirements\n- Error handling patterns\n</thinking>\n\n<blueprint>\nService BookmarkService {\n  description: \"Manages bookmarks with CRUD operations\",\n  \n  dependencies: {\n    storage: BookmarksDatabase\n  },\n  \n  methods: {\n    createBookmark(bookmark: BookmarkInput) -> Bookmark {\n      preconditions: [bookmark URL is valid],\n      postconditions: [bookmark created with unique ID and metadata],\n      errors: [InvalidUrl, DuplicateUrl]\n    },\n    \n    getBookmark(bookmarkId: string) -> Bookmark {\n      preconditions: [bookmarkId is valid],\n      postconditions: [returns bookmark or null if not found],\n      errors: [BookmarkNotFound]\n    },\n    \n    updateBookmark(bookmarkId: string, updates: BookmarkUpdate) -> Bookmark {\n      preconditions: [bookmarkId valid, URL valid if provided],\n      postconditions: [bookmark updated with new values],\n      errors: [BookmarkNotFound, InvalidUrl]\n    },\n    \n    deleteBookmark(bookmarkId: string) -> bool {\n      preconditions: [bookmarkId is valid],\n      postconditions: [bookmark deleted, returns success status],\n      errors: [BookmarkNotFound]\n    },\n    \n    listBookmarks(tagFilter: string?) -> Bookmark[] {\n      preconditions: [],\n      postconditions: [returns list of bookmarks, optionally filtered by tag]\n    },\n    \n    searchBookmarks(query: string) -> Bookmark[] {\n      preconditions: [query is provided],\n      postconditions: [returns bookmarks matching the search query]\n    }\n  }\n}\n\nType Bookmark {\n  id: string,\n  url: string,\n  title: string,\n  description: string?,\n  tags: string[],\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType BookmarkInput {\n  url: string,\n  title: string,\n  description: string?,\n  tags: string[]\n}\n\nType BookmarkUpdate {\n  url?: string,\n  title?: string,\n  description?: string?,\n  tags?: string[]\n}\n\nDatabase BookmarksDatabase {\n  Table Bookmarks {\n    columns: {\n      id: {type: String, primaryKey: true},\n      url: {type: String, required: true, unique: true},\n      title: {type: String, required: true},\n      description: {type: String},\n      createdAt: {type: Timestamp},\n      updatedAt: {type: Timestamp}\n    },\n    indexes: [\n      {name: \"idx_url\", columns: [\"url\"]},\n      {name: \"idx_title\", columns: [\"title\"]}\n    ]\n  },\n  \n  Table BookmarkTags {\n    columns: {\n      bookmarkId: {type: String, foreignKey: \"Bookmarks.id\"},\n      tag: {type: String}\n    },\n    indexes: [\n      {name: \"idx_bookmark_tag\", columns: [\"bookmarkId\", \"tag\"]}\n    ]\n  }\n}\n\nValidation BookmarkValidation {\n  url: {pattern: \"^(https?://)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([/\\w \\.-]*)*/?$\"},\n  title: {minLength: 1, maxLength: 200},\n  description: {maxLength: 500},\n  tags: {maxCount: 10, maxLength: 50}\n}\n</blueprint>"}