{"id": "blueprint_advmath_001", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Quadratic equation solver", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to solve for the roots of a quadratic equation `ax^2 + bx + c = 0`.\n- It needs the coefficients `a`, `b`, and `c` as inputs.\n- It must handle cases for two real roots, one real root, and two complex roots based on the discriminant (b^2 - 4ac).\n\nSTRATEGIC APPROACH:\n- Design a `QuadraticSolver` service.\n- Implement a `solve` method that takes `a`, `b`, and `c`.\n- The method will first calculate the discriminant. If `a` is 0, it's not a quadratic equation, which is an error case.\n- If the discriminant is positive, calculate two real roots.\n- If the discriminant is zero, calculate one real root.\n- If the discriminant is negative, calculate two complex roots.\n\nDESIGN PREPARATION:\n- A `QuadraticSolver` service with a `solve` method.\n- Inputs: `a: float`, `b: float`, `c: float`.\n- A `QuadraticSolution` result type to hold the real and imaginary parts of the roots.\n- Error handling for `NotAQuadraticEquation` (when `a` is 0).\n</thinking>\n\n<blueprint>\nService QuadraticSolver {\n  description: \"Solves for the roots of a quadratic equation (ax^2 + bx + c = 0).\",\n  methods: {\n    solve(a: float, b: float, c: float) -> QuadraticSolution {\n      preconditions: [a != 0],\n      postconditions: [returns the real and/or complex roots of the equation],\n      errors: [NotAQuadraticEquation]\n    }\n  }\n}\n\nType Root {\n  realPart: float,\n  imaginaryPart: float\n}\n\nType QuadraticSolution {\n  root1: Root,\n  root2: Root,\n  numberOfRealRoots: int\n}\n</blueprint>"}{"id": "blueprint_advmath_002", "category": "advanced_math_physics", "difficulty": "intermediate", "user_query": "Matrix multiplication service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to multiply two matrices, A and B.\n- Matrix multiplication is only possible if the number of columns in matrix A is equal to the number of rows in matrix B.\n- The input will be two 2D arrays (matrices).\n\nSTRATEGIC APPROACH:\n- Design a `MatrixMath` service.\n- Implement a `multiply` method that takes two matrices as input.\n- The method must first validate the dimensions of the input matrices.\n- It will then perform the multiplication using nested loops and return the resulting matrix.\n\nDESIGN PREPARATION:\n- A `Matrix` type (a 2D array of floats).\n- A `MatrixMath` service with a `multiply` method.\n- Inputs: `matrixA: Matrix`, `matrixB: Matrix`.\n- Error handling for `MismatchedDimensions`.\n</king>\n\n<blueprint>\nService MatrixMath {\n  description: \"Performs matrix operations like multiplication.\",\n  methods: {\n    multiply(matrixA: array[array[float]], matrixB: array[array[float]]) -> array[array[float]] {\n      preconditions: [number of columns in matrixA equals number of rows in matrixB, matrices are not empty],\n      postconditions: [returns the resulting matrix from the multiplication],\n      errors: [MismatchedDimensions, InvalidMatrix]\n    }\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_003", "category": "advanced_math_physics", "difficulty": "intermediate", "user_query": "Vector operations service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to perform common operations on 2D or 3D vectors.\n- Operations should include dot product, cross product (for 3D), and magnitude.\n- The service needs to handle vectors of different dimensions correctly.\n\nSTRATEGIC APPROACH:\n- Design a `VectorMath` service.\n- Implement separate methods for each operation: `dotProduct`, `crossProduct`, `magnitude`.\n- The methods should validate that the input vectors have the correct dimensions for the operation.\n\nDESIGN PREPARATION:\n- A `Vector` type (an array of floats).\n- A `VectorMath` service.\n- `dotProduct(vectorA: Vector, vectorB: Vector)` method.\n- `crossProduct(vectorA: Vector, vectorB: Vector)` method (for 3D vectors only).\n- `magnitude(vector: Vector)` method.\n- Error handling for `MismatchedDimensions` or `InvalidDimensionForOperation`.\n</king>\n\n<blueprint>\nService VectorMath {\n  description: \"Performs vector operations like dot product, cross product, and magnitude.\",\n  methods: {\n    dotProduct(vectorA: array[float], vectorB: array[float]) -> float {\n      preconditions: [vectors have the same, non-zero dimension],\n      postconditions: [returns the scalar dot product of the two vectors],\n      errors: [MismatchedDimensions]\n    },\n    crossProduct(vectorA: array[float], vectorB: array[float]) -> array[float] {\n      preconditions: [both vectors must have exactly 3 dimensions],\n      postconditions: [returns the 3D vector representing the cross product],\n      errors: [InvalidDimensionForOperation]\n    },\n    magnitude(vector: array[float]) -> float {\n      preconditions: [vector is not empty],\n      postconditions: [returns the scalar magnitude (length) of the vector],\n      errors: [InvalidVector]\n    }\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_004", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Statistical calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate basic descriptive statistics for a list of numbers.\n- The required statistics are mean, median, mode, and standard deviation.\n\nSTRATEGIC APPROACH:\n- Design a `StatisticsCalculator` service.\n- Implement a single `calculate` method that takes a list of numbers and returns all desired statistics in one object.\n- This is more efficient than calling separate methods for each statistic.\n\nDESIGN PREPARATION:\n- A `StatisticsCalculator` service with a `calculate` method.\n- Input: `data: array[float]`.\n- A `StatisticsResult` type to hold the `mean`, `median`, `mode` (which could be an array), and `standardDeviation`.\n- Error handling for empty input lists.\n</king>\n\n<blueprint>\nService StatisticsCalculator {\n  description: \"Calculates mean, median, mode, and standard deviation for a list of numbers.\",\n  methods: {\n    calculate(data: array[float]) -> StatisticsResult {\n      preconditions: [data array is not empty],\n      postconditions: [returns an object containing the calculated statistics],\n      errors: [EmptyDataSet]\n    }\n  }\n}\n\nType StatisticsResult {\n  mean: float,\n  median: float,\n  mode: array[float],\n  standardDeviation: float,\n  count: int\n}\n</blueprint>"}{"id": "blueprint_advmath_005", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Prime number generator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to generate a list of all prime numbers up to a specified integer limit.\n- This requires an efficient algorithm to avoid long computation times for large limits.\n\nSTRATEGIC APPROACH:\n- Design a `PrimeGenerator` service.\n- Implement a `generatePrimesUpTo` method.\n- Use an efficient algorithm like the Sieve of Eratosthenes to perform the prime generation.\n\nDESIGN PREPARATION:\n- A `PrimeGenerator` service with a `generatePrimesUpTo` method.\n- Input: `limit: int`.\n- The method returns an `array[int]`.\n- Error handling for limits less than 2.\n</king>\n\n<blueprint>\nService PrimeGenerator {\n  description: \"Generates a list of prime numbers up to a specified limit.\",\n  methods: {\n    generatePrimesUpTo(limit: int) -> array[int] {\n      preconditions: [limit >= 2],\n      postconditions: [returns an array of all prime numbers from 2 up to the limit],\n      errors: [InvalidLimit]\n    }\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_006", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Fibonacci sequence generator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to generate the Fibonacci sequence up to the Nth term.\n- The sequence starts with 0 and 1, and each subsequent term is the sum of the two preceding ones.\n\nSTRATEGIC APPROACH:\n- Design a `FibonacciGenerator` service.\n- Implement a `generateSequence` method that takes an integer `n`.\n- The method will iteratively calculate the sequence up to the Nth term and return it as a list.\n\nDESIGN PREPARATION:\n- A `FibonacciGenerator` service with a `generateSequence` method.\n- Input: `n: int` (the number of terms to generate).\n- The method returns an `array[int]`.\n- Error handling for `n` less than 1.\n</king>\n\n<blueprint>\nService FibonacciGenerator {\n  description: \"Generates the Fibonacci sequence up to the Nth term.\",\n  methods: {\n    generateSequence(n: int) -> array[int] {\n      preconditions: [n > 0],\n      postconditions: [returns an array containing the first n terms of the Fibonacci sequence],\n      errors: [InvalidCount]\n    }\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_007", "category": "advanced_math_physics", "difficulty": "intermediate", "user_query": "Projectile motion calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate key metrics of projectile motion in a 2D plane, ignoring air resistance.\n- Inputs are the initial velocity, launch angle, and initial height.\n- Outputs should include maximum height, total flight time, and range (horizontal distance).\n\nSTRATEGIC APPROACH:\n- Design a `ProjectileMotionCalculator` service.\n- Implement a `calculate` method that takes the initial conditions.\n- Use standard kinematic equations to calculate the desired metrics.\n\nDESIGN PREPARATION:\n- A `ProjectileMotionCalculator` service with a `calculate` method.\n- Inputs: `initialVelocity: float`, `launchAngleDegrees: float`, `initialHeight: float`.\n- A `ProjectileResult` type to hold `maxHeight`, `flightTime`, and `range`.\n- Assume a standard gravity value (e.g., 9.81 m/s^2), or allow it to be an optional input.\n- Error handling for invalid inputs (e.g., negative velocity).\n</king>\n\n<blueprint>\nService ProjectileMotionCalculator {\n  description: \"Calculates the trajectory of a projectile given initial velocity and angle.\",\n  methods: {\n    calculate(initialVelocity: float, launchAngleDegrees: float, initialHeight: float, gravity: float) -> ProjectileResult {\n      preconditions: [initialVelocity >= 0, launchAngleDegrees between 0 and 90, initialHeight >= 0, gravity > 0],\n      postconditions: [returns the calculated max height, flight time, and horizontal range],\n      errors: [InvalidInput]\n    }\n  }\n}\n\nType ProjectileResult {\n  maxHeight: float,\n  flightTime: float,\n  range: float\n}\n</blueprint>"}{"id": "blueprint_advmath_008", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Kinetic energy calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate the kinetic energy of an object based on the formula E = 0.5 * m * v^2.\n- Inputs are the object's mass and velocity.\n\nSTRATEGIC APPROACH:\n- Design a `PhysicsCalculator` service or add to an existing one.\n- Implement a `calculateKineticEnergy` method.\n- The method will take mass and velocity, validate them, and apply the formula.\n\nDESIGN PREPARATION:\n- A `PhysicsCalculator` service with a `calculateKineticEnergy` method.\n- Inputs: `mass: float`, `velocity: float`.\n- The method returns a float representing the energy.\n- Input validation for non-negative mass.\n</king>\n\n<blueprint>\nService PhysicsCalculator {\n  description: \"Calculates various basic physics formulas.\",\n  methods: {\n    calculateKineticEnergy(mass: float, velocity: float) -> float {\n      preconditions: [mass >= 0],\n      postconditions: [returns the calculated kinetic energy],\n      errors: [InvalidMass]\n    }\n    // ... other physics methods could be added here\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_009", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Ohm's law calculator (voltage, current, resistance)", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to solve for any one variable of Ohm's Law (V=IR) given the other two.\n- It should be flexible enough to calculate voltage, current, or resistance.\n\nSTRATEGIC APPROACH:\n- Design an `OhmsLawCalculator` service.\n- Implement three separate methods for clarity: `calculateVoltage`, `calculateCurrent`, `calculateResistance`.\n- This avoids ambiguity and complex input structures.\n\nDESIGN PREPARATION:\n- An `OhmsLawCalculator` service.\n- `calculateVoltage(current: float, resistance: float)` method.\n- `calculateCurrent(voltage: float, resistance: float)` method.\n- `calculateResistance(voltage: float, current: float)` method.\n- Error handling for division by zero.\n</king>\n\n<blueprint>\nService OhmsLawCalculator {\n  description: \"Calculates voltage, current, or resistance using Ohm's Law (V=IR).\",\n  methods: {\n    calculateVoltage(current: float, resistance: float) -> float {\n      preconditions: [],\n      postconditions: [returns the calculated voltage],\n      errors: []\n    },\n    calculateCurrent(voltage: float, resistance: float) -> float {\n      preconditions: [resistance != 0],\n      postconditions: [returns the calculated current],\n      errors: [DivisionByZero]\n    },\n    calculateResistance(voltage: float, current: float) -> float {\n      preconditions: [current != 0],\n      postconditions: [returns the calculated resistance],\n      errors: [DivisionByZero]\n    }\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_010", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Simple interest calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate simple interest based on the formula I = P * r * t.\n- Inputs are the principal amount, the annual interest rate, and the time period.\n- It should be able to return both the interest amount and the total final amount.\n\nSTRATEGIC APPROACH:\n- Design a `SimpleInterestCalculator` service.\n- Implement a `calculate` method that takes principal, rate, and time.\n- The method will return a result object containing the interest and the total amount.\n\nDESIGN PREPARATION:\n- A `SimpleInterestCalculator` service with a `calculate` method.\n- Inputs: `principal: float`, `annualRate: float`, `timeInYears: float`.\n- A `InterestResult` type to hold `interestAmount` and `totalAmount`.\n- Validation for non-negative inputs.\n</king>\n\n<blueprint>\nService SimpleInterestCalculator {\n  description: \"Calculates simple interest and the total final amount.\",\n  methods: {\n    calculate(principal: float, annualRate: float, timeInYears: float) -> InterestResult {\n      preconditions: [principal >= 0, annualRate >= 0, timeInYears >= 0],\n      postconditions: [returns the calculated simple interest and the total final amount],\n      errors: [InvalidInput]\n    }\n  }\n}\n\nType InterestResult {\n  interestAmount: float,\n  totalAmount: float\n}\n</blueprint>"}{"id": "blueprint_advmath_011", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Area and perimeter calculator (for various shapes)", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate the area and perimeter of various common 2D shapes.\n- It should handle shapes like circles, squares, rectangles, and triangles.\n\nSTRATEGIC APPROACH:\n- Design a `GeometryCalculator` service.\n- Implement separate methods for each shape to ensure clear and simple inputs.\n- For example, `calculateCircleMetrics`, `calculateRectangleMetrics`, etc.\n- Each method will return an object with both area and perimeter.\n\nDESIGN PREPARATION:\n- A `GeometryCalculator` service.\n- `calculateCircleMetrics(radius: float)` method.\n- `calculateRectangleMetrics(length: float, width: float)` method.\n- `calculateTriangleMetrics(sideA: float, sideB: float, sideC: float, base: float, height: float)` method.\n- A `ShapeMetrics` result type (area, perimeter).\n- Validation for valid shape dimensions (e.g., radius > 0, triangle inequality).\n</king>\n\n<blueprint>\nService GeometryCalculator {\n  description: \"Calculates the area and perimeter of various 2D shapes.\",\n  methods: {\n    calculateCircleMetrics(radius: float) -> ShapeMetrics {\n      preconditions: [radius > 0],\n      postconditions: [returns the area and circumference of the circle],\n      errors: [InvalidDimensions]\n    },\n    calculateRectangleMetrics(length: float, width: float) -> ShapeMetrics {\n      preconditions: [length > 0, width > 0],\n      postconditions: [returns the area and perimeter of the rectangle],\n      errors: [InvalidDimensions]\n    },\n    calculateTriangleMetrics(sideA: float, sideB: float, sideC: float, base: float, height: float) -> ShapeMetrics {\n      preconditions: [all sides > 0, sides satisfy the triangle inequality, base and height > 0],\n      postconditions: [returns the area and perimeter of the triangle],\n      errors: [InvalidDimensions]\n    }\n  }\n}\n\nType ShapeMetrics {\n  shape: string,\n  area: float,\n  perimeter: float\n}\n</blueprint>"}{"id": "blueprint_advmath_012", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Volume calculator (for various 3D shapes)", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate the volume of various common 3D shapes.\n- It should handle shapes like cubes, spheres, cylinders, and cones.\n\nSTRATEGIC APPROACH:\n- Design a `SolidGeometryCalculator` service.\n- Implement separate methods for each shape to keep inputs clear and specific.\n- Each method will take the necessary dimensions and return the calculated volume.\n\nDESIGN PREPARATION:\n- A `SolidGeometryCalculator` service.\n- `calculateCubeVolume(sideLength: float)` method.\n- `calculateSphereVolume(radius: float)` method.\n- `calculateCylinderVolume(radius: float, height: float)` method.\n- `calculateConeVolume(radius: float, height: float)` method.\n- Validation for non-negative dimensions.\n</king>\n\n<blueprint>\nService SolidGeometryCalculator {\n  description: \"Calculates the volume of various 3D shapes.\",\n  methods: {\n    calculateCubeVolume(sideLength: float) -> float {\n      preconditions: [sideLength >= 0],\n      postconditions: [returns the volume of the cube],\n      errors: [InvalidDimensions]\n    },\n    calculateSphereVolume(radius: float) -> float {\n      preconditions: [radius >= 0],\n      postconditions: [returns the volume of the sphere],\n      errors: [InvalidDimensions]\n    },\n    calculateCylinderVolume(radius: float, height: float) -> float {\n      preconditions: [radius >= 0, height >= 0],\n      postconditions: [returns the volume of the cylinder],\n      errors: [InvalidDimensions]\n    },\n    calculateConeVolume(radius: float, height: float) -> float {\n      preconditions: [radius >= 0, height >= 0],\n      postconditions: [returns the volume of the cone],\n      errors: [InvalidDimensions]\n    }\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_013", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Factorial calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to compute the factorial of a non-negative integer `n` (n!).\n- The factorial is the product of all positive integers up to `n`.\n\nSTRATEGIC APPROACH:\n- Design a `FactorialCalculator` service.\n- Implement a `calculate` method that takes an integer `n`.\n- Use an iterative approach to calculate the product to avoid stack overflow issues that can occur with recursion for large `n`.\n\nDESIGN PREPARATION:\n- A `FactorialCalculator` service with a `calculate` method.\n- Input: `n: int`.\n- Output: a float or a large integer type to handle large results.\n- Validation to ensure `n` is a non-negative integer.\n</king>\n\n<blueprint>\nService FactorialCalculator {\n  description: \"Computes the factorial of a non-negative integer (n!).\",\n  methods: {\n    calculate(n: int) -> float {\n      preconditions: [n >= 0],\n      postconditions: [returns the factorial of n],\n      errors: [InvalidInput]\n    }\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_014", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Logarithm calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate logarithms.\n- It should be able to calculate the logarithm of a number for a specified base, including common cases like natural log (base e) and log base 10.\n\nSTRATEGIC APPROACH:\n- Design a `LogarithmCalculator` service.\n- Implement a single `calculate` method that takes the number and the base.\n- Most math libraries can calculate natural logs, so the formula `log_b(x) = log_e(x) / log_e(b)` can be used for arbitrary bases.\n\nDESIGN PREPARATION:\n- A `LogarithmCalculator` service with a `calculate` method.\n- Inputs: `number: float`, `base: float`.\n- Validation to ensure the number and base are positive, and the base is not 1.\n</king>\n\n<blueprint>\nService LogarithmCalculator {\n  description: \"Calculates the logarithm of a number for a given base.\",\n  methods: {\n    calculate(number: float, base: float) -> float {\n      preconditions: [number > 0, base > 0, base != 1],\n      postconditions: [returns the logarithm of the number for the specified base],\n      errors: [InvalidInput, DomainError]\n    }\n  }\n}\n</blueprint>"}{"id": "blueprint_advmath_015", "category": "advanced_math_physics", "difficulty": "basic", "user_query": "Relativistic Energy Calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate the rest energy of an object using Einstein's mass-energy equivalence formula, E = mc^2.\n- The input is the mass of the object.\n- The speed of light, `c`, is a constant.\n\nSTRATEGIC APPROACH:\n- Design a `RelativisticEnergyCalculator` service.\n- The service will have the constant for the speed of light defined internally.\n- Implement a `calculateRestEnergy` method that takes mass as input and applies the formula.\n\nDESIGN PREPARATION:\n- A `RelativisticEnergyCalculator` service with a `calculateRestEnergy` method.\n- Input: `massInKg: float`.\n- The service will use a constant `SPEED_OF_LIGHT = 299792458.0` m/s.\n- Validation to ensure mass is non-negative.\n</king>\n\n<blueprint>\nService RelativisticEnergyCalculator {\n  description: \"Calculates the rest energy of an object using E=mc^2.\",\n  constants: {\n    SPEED_OF_LIGHT: 299792458.0 // meters per second\n  },\n  methods: {\n    calculateRestEnergy(massInKg: float) -> float {\n      preconditions: [massInKg >= 0],\n      postconditions: [returns the calculated rest energy in Joules],\n      errors: [InvalidMass]\n    }\n  }\n}\n</blueprint>"}