{"id": "q_calc_026", "category": "simple_calculations", "difficulty": "basic", "user_query": "Grade point average calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need to calculate Grade Point Average (GPA) from grades and credit hours\n- Should handle different grading scales (letter grades, percentage, etc.)\n- Must provide accurate calculations using standard GPA formula\n- Should support both semester and cumulative GPA calculations\n\nSTRATEGIC APPROACH:\n- Create a GPACalculator service with calculation methods\n- Implement GPA formula: GPA = sum(grade_points * credit_hours) / total_credit_hours\n- Support different grading scales and conversions\n- Include validation for realistic grade values and credit hours\n- Provide detailed breakdown of the calculation\n\nDESIGN PREPARATION:\n- Core calculation methods: calculateGPA, calculateSemesterGPA, convertGradeToPoints\n- Supporting methods: validateGradeInput, formatGPA\n- Input validation for grades, credit hours, and grading scales\n- Result formatting with detailed breakdown\n</thinking>\n\n<blueprint>\nService GPACalculator {\n  description: \"Calculates Grade Point Average from grades and credit hours\",\n  \n  methods: {\n    calculateGPA(courses: CourseGrade[]) -> GPACalculationResult {\n      preconditions: [courses not empty, all grades valid, credit hours positive],\n      postconditions: [returns cumulative GPA with detailed breakdown],\n      errors: [InvalidGradeData]\n    },\n    \n    calculateSemesterGPA(courses: CourseGrade[]) -> GPACalculationResult {\n      preconditions: [courses not empty, all grades valid, credit hours positive],\n      postconditions: [returns semester GPA with detailed breakdown]\n    },\n    \n    convertGradeToPoints(grade: string, scale: GradingScale) -> float {\n      preconditions: [valid grade for scale],\n      postconditions: [returns corresponding grade points]\n    },\n    \n    getGradeEquivalent(gradePoints: float, scale: GradingScale) -> string {\n      preconditions: [valid grade points and scale],\n      postconditions: [returns equivalent letter grade]\n    },\n    \n    validateGradeInput(course: CourseGrade) -> ValidationResult {\n      preconditions: [course data provided],\n      postconditions: [returns validation result]\n    }\n  }\n}\n\nType GPACalculationResult {\n  gpa: float,\n  totalGradePoints: float,\n  totalCreditHours: float,\n  courseCount: int,\n  courses: CourseGrade[],\n  calculationDate: timestamp\n}\n\nType CourseGrade {\n  courseName: string,\n  grade: string,\n  creditHours: float,\n  gradePoints: float,\n  gradeScale: GradingScale\n}\n\nType GradingScale {\n  enum: [\"letter_4.0\", \"letter_5.0\", \"percentage\", \"pass_fail\"]\n}\n\nType ValidationResult {\n  isValid: bool,\n  errors: string[],\n  warnings: string[]\n}\n\nValidation GPAConstraints {\n  minCreditHours: {value: 0.5, unit: \"credit hours\"},\n  maxCreditHours: {value: 10, unit: \"credit hours\"},\n  minGPA: {value: 0.0},\n  maxGPA: {value: 5.0},  // Accommodating 5.0 scale\n  minGradePoints: {value: 0.0},\n  maxGradePoints: {value: 5.0}\n}\n\nOperation CalculateGPA {\n  type: \"calculation\",\n  inputs: [\"courses\"],\n  formula: \"GPA = sum(grade_points * credit_hours) / total_credit_hours\",\n  steps: [\n    \"convert each grade to grade points based on scale\",\n    \"multiply grade points by credit hours for each course\",\n    \"sum all grade points * credit hours\",\n    \"sum all credit hours\",\n    \"divide total grade points by total credit hours\"\n  ],\n  postconditions: [returns calculated GPA with breakdown]\n}\n\nScenario gpa_calculation_accuracy {\n  Preconditions: [valid course grades and credit hours],\n  \n  Given I have 3 courses: A (3 credits), B+ (4 credits), A- (3 credits),\n  When calculateGPA is called using 4.0 scale,\n  Then the GPA should be calculated as: ((4.0*3) + (3.3*4) + (3.7*3)) / (3+4+3),\n  And the result should be approximately 3.69.\n  \n  Postconditions: [accurate GPA calculation returned]\n}\n</blueprint>", "validation": {"has_thinking": true, "has_blueprint": true, "thinking_structure": ["problem_understanding", "strategic_approach", "design_preparation"], "blueprint_syntax_valid": true, "blueprint_completeness": ["service_definition", "methods_with_contracts", "types", "validation_rules", "operations", "scenarios"]}}
{"id": "q_calc_027", "category": "simple_calculations", "difficulty": "basic", "user_query": "Calorie burn calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need to calculate calories burned during physical activities\n- Should handle different types of exercises and intensities\n- Must provide accurate calculations using metabolic equivalent (MET) values\n- Should consider user factors like weight, age, and gender\n\nSTRATEGIC APPROACH:\n- Create a CalorieBurnCalculator service with calculation methods\n- Implement calorie calculation using MET values: Calories = MET * body_weight(kg) * time(hours)\n- Support various activities with different MET values\n- Include user profile factors for more accurate calculations\n- Provide validation for realistic activity durations and weights\n\nDESIGN PREPARATION:\n- Core calculation methods: calculateCaloriesBurned, estimateActivityCalories\n- Supporting methods: getMETValue, adjustForUserProfile\n- Activity database with MET values for different exercises\n- Input validation for weight, time, and activity parameters\n</thinking>\n\n<blueprint>\nService CalorieBurnCalculator {\n  description: \"Calculates calories burned during physical activities\",\n  \n  methods: {\n    calculateCaloriesBurned(activity: ActivityType, durationMinutes: int, userWeightKg: float, intensity: ActivityIntensity?) -> CalorieBurnResult {\n      preconditions: [valid activity, duration > 0, weight > 0],\n      postconditions: [returns estimated calories burned with details],\n      errors: [InvalidActivityParameters]\n    },\n    \n    estimateActivityCalories(activity: string, durationMinutes: int, userWeightKg: float) -> CalorieBurnResult {\n      preconditions: [duration > 0, weight > 0],\n      postconditions: [returns estimated calories for custom activity]\n    },\n    \n    getMETValue(activity: ActivityType, intensity: ActivityIntensity?) -> float {\n      preconditions: [valid activity and intensity],\n      postconditions: [returns metabolic equivalent value]\n    },\n    \n    calculateTotalCaloriesForSession(activities: ActivitySession[]) -> TotalCalorieResult {\n      preconditions: [activities not empty, all valid],\n      postconditions: [returns total calories burned for session]\n    },\n    \n    suggestActivitiesForCalorieTarget(calorieTarget: int, userWeightKg: float) -> ActivitySuggestion[] {\n      preconditions: [calorieTarget > 0, weight > 0],\n      postconditions: [returns activities to achieve target calories]\n    }\n  }\n}\n\nType CalorieBurnResult {\n  activity: ActivityType,\n  durationMinutes: int,\n  userWeightKg: float,\n  metValue: float,\n  caloriesBurned: int,\n  intensity: ActivityIntensity?,\n  calculationDate: timestamp\n}\n\nType TotalCalorieResult {\n  totalCalories: int,\n  sessionDuration: int,  // in minutes\n  activities: CalorieBurnResult[],\n  averageCaloriesPerMinute: float\n}\n\nType ActivityType {\n  enum: [\"running\", \"walking\", \"cycling\", \"swimming\", \"weight_training\", \"yoga\", \"tennis\", \"basketball\", \"soccer\", \"hiking\", \"dancing\", \"rowing\", \"elliptical\", \"stair_climbing\"]\n}\n\nType ActivityIntensity {\n  enum: [\"light\", \"moderate\", \"vigorous\", \"very_vigorous\"]\n}\n\nType ActivitySession {\n  activity: ActivityType,\n  durationMinutes: int,\n  intensity: ActivityIntensity?\n}\n\nType ActivitySuggestion {\n  activity: ActivityType,\n  durationRequired: int,  // in minutes\n  caloriesExpected: int,\n  intensity: ActivityIntensity?\n}\n\nValidation CalorieConstraints {\n  minWeight: {value: 25, unit: \"kg\"},  // Approximately 55 lbs\n  maxWeight: {value: 500, unit: \"kg\"},  // Approximately 1100 lbs\n  minDuration: {value: 1, unit: \"minutes\"},\n  maxDuration: {value: 1440, unit: \"minutes\"},  // 24 hours\n  minCalories: {value: 1, unit: \"calories\"},\n  maxCalories: {value: 10000, unit: \"calories\"}\n}\n\nOperation CalculateCaloriesBurned {\n  type: \"calculation\",\n  inputs: [\"activity\", \"durationMinutes\", \"userWeightKg\", \"intensity\"],\n  formula: \"Calories = MET * body_weight(kg) * time(hours)\",\n  steps: [\n    \"get MET value for activity and intensity\",\n    \"convert duration from minutes to hours\",\n    \"apply calorie formula\",\n    \"round to nearest integer\"\n  ],\n  postconditions: [returns estimated calories burned]\n}\n\nScenario calorie_calculation_accuracy {\n  Preconditions: [valid activity, duration, and weight],\n  \n  Given a person weighing 70kg runs for 30 minutes at moderate intensity,\n  When calculateCaloriesBurned is called,\n  Then the MET value for running should be applied,\n  And the result should be approximately 300-400 calories depending on exact MET.\n  \n  Postconditions: [accurate calorie calculation returned]\n}\n</blueprint>", "validation": {"has_thinking": true, "has_blueprint": true, "thinking_structure": ["problem_understanding", "strategic_approach", "design_preparation"], "blueprint_syntax_valid": true, "blueprint_completeness": ["service_definition", "methods_with_contracts", "types", "validation_rules", "operations", "scenarios"]}}
{"id": "q_calc_028", "category": "simple_calculations", "difficulty": "basic", "user_query": "Budget allocation calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need to calculate budget allocations based on income and spending categories\n- Should handle percentage-based and fixed-amount allocations\n- Must provide accurate calculations for various budgeting methods (50/30/20, envelope method, etc.)\n- Should support tracking of remaining funds after allocations\n\nSTRATEGIC APPROACH:\n- Create a BudgetAllocationCalculator service with calculation methods\n- Implement various budgeting formulas and allocation strategies\n- Support different budgeting methodologies (50/30/20, zero-based, etc.)\n- Include validation for realistic budget amounts and percentages\n- Provide detailed breakdown of allocations\n\nDESIGN PREPARATION:\n- Core calculation methods: allocateBudget, calculateCategoryAmounts, applyBudgetRule\n- Supporting methods: validateBudgetAllocation, formatBudgetBreakdown\n- Budget template support for common methodologies\n- Input validation for income, percentages, and fixed amounts\n</thinking>\n\n<blueprint>\nService BudgetAllocationCalculator {\n  description: \"Calculates budget allocations based on income and spending categories\",\n  \n  methods: {\n    allocateBudget(income: float, allocationRules: AllocationRule[]) -> BudgetAllocationResult {\n      preconditions: [income > 0, allocationRules not empty, percentages sum <= 100],\n      postconditions: [returns budget breakdown by category],\n      errors: [InvalidBudgetAllocation]\n    },\n    \n    applyStandardMethod(income: float, method: BudgetMethod) -> BudgetAllocationResult {\n      preconditions: [income > 0, valid method],\n      postconditions: [returns allocation based on standard method]\n    },\n    \n    calculateCategoryAmount(income: float, percentage: float) -> float {\n      preconditions: [income >= 0, percentage between 0 and 100],\n      postconditions: [returns amount for category based on percentage]\n    },\n    \n    calculateRemainingAfterAllocations(income: float, allocatedAmounts: float[]) -> float {\n      preconditions: [income >= sum of allocated amounts],\n      postconditions: [returns remaining amount after allocations]\n    },\n    \n    suggestAllocationImprovements(currentAllocation: BudgetAllocationResult, financialGoals: FinancialGoal[]) -> AllocationImprovement[] {\n      preconditions: [valid current allocation and goals],\n      postconditions: [returns suggestions for better allocation]\n    }\n  }\n}\n\nType BudgetAllocationResult {\n  totalIncome: float,\n  allocations: CategoryAllocation[],\n  totalAllocated: float,\n  remainingAmount: float,\n  allocationMethod: BudgetMethod?,\n  calculationDate: timestamp\n}\n\nType CategoryAllocation {\n  categoryName: string,\n  percentage: float,\n  amount: float,\n  type: AllocationType\n}\n\nType AllocationRule {\n  categoryName: string,\n  percentage: float?,\n  fixedAmount: float?,\n  type: AllocationType\n}\n\nType AllocationType {\n  enum: [\"percentage\", \"fixed_amount\", \"minimum\", \"maximum\"]\n}\n\nType BudgetMethod {\n  enum: [\"fifty_thirty_twenty\", \"zero_based\", \"envelope_method\", \"pay_yourself_first\"]\n}\n\nType FinancialGoal {\n  name: string,\n  targetAmount: float,\n  timeframeMonths: int,\n  priority: Priority\n}\n\nType Priority {\n  enum: [\"low\", \"medium\", \"high\", \"critical\"]\n}\n\nType AllocationImprovement {\n  category: string,\n  currentPercentage: float,\n  suggestedPercentage: float,\n  suggestedAmount: float,\n  reason: string\n}\n\nValidation BudgetConstraints {\n  minIncome: {value: 100, currency: \"USD\"},\n  maxIncome: {value: 10000000, currency: \"USD\"},\n  minPercentage: {value: 0, percent: true},\n  maxPercentage: {value: 100, percent: true},\n  minAmount: {value: 0, currency: \"USD\"},\n  maxTotalPercentage: {value: 100, percent: true}\n}\n\nOperation AllocateBudget {\n  type: \"calculation\",\n  inputs: [\"income\", \"allocationRules\"],\n  steps: [\n    \"process each allocation rule\",\n    \"calculate amount for percentage-based allocations\",\n    \"apply fixed amounts directly\",\n    \"sum all allocations\",\n    \"calculate remaining amount\"\n  ],\n  postconditions: [returns complete budget allocation breakdown]\n}\n\nScenario budget_allocation_calculation {\n  Preconditions: [valid income and allocation rules],\n  \n  Given monthly income of $5000 and 50/30/20 allocation rule,\n  When allocateBudget is called,\n  Then needs should get $2500 (50%),\n  And wants should get $1500 (30%),\n  And savings should get $1000 (20%).\n  \n  Postconditions: [accurate budget allocation returned]\n}\n</blueprint>", "validation": {"has_thinking": true, "has_blueprint": true, "thinking_structure": ["problem_understanding", "strategic_approach", "design_preparation"], "blueprint_syntax_valid": true, "blueprint_completeness": ["service_definition", "methods_with_contracts", "types", "validation_rules", "operations", "scenarios"]}}
