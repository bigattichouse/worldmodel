{"id": "fin_001", "category": "business_logic", "subcategory": "financial_services", "difficulty": "intermediate", "user_query": "Design a fraud detection system for credit card transactions", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need real-time fraud detection for credit card transactions\n- Must analyze transaction patterns, amounts, locations, timing\n- Should minimize false positives while catching actual fraud\n- Must integrate with existing payment processing systems\n- Requires rapid response (sub-second) for transaction approval\n\nSTRATEGIC APPROACH:\n- Create multi-layered fraud detection with rule-based and ML components\n- Implement real-time scoring system with risk thresholds\n- Design customer behavior profiling and anomaly detection\n- Include transaction blocking and alert mechanisms\n- Support manual review workflow for borderline cases\n\nDESIGN PREPARATION:\n- Transaction analysis engine with multiple detection methods\n- Customer profile database with behavioral patterns\n- Rule engine for known fraud patterns\n- Alert and notification system for suspicious activity\n- Integration points with card networks and merchants\n</thinking>\n\n<blueprint>\nService FraudDetectionSystem {\n  description: \"Real-time credit card fraud detection with risk scoring\",\n  \n  dependencies: {\n    storage: FraudDatabase,\n    profiling: CustomerProfileService,\n    notifications: AlertNotificationService,\n    external: CardNetworkAPI,\n    ml: AnomalyDetectionEngine\n  },\n  \n  methods: {\n    analyzeTransaction(transaction: Transaction) -> FraudAssessment {\n      preconditions: [transaction valid, customer exists],\n      postconditions: [returns risk score and recommendation, analysis logged],\n      errors: [InvalidTransaction, CustomerNotFound, SystemUnavailable]\n    },\n    \n    updateCustomerProfile(customerId: CustomerId, transaction: Transaction) -> void {\n      preconditions: [customer exists, transaction approved],\n      postconditions: [profile updated with new behavioral data],\n      errors: [CustomerNotFound]\n    },\n    \n    blockCard(cardNumber: string, reason: string, severity: BlockSeverity) -> BlockResult {\n      preconditions: [card exists, reason provided],\n      postconditions: [card blocked, customer notified, incident logged],\n      errors: [CardNotFound, AlreadyBlocked]\n    },\n    \n    investigateFraudAlert(alertId: AlertId, investigatorId: UserId) -> Investigation {\n      preconditions: [alert exists, investigator authorized],\n      postconditions: [investigation initiated, alert assigned],\n      errors: [AlertNotFound, UnauthorizedInvestigator]\n    },\n    \n    reviewManualCase(caseId: CaseId, decision: ReviewDecision, notes: string) -> void {\n      preconditions: [case exists, decision valid],\n      postconditions: [case resolved, customer notified, models updated],\n      errors: [CaseNotFound, InvalidDecision]\n    }\n  }\n}\n\nService CustomerProfileService {\n  description: \"Maintains customer behavioral profiles for fraud detection\",\n  \n  methods: {\n    buildProfile(customerId: CustomerId, transactionHistory: Transaction[]) -> CustomerProfile {\n      preconditions: [customer exists, sufficient transaction history],\n      postconditions: [profile created with spending patterns and preferences]\n    },\n    \n    calculateAnomalyScore(profile: CustomerProfile, transaction: Transaction) -> AnomalyScore {\n      preconditions: [profile exists, transaction valid],\n      postconditions: [returns score indicating deviation from normal behavior]\n    }\n  }\n}\n\nDatabase FraudDatabase {\n  Table Transactions {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      cardNumber: {type: String, sensitive: true, required: true},\n      customerId: {type: UUID, foreignKey: \"Customers.id\"},\n      amount: {type: Decimal, precision: 10, scale: 2},\n      currency: {type: String, length: 3},\n      merchantId: {type: String},\n      merchantCategory: {type: String},\n      location: {type: String},\n      timestamp: {type: Timestamp, required: true},\n      fraudScore: {type: Decimal, precision: 5, scale: 3},\n      isApproved: {type: Bool},\n      isFraudulent: {type: Bool}\n    },\n    indexes: [\n      {name: \"idx_card_timestamp\", columns: [\"cardNumber\", \"timestamp\"]},\n      {name: \"idx_customer_timestamp\", columns: [\"customerId\", \"timestamp\"]},\n      {name: \"idx_fraud_score\", columns: [\"fraudScore\"]}\n    ]\n  },\n  \n  Table CustomerProfiles {\n    columns: {\n      customerId: {type: UUID, primaryKey: true},\n      averageTransactionAmount: {type: Decimal, precision: 10, scale: 2},\n      typicalMerchantCategories: {type: String[]},\n      usualLocations: {type: String[]},\n      timePatterns: {type: String[]},\n      riskLevel: {type: String, enum: [\"low\", \"medium\", \"high\"]},\n      lastUpdated: {type: Timestamp},\n      profileVersion: {type: Int, default: 1}\n    }\n  },\n  \n  Table FraudAlerts {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      transactionId: {type: UUID, foreignKey: \"Transactions.id\"},\n      alertType: {type: String, required: true},\n      severity: {type: String, enum: [\"low\", \"medium\", \"high\", \"critical\"]},\n      fraudScore: {type: Decimal, precision: 5, scale: 3},\n      triggeredRules: {type: String[]},\n      status: {type: String, enum: [\"open\", \"investigating\", \"resolved\", \"false_positive\"]},\n      assignedInvestigator: {type: UUID, foreignKey: \"Users.id\"},\n      createdAt: {type: Timestamp, default: \"now()\"},\n      resolvedAt: {type: Timestamp}\n    }\n  }\n}\n\nType FraudAssessment {\n  transactionId: TransactionId,\n  riskScore: decimal,\n  riskLevel: string,\n  recommendation: string,\n  triggeredRules: string[],\n  anomalyFactors: string[],\n  processingTimeMs: int\n}\n\nType CustomerProfile {\n  customerId: CustomerId,\n  spendingPatterns: SpendingPattern,\n  locationPatterns: LocationPattern,\n  timePatterns: TimePattern,\n  riskFactors: string[]\n}\n\nType AnomalyScore {\n  overallScore: decimal,\n  amountAnomaly: decimal,\n  locationAnomaly: decimal,\n  timeAnomaly: decimal,\n  merchantAnomaly: decimal\n}\n\nValidation FraudDetectionRules {\n  highRiskThreshold: {score: 0.8, action: \"block_transaction\"},\n  mediumRiskThreshold: {score: 0.5, action: \"manual_review\"},\n  lowRiskThreshold: {score: 0.2, action: \"approve_with_monitoring\"},\n  maximumTransactionAmount: {value: 10000, currency: \"USD\"},\n  rapidFireThreshold: {transactions: 5, timeWindow: \"5 minutes\"},\n  locationChangeThreshold: {distance: 100, timeWindow: \"1 hour\"}\n}\n\nScenario suspicious_transaction_detection {\n  Preconditions: [customer has established profile, transaction outside normal patterns],\n  \n  Given a transaction that deviates significantly from customer profile,\n  When fraud detection analysis is performed,\n  Then high risk score is calculated,\n  And transaction is flagged for manual review,\n  And alert is created for investigation,\n  And customer is notified of security check.\n  \n  Postconditions: [transaction temporarily held, investigation initiated, audit trail created]\n}\n</blueprint>"}
{"id": "fin_002", "category": "business_logic", "subcategory": "financial_services", "difficulty": "intermediate", "user_query": "Create an investment portfolio management system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to manage investment portfolios for clients\n- Should track holdings, performance, asset allocation, rebalancing\n- Must support multiple account types (retirement, taxable, etc.)\n- Should provide performance reporting and risk analysis\n- Requires integration with market data and trading systems\n\nSTRATEGIC APPROACH:\n- Design portfolio management service with comprehensive tracking\n- Include real-time valuation and performance calculation\n- Support automated rebalancing based on target allocations\n- Provide risk analysis and reporting capabilities\n- Include client notification and advisory features\n\nDESIGN PREPARATION:\n- Portfolio and holding entities with real-time pricing\n- Performance calculation engine with time-weighted returns\n- Rebalancing logic with tax-loss harvesting\n- Risk metrics calculation and monitoring\n- Integration with market data providers\n</thinking>\n\n<blueprint>\nService PortfolioManager {\n  description: \"Comprehensive investment portfolio management with automated rebalancing\",\n  \n  dependencies: {\n    storage: PortfolioDatabase,\n    marketData: MarketDataService,\n    trading: TradingExecutionService,\n    risk: RiskAnalysisEngine,\n    reporting: PerformanceReportingService\n  },\n  \n  methods: {\n    createPortfolio(clientId: ClientId, portfolioConfig: PortfolioConfiguration) -> PortfolioId {\n      preconditions: [client exists, valid configuration, sufficient initial funding],\n      postconditions: [portfolio created, initial allocation set, tracking enabled],\n      errors: [ClientNotFound, InsufficientFunds, InvalidConfiguration]\n    },\n    \n    updateHolding(portfolioId: PortfolioId, symbol: string, quantity: decimal, price: decimal) -> void {\n      preconditions: [portfolio exists, valid symbol, realistic price],\n      postconditions: [holding updated, portfolio value recalculated, rebalancing triggered if needed],\n      errors: [PortfolioNotFound, InvalidSymbol, InvalidPrice]\n    },\n    \n    calculatePortfolioValue(portfolioId: PortfolioId) -> PortfolioValuation {\n      preconditions: [portfolio exists, market data available],\n      postconditions: [returns current market value with breakdown by asset],\n      errors: [PortfolioNotFound, MarketDataUnavailable]\n    },\n    \n    rebalancePortfolio(portfolioId: PortfolioId, targetAllocation: AssetAllocation) -> RebalanceResult {\n      preconditions: [portfolio exists, valid target allocation, sufficient cash/margin],\n      postconditions: [trades executed, portfolio aligned with targets, costs minimized],\n      errors: [PortfolioNotFound, InsufficientLiquidity, MarketClosed]\n    },\n    \n    generatePerformanceReport(portfolioId: PortfolioId, period: ReportingPeriod) -> PerformanceReport {\n      preconditions: [portfolio exists, sufficient history for period],\n      postconditions: [returns comprehensive performance analysis],\n      errors: [PortfolioNotFound, InsufficientHistory]\n    }\n  }\n}\n\nDatabase PortfolioDatabase {\n  Table Portfolios {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      clientId: {type: UUID, foreignKey: \"Clients.id\"},\n      name: {type: String, required: true},\n      accountType: {type: String, enum: [\"taxable\", \"traditional_ira\", \"roth_ira\", \"401k\"]},\n      totalValue: {type: Decimal, precision: 15, scale: 2},\n      cashBalance: {type: Decimal, precision: 15, scale: 2},\n      targetAllocation: {type: JSON},\n      riskTolerance: {type: String, enum: [\"conservative\", \"moderate\", \"aggressive\"]},\n      autoRebalance: {type: Bool, default: true},\n      lastRebalanced: {type: Timestamp},\n      createdAt: {type: Timestamp, default: \"now()\"}\n    }\n  },\n  \n  Table Holdings {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      portfolioId: {type: UUID, foreignKey: \"Portfolios.id\"},\n      symbol: {type: String, required: true},\n      assetType: {type: String, enum: [\"stock\", \"bond\", \"etf\", \"mutual_fund\", \"crypto\"]},\n      quantity: {type: Decimal, precision: 15, scale: 6},\n      averageCostBasis: {type: Decimal, precision: 10, scale: 4},\n      currentPrice: {type: Decimal, precision: 10, scale: 4},\n      marketValue: {type: Decimal, precision: 15, scale: 2},\n      unrealizedGainLoss: {type: Decimal, precision: 15, scale: 2},\n      lastUpdated: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_portfolio_symbol\", columns: [\"portfolioId\", \"symbol\"]}\n    ]\n  },\n  \n  Table PerformanceHistory {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      portfolioId: {type: UUID, foreignKey: \"Portfolios.id\"},\n      date: {type: Date, required: true},\n      totalValue: {type: Decimal, precision: 15, scale: 2},\n      dailyReturn: {type: Decimal, precision: 8, scale: 6},\n      cumulativeReturn: {type: Decimal, precision: 8, scale: 6},\n      benchmarkReturn: {type: Decimal, precision: 8, scale: 6},\n      cashFlows: {type: Decimal, precision: 15, scale: 2}\n    },\n    indexes: [\n      {name: \"idx_portfolio_date\", columns: [\"portfolioId\", \"date\"]}\n    ]\n  }\n}\n\nType PortfolioValuation {\n  portfolioId: PortfolioId,\n  totalValue: decimal,\n  cashBalance: decimal,\n  holdings: HoldingValuation[],\n  assetAllocation: AllocationBreakdown,\n  lastUpdated: timestamp\n}\n\nType HoldingValuation {\n  symbol: string,\n  quantity: decimal,\n  currentPrice: decimal,\n  marketValue: decimal,\n  weightInPortfolio: decimal,\n  unrealizedGainLoss: decimal,\n  unrealizedGainLossPercent: decimal\n}\n\nType RebalanceResult {\n  portfolioId: PortfolioId,\n  tradesExecuted: Trade[],\n  totalCosts: decimal,\n  newAllocation: AllocationBreakdown,\n  deviationFromTarget: decimal,\n  executionTime: timestamp\n}\n\nType PerformanceReport {\n  portfolioId: PortfolioId,\n  period: ReportingPeriod,\n  totalReturn: decimal,\n  annualizedReturn: decimal,\n  volatility: decimal,\n  sharpeRatio: decimal,\n  maxDrawdown: decimal,\n  benchmarkComparison: BenchmarkComparison,\n  riskMetrics: RiskMetrics\n}\n\nValidation PortfolioLimits {\n  minimumInvestment: {value: 1000, currency: \"USD\"},\n  maximumSingleHolding: {percentage: 25},\n  rebalancingThreshold: {percentage: 5},\n  maximumCashPosition: {percentage: 10},\n  minimumDiversification: {holdings: 5}\n}\n</blueprint>"}