{"id": "blueprint_tech_sec_001", "category": "security_cryptography", "difficulty": "intermediate", "user_query": "Hashing Service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to create a cryptographic hash of a given string.\n- It should support multiple common hashing algorithms (e.g., SHA-256 for integrity checks, bcrypt for passwords).\n- For password hashing, it should handle salt generation automatically.\n\nSTRATEGIC APPROACH:\n- Design a `HashingService`.\n- Implement separate methods for different use cases: `generateIntegrityHash` (e.g., SHA-256) and `hashPassword` (e.g., bcrypt).\n- Also provide a `verifyPassword` method to compare a raw password against a bcrypt hash.\n- The implementation should wrap a standard, well-vetted cryptography library.\n\nDESIGN PREPARATION:\n- A `HashingService` with methods: `generateIntegrityHash`, `hashPassword`, `verifyPassword`.\n- `generateIntegrityHash` takes a string and an algorithm name, returns a hex-encoded hash string.\n- `hashPassword` takes a password string, generates a salt, and returns the full hash string (which includes the salt).\n- `verifyPassword` takes a plain-text password and a hash string and returns a boolean.\n- Error handling for `UnsupportedAlgorithm`.\n</thinking>\n\n<blueprint>\nService HashingService {\n  description: \"Generates cryptographic hashes for data integrity and password storage.\",\n  methods: {\n    generateIntegrityHash(data: string, algorithm: string) -> string {\n      preconditions: [algorithm is supported (e.g., 'SHA-256', 'SHA-512')],\n      postconditions: [returns a hex-encoded hash of the input data],\n      errors: [UnsupportedAlgorithm]\n    },\n    hashPassword(password: string) -> string {\n      preconditions: [password is not empty],\n      postconditions: [returns a secure password hash (e.g., bcrypt) including the generated salt],\n      errors: [HashingFailed]\n    },\n    verifyPassword(password: string, hash: string) -> bool {\n      preconditions: [password and hash are not empty],\n      postconditions: [returns true if the password matches the hash, false otherwise],\n      errors: [HashingFailed]\n    }\n  }\n}\n</blueprint>"}
{"id": "blueprint_tech_sec_002", "category": "security_cryptography", "difficulty": "intermediate", "user_query": "HMAC Generation Service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to generate a Hash-based Message Authentication Code (HMAC).\n- An HMAC is used to verify both the data integrity and the authenticity of a message.\n- It requires a message, a secret key, and a hash algorithm.\n\nSTRATEGIC APPROACH:\n- Design a `HmacService`.\n- Implement a `generate` method that takes the message, a secret key, and the desired algorithm.\n- The service will use a standard cryptography library to perform the HMAC generation.\n\nDESIGN PREPARATION:\n- A `HmacService` with a `generate` method.\n- Inputs: `message: string`, `secretKey: string`, `algorithm: string` (e.g., 'SHA256', 'SHA512').\n- The method returns a hex-encoded HMAC string.\n- A `verify` method could also be included to compare a message and HMAC against a key.\n- Error handling for `UnsupportedAlgorithm`.\n</thinking>\n\n<blueprint>\nService HmacService {\n  description: \"Generates and verifies Hash-based Message Authentication Codes (HMACs).\",\n  methods: {\n    generate(message: string, secretKey: string, algorithm: string) -> string {\n      preconditions: [secretKey is not empty, algorithm is supported (e.g., 'SHA256')],\n      postconditions: [returns a hex-encoded HMAC string],\n      errors: [UnsupportedAlgorithm, GenerationFailed]\n    },\n    verify(message: string, hmacToVerify: string, secretKey: string, algorithm: string) -> bool {\n      preconditions: [secretKey is not empty, algorithm is supported],\n      postconditions: [returns true if the generated HMAC for the message matches the provided HMAC, false otherwise],\n      errors: [UnsupportedAlgorithm]\n    }\n  }\n}\n</blueprint>"}
{"id": "blueprint_tech_sec_003", "category": "security_cryptography", "difficulty": "intermediate", "user_query": "JWT (JSON Web Token) Validator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to decode and validate a JSON Web Token (JWT).\n- Validation involves checking the cryptographic signature, the expiration date (exp claim), and potentially other claims like issuer (iss) and audience (aud).\n\nSTRATEGIC APPROACH:\n- Design a `JwtService`.\n- It should have a method to `issue` tokens and a method to `validate` them.\n- The service needs to be configured with the secret key or public/private key pair for signing.\n\nDESIGN PREPARATION:\n- A `JwtService` configured with a secret key and default expiration time.\n- `issue(claims: map<string, any>, expiresInSeconds: int | null) -> string` method to generate and sign a JWT.\n- `validate(token: string) -> JwtValidationResult` method.\n- A `JwtValidationResult` type containing a boolean `isValid`, any `error` message (e.g., 'TokenExpired', 'InvalidSignature'), and the decoded `claims` if valid.\n- Error handling is managed within the result object.\n</thinking>\n\n<blueprint>\nService JwtService {\n  description: \"Issues and validates JSON Web Tokens (JWTs).\",\n  configuration: {\n    secretKey: string,\n    defaultExpiresInSeconds: int\n  },\n  methods: {\n    issue(claims: map<string, any>, expiresInSeconds: int | null) -> string {\n      preconditions: [claims map is not empty],\n      postconditions: [returns a newly generated and signed JWT string],\n      errors: [SigningError]\n    },\n    validate(token: string) -> JwtValidationResult {\n      preconditions: [token is not empty],\n      postconditions: [returns a result object indicating if the token is valid and containing its decoded claims],\n      errors: []\n    }\n  }\n}\n\nType JwtValidationResult {\n  isValid: bool,\n  claims: map<string, any> | null,\n  error: string | null // e.g., \"TokenExpired\", \"InvalidSignature\", \"InvalidIssuer\"\n}\n</blueprint>"}
{"id": "blueprint_tech_sec_004", "category": "security_cryptography", "difficulty": "intermediate", "user_query": "TOTP (Time-based One-Time Password) Generator/Validator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to generate and validate Time-based One-Time Passwords (TOTPs), commonly used for 2-Factor Authentication.\n- It requires a shared secret key between the server and the user's device.\n\nSTRATEGIC APPROACH:\n- Design a `TotpService`.\n- It needs a method to `generateNewSecret` for a user.\n- A `generateCode` method (primarily for testing/debugging) that takes the secret.\n- A `validateCode` method that takes the user's secret and the code they provided.\n\nDESIGN PREPARATION:\n- A `TotpService` with `generateNewSecret`, `validateCode` methods.\n- `generateNewSecret` returns a base32 encoded secret key.\n- `validateCode` takes `secret: string` and `code: string` and returns a boolean.\n- The validation must account for a small time window to allow for clock drift between client and server.\n- Configuration for code length (e.g., 6 digits) and time step (e.g., 30 seconds).\n</thinking>\n\n<blueprint>\nService TotpService {\n  description: \"Generates and validates Time-based One-Time Passwords (TOTPs) for 2FA.\",\n  configuration: {\n    timeStepSeconds: 30,\n    codeLength: 6,\n    acceptedTimeWindow: 1 // Number of steps (past and future) to accept\n  },\n  methods: {\n    generateNewSecret() -> string {\n      preconditions: [],\n      postconditions: [returns a new, unique, base32-encoded secret key for a user],\n      errors: []\n    },\n    validateCode(secret: string, code: string) -> bool {\n      preconditions: [secret and code are not empty],\n      postconditions: [returns true if the provided code is valid for the secret within the current time window],\n      errors: [InvalidSecret, InvalidCodeFormat]\n    }\n  }\n}\n</blueprint>"}
{"id": "blueprint_tech_sec_005", "category": "security_cryptography", "difficulty": "intermediate", "user_query": "Data Encryption/Decryption Service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to provide symmetric encryption and decryption for sensitive data at rest or in transit.\n- It needs to handle key management abstractly and perform authenticated encryption (e.g., AES-GCM) to ensure both confidentiality and integrity.\n\nSTRATEGIC APPROACH:\n- Design a `DataEncryptionService`.\n- The service must be configured with a master encryption key (which should be managed securely, e.g., via a KMS).\n- It will have `encrypt` and `decrypt` methods.\n- The `encrypt` method will generate a new initialization vector (IV) for each operation, perform encryption, and return the ciphertext and IV together.\n\nDESIGN PREPARATION:\n- A `DataEncryptionService` configured with a master key.\n- `encrypt(plaintext: string) -> string` method that returns a combined string (e.g., base64-encoded `iv:ciphertext:tag`).\n- `decrypt(ciphertext: string) -> string` method that parses the combined string, uses the IV, and performs decryption and authentication.\n- Error handling for `DecryptionFailed` (which could mean tampering or wrong key).\n</thinking>\n\n<blueprint>\nService DataEncryptionService {\n  description: \"Provides symmetric encryption and decryption for sensitive data.\",\n  configuration: {\n    masterEncryptionKey: string // This should be loaded from a secure source\n  },\n  methods: {\n    encrypt(plaintext: string) -> string {\n      preconditions: [plaintext is not empty],\n      postconditions: [returns a base64-encoded string containing the IV, ciphertext, and auth tag],\n      errors: [EncryptionFailed]\n    },\n    decrypt(encryptedData: string) -> string {\n      preconditions: [encryptedData is not empty and in the expected format],\n      postconditions: [returns the original plaintext string if decryption and authentication are successful],\n      errors: [DecryptionFailed, InvalidFormat]\n    }\n  }\n}\n</blueprint>"}
