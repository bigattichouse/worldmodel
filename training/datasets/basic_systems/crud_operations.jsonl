{"id": "crud_001", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Design a book library catalog system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to manage library book catalog\n- Should handle adding, updating, finding, and removing books\n- Must track basic book information like title, author, ISBN\n- Should support search and filtering capabilities\n\nSTRATEGIC APPROACH:\n- Create a book catalog service with standard CRUD operations\n- Design database schema for book entities\n- Include search and filtering functionality\n- Add validation for book data integrity\n\nDESIGN PREPARATION:\n- Book entity with essential metadata\n- CRUD service methods with proper validation\n- Search capabilities by various fields\n- Database indexes for performance\n</thinking>\n\n<blueprint>\nService LibraryCatalog {\n  description: \"Manages library book catalog with CRUD operations\",\n  \n  dependencies: {\n    storage: LibraryDatabase,\n    validator: BookDataValidator\n  },\n  \n  methods: {\n    addBook(book: BookInfo) -> BookId {\n      preconditions: [ISBN is valid, title not empty, author not empty],\n      postconditions: [book stored with unique ID, searchable by all fields],\n      errors: [InvalidISBN, DuplicateBook, ValidationError]\n    },\n    \n    updateBook(bookId: BookId, updates: BookUpdates) -> void {\n      preconditions: [book exists, updates are valid],\n      postconditions: [book updated, search indexes refreshed],\n      errors: [BookNotFound, InvalidUpdate]\n    },\n    \n    findBook(bookId: BookId) -> BookInfo {\n      preconditions: [valid book ID provided],\n      postconditions: [returns book info or null if not found]\n    },\n    \n    searchBooks(criteria: SearchCriteria) -> BookInfo[] {\n      preconditions: [search criteria valid],\n      postconditions: [returns matching books sorted by relevance],\n      errors: [InvalidSearchCriteria]\n    },\n    \n    removeBook(bookId: BookId) -> void {\n      preconditions: [book exists, not currently checked out],\n      postconditions: [book removed, search indexes updated],\n      errors: [BookNotFound, BookInUse]\n    }\n  }\n}\n\nDatabase LibraryDatabase {\n  Table Books {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      isbn: {type: String, unique: true, required: true},\n      title: {type: String, required: true, maxLength: 500},\n      author: {type: String, required: true, maxLength: 200},\n      publisher: {type: String, maxLength: 200},\n      publishedYear: {type: Int, min: 1000, max: 2100},\n      genre: {type: String, maxLength: 100},\n      pages: {type: Int, min: 1},\n      available: {type: Bool, default: true},\n      createdAt: {type: Timestamp, default: \"now()\"},\n      updatedAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_isbn\", columns: [\"isbn\"]},\n      {name: \"idx_title\", columns: [\"title\"]},\n      {name: \"idx_author\", columns: [\"author\"]},\n      {name: \"idx_genre\", columns: [\"genre\"]}\n    ]\n  }\n}\n\nType BookInfo {\n  id: BookId,\n  isbn: string,\n  title: string,\n  author: string,\n  publisher: string,\n  publishedYear: int,\n  genre: string,\n  pages: int,\n  available: bool\n}\n\nType SearchCriteria {\n  title: string?,\n  author: string?,\n  isbn: string?,\n  genre: string?,\n  publishedYear: int?,\n  availableOnly: bool?\n}\n</blueprint>"}
{"id": "crud_002", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Create a contact management system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to store and manage personal/business contacts\n- Should handle contact information like name, phone, email, address\n- Must support adding, editing, searching, and organizing contacts\n- Should allow grouping contacts by categories or tags\n\nSTRATEGIC APPROACH:\n- Design contact management service with full CRUD operations\n- Include flexible contact information storage\n- Support contact categorization and tagging\n- Add search and filtering by multiple criteria\n- Include data validation and deduplication\n\nDESIGN PREPARATION:\n- Contact entity with comprehensive personal information\n- Category/tag system for organization\n- Search functionality across all contact fields\n- Validation for email, phone number formats\n</thinking>\n\n<blueprint>\nService ContactManager {\n  description: \"Manages personal and business contacts with organization features\",\n  \n  dependencies: {\n    storage: ContactDatabase,\n    validator: ContactValidator,\n    deduplicator: ContactDeduplicator\n  },\n  \n  methods: {\n    createContact(contactData: ContactInfo) -> ContactId {\n      preconditions: [at least name or email provided, valid email format if provided],\n      postconditions: [contact created, searchable, checked for duplicates],\n      errors: [ValidationError, PossibleDuplicate]\n    },\n    \n    updateContact(contactId: ContactId, updates: ContactUpdates) -> void {\n      preconditions: [contact exists, updates are valid],\n      postconditions: [contact updated, duplicate check performed],\n      errors: [ContactNotFound, ValidationError]\n    },\n    \n    getContact(contactId: ContactId) -> ContactInfo {\n      preconditions: [valid contact ID],\n      postconditions: [returns complete contact information]\n    },\n    \n    searchContacts(query: SearchQuery) -> ContactInfo[] {\n      preconditions: [query not empty],\n      postconditions: [returns matching contacts ranked by relevance]\n    },\n    \n    deleteContact(contactId: ContactId) -> void {\n      preconditions: [contact exists],\n      postconditions: [contact removed, associated tags cleaned up],\n      errors: [ContactNotFound]\n    },\n    \n    addContactToGroup(contactId: ContactId, groupName: string) -> void {\n      preconditions: [contact exists, group name valid],\n      postconditions: [contact associated with group]\n    }\n  }\n}\n\nDatabase ContactDatabase {\n  Table Contacts {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      firstName: {type: String, maxLength: 100},\n      lastName: {type: String, maxLength: 100},\n      company: {type: String, maxLength: 200},\n      title: {type: String, maxLength: 150},\n      email: {type: String, maxLength: 255},\n      phone: {type: String, maxLength: 20},\n      address: {type: String, maxLength: 500},\n      notes: {type: Text},\n      createdAt: {type: Timestamp, default: \"now()\"},\n      updatedAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_name\", columns: [\"firstName\", \"lastName\"]},\n      {name: \"idx_email\", columns: [\"email\"]},\n      {name: \"idx_company\", columns: [\"company\"]}\n    ]\n  },\n  \n  Table ContactGroups {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      contactId: {type: UUID, foreignKey: \"Contacts.id\"},\n      groupName: {type: String, required: true, maxLength: 100}\n    }\n  }\n}\n\nType ContactInfo {\n  id: ContactId,\n  firstName: string,\n  lastName: string,\n  company: string,\n  title: string,\n  email: string,\n  phone: string,\n  address: string,\n  notes: string,\n  groups: string[]\n}\n</blueprint>"}
{"id": "crud_003", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Build a product inventory tracker", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to track products and their inventory levels\n- Should handle product creation, updates, stock management\n- Must track stock quantities, reorder points, suppliers\n- Should support low stock alerts and inventory reports\n\nSTRATEGIC APPROACH:\n- Create inventory management service with product CRUD\n- Include stock level tracking and movement history\n- Add automated low stock detection and alerting\n- Support supplier information and reorder management\n- Include audit trail for all inventory changes\n\nDESIGN PREPARATION:\n- Product entities with SKU, description, pricing\n- Stock tracking with current levels and movements\n- Alert system for low stock conditions\n- Supplier relationship management\n</thinking>\n\n<blueprint>\nService InventoryTracker {\n  description: \"Tracks product inventory with automated stock management\",\n  \n  dependencies: {\n    storage: InventoryDatabase,\n    alerts: StockAlertService,\n    audit: InventoryAuditLogger\n  },\n  \n  methods: {\n    addProduct(product: ProductInfo) -> ProductId {\n      preconditions: [SKU unique, name not empty, valid pricing],\n      postconditions: [product created, stock initialized, searchable],\n      errors: [DuplicateSKU, ValidationError]\n    },\n    \n    updateProduct(productId: ProductId, updates: ProductUpdates) -> void {\n      preconditions: [product exists, updates valid],\n      postconditions: [product updated, audit logged],\n      errors: [ProductNotFound, ValidationError]\n    },\n    \n    adjustStock(productId: ProductId, quantity: int, reason: string) -> void {\n      preconditions: [product exists, quantity change justified],\n      postconditions: [stock updated, movement logged, alerts checked],\n      errors: [ProductNotFound, InsufficientStock]\n    },\n    \n    getProduct(productId: ProductId) -> ProductInfo {\n      preconditions: [valid product ID],\n      postconditions: [returns product with current stock levels]\n    },\n    \n    getLowStockProducts() -> ProductInfo[] {\n      preconditions: [none],\n      postconditions: [returns products below reorder point]\n    },\n    \n    recordStockMovement(productId: ProductId, movement: StockMovement) -> void {\n      preconditions: [product exists, movement valid],\n      postconditions: [movement recorded, stock updated, audit trail created]\n    }\n  }\n}\n\nDatabase InventoryDatabase {\n  Table Products {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      sku: {type: String, unique: true, required: true},\n      name: {type: String, required: true, maxLength: 200},\n      description: {type: Text},\n      category: {type: String, maxLength: 100},\n      unitPrice: {type: Decimal, precision: 10, scale: 2},\n      costPrice: {type: Decimal, precision: 10, scale: 2},\n      currentStock: {type: Int, default: 0, min: 0},\n      reorderPoint: {type: Int, default: 10},\n      maxStock: {type: Int},\n      supplierId: {type: UUID, foreignKey: \"Suppliers.id\"},\n      isActive: {type: Bool, default: true},\n      createdAt: {type: Timestamp, default: \"now()\"},\n      updatedAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_sku\", columns: [\"sku\"]},\n      {name: \"idx_category\", columns: [\"category\"]},\n      {name: \"idx_low_stock\", columns: [\"currentStock\", \"reorderPoint\"]}\n    ]\n  },\n  \n  Table StockMovements {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      productId: {type: UUID, foreignKey: \"Products.id\"},\n      movementType: {type: String, enum: [\"IN\", \"OUT\", \"ADJUSTMENT\"]},\n      quantity: {type: Int, required: true},\n      reason: {type: String, required: true},\n      previousStock: {type: Int, required: true},\n      newStock: {type: Int, required: true},\n      createdAt: {type: Timestamp, default: \"now()\"}\n    }\n  }\n}\n\nType ProductInfo {\n  id: ProductId,\n  sku: string,\n  name: string,\n  description: string,\n  category: string,\n  unitPrice: decimal,\n  currentStock: int,\n  reorderPoint: int,\n  isLowStock: bool\n}\n\nType StockMovement {\n  movementType: string,\n  quantity: int,\n  reason: string\n}\n</blueprint>"}
{"id": "crud_004", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Design a student record system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to manage student records for educational institution\n- Should handle student enrollment, academic history, grades\n- Must track personal information, course registrations, transcripts\n- Should support searching and reporting capabilities\n\nSTRATEGIC APPROACH:\n- Create student information service with comprehensive record management\n- Include enrollment and course registration functionality\n- Support grade tracking and transcript generation\n- Add search capabilities by various criteria\n- Include academic standing and progress tracking\n\nDESIGN PREPARATION:\n- Student entity with personal and academic information\n- Course registration and grade recording\n- Academic history tracking and calculations\n- Search and reporting functionality\n</thinking>\n\n<blueprint>\nService StudentRecordSystem {\n  description: \"Manages comprehensive student records and academic history\",\n  \n  dependencies: {\n    storage: StudentDatabase,\n    validator: StudentDataValidator,\n    calculator: GPACalculator\n  },\n  \n  methods: {\n    enrollStudent(student: StudentInfo) -> StudentId {\n      preconditions: [valid student data, unique student ID],\n      postconditions: [student enrolled, record created, searchable],\n      errors: [DuplicateStudent, ValidationError]\n    },\n    \n    updateStudent(studentId: StudentId, updates: StudentUpdates) -> void {\n      preconditions: [student exists, updates valid],\n      postconditions: [student information updated, history logged],\n      errors: [StudentNotFound, ValidationError]\n    },\n    \n    getStudent(studentId: StudentId) -> StudentInfo {\n      preconditions: [valid student ID],\n      postconditions: [returns complete student information]\n    },\n    \n    searchStudents(criteria: SearchCriteria) -> StudentInfo[] {\n      preconditions: [search criteria valid],\n      postconditions: [returns matching students],\n      errors: [InvalidSearchCriteria]\n    },\n    \n    recordGrade(studentId: StudentId, courseId: CourseId, grade: Grade) -> void {\n      preconditions: [student enrolled in course, valid grade],\n      postconditions: [grade recorded, GPA recalculated, transcript updated],\n      errors: [StudentNotFound, CourseNotFound, InvalidGrade]\n    },\n    \n    generateTranscript(studentId: StudentId) -> Transcript {\n      preconditions: [student exists, has academic history],\n      postconditions: [returns official transcript with all courses and grades]\n    }\n  }\n}\n\nDatabase StudentDatabase {\n  Table Students {\n    columns: {\n      id: {type: String, primaryKey: true},\n      firstName: {type: String, required: true, maxLength: 100},\n      lastName: {type: String, required: true, maxLength: 100},\n      email: {type: String, unique: true, required: true},\n      dateOfBirth: {type: Date, required: true},\n      enrollmentDate: {type: Date, required: true},\n      major: {type: String, maxLength: 100},\n      minor: {type: String, maxLength: 100},\n      academicStanding: {type: String, enum: [\"good\", \"probation\", \"suspended\"]},\n      cumulativeGPA: {type: Decimal, precision: 3, scale: 2},\n      totalCredits: {type: Int, default: 0},\n      expectedGraduation: {type: Date},\n      isActive: {type: Bool, default: true},\n      createdAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_name\", columns: [\"lastName\", \"firstName\"]},\n      {name: \"idx_email\", columns: [\"email\"]},\n      {name: \"idx_major\", columns: [\"major\"]}\n    ]\n  },\n  \n  Table CourseEnrollments {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      studentId: {type: String, foreignKey: \"Students.id\"},\n      courseId: {type: String, required: true},\n      courseName: {type: String, required: true},\n      semester: {type: String, required: true},\n      year: {type: Int, required: true},\n      credits: {type: Int, required: true},\n      grade: {type: String, maxLength: 2},\n      gradePoints: {type: Decimal, precision: 3, scale: 2},\n      enrollmentDate: {type: Date, required: true},\n      completionDate: {type: Date}\n    },\n    indexes: [\n      {name: \"idx_student_course\", columns: [\"studentId\", \"courseId\"]},\n      {name: \"idx_semester\", columns: [\"semester\", \"year\"]}\n    ]\n  }\n}\n\nType StudentInfo {\n  id: StudentId,\n  firstName: string,\n  lastName: string,\n  email: string,\n  dateOfBirth: date,\n  major: string,\n  minor: string,\n  cumulativeGPA: decimal,\n  totalCredits: int,\n  academicStanding: string\n}\n\nType Transcript {\n  studentInfo: StudentInfo,\n  courses: CourseRecord[],\n  semesterSummaries: SemesterSummary[],\n  overallSummary: AcademicSummary,\n  generatedDate: timestamp\n}\n\nValidation StudentRecordRules {\n  minimumGPA: {value: 2.0, standing: \"good\"},\n  probationGPA: {value: 1.5, standing: \"probation\"},\n  suspensionGPA: {value: 1.0, standing: \"suspended\"},\n  maximumCreditsPerSemester: {value: 21},\n  graduationRequiredCredits: {value: 120}\n}\n</blueprint>"}
{"id": "crud_005", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Create a simple blog post manager", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to manage blog posts and articles\n- Should handle post creation, editing, publishing, and organization\n- Must support categories, tags, and content management\n- Should include draft/published status and author management\n\nSTRATEGIC APPROACH:\n- Create blog management service with full content lifecycle\n- Include post categorization and tagging system\n- Support draft and publishing workflow\n- Add search and filtering capabilities\n- Include basic SEO and metadata management\n\nDESIGN PREPARATION:\n- Post entities with content, metadata, and publishing status\n- Category and tag organization system\n- Author management and attribution\n- Publishing workflow with status tracking\n</thinking>\n\n<blueprint>\nService BlogManager {\n  description: \"Manages blog posts with publishing workflow and organization\",\n  \n  dependencies: {\n    storage: BlogDatabase,\n    renderer: ContentRenderer,\n    seo: SEOMetadataGenerator\n  },\n  \n  methods: {\n    createPost(post: PostInfo, authorId: AuthorId) -> PostId {\n      preconditions: [title not empty, author exists, valid content],\n      postconditions: [post created as draft, SEO metadata generated, searchable],\n      errors: [AuthorNotFound, ValidationError]\n    },\n    \n    updatePost(postId: PostId, updates: PostUpdates) -> void {\n      preconditions: [post exists, author has permission],\n      postconditions: [post updated, modification time updated],\n      errors: [PostNotFound, UnauthorizedEdit]\n    },\n    \n    publishPost(postId: PostId, publishDate: timestamp) -> void {\n      preconditions: [post exists, post is complete, author authorized],\n      postconditions: [post published, publicly visible, SEO optimized],\n      errors: [PostNotFound, IncompletePost, UnauthorizedPublish]\n    },\n    \n    getPost(postId: PostId, includeUnpublished: bool) -> PostInfo {\n      preconditions: [valid post ID],\n      postconditions: [returns post with content and metadata]\n    },\n    \n    searchPosts(criteria: SearchCriteria) -> PostInfo[] {\n      preconditions: [search criteria valid],\n      postconditions: [returns matching published posts],\n      errors: [InvalidSearchCriteria]\n    },\n    \n    addCategory(postId: PostId, categoryName: string) -> void {\n      preconditions: [post exists, category name valid],\n      postconditions: [post associated with category]\n    },\n    \n    addTags(postId: PostId, tags: string[]) -> void {\n      preconditions: [post exists, tags valid],\n      postconditions: [tags associated with post, searchable by tags]\n    }\n  }\n}\n\nDatabase BlogDatabase {\n  Table Posts {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      title: {type: String, required: true, maxLength: 200},\n      slug: {type: String, unique: true, required: true},\n      content: {type: Text, required: true},\n      excerpt: {type: String, maxLength: 500},\n      authorId: {type: UUID, foreignKey: \"Authors.id\"},\n      status: {type: String, enum: [\"draft\", \"published\", \"archived\"]},\n      publishedAt: {type: Timestamp},\n      featuredImage: {type: String},\n      seoTitle: {type: String, maxLength: 60},\n      seoDescription: {type: String, maxLength: 160},\n      createdAt: {type: Timestamp, default: \"now()\"},\n      updatedAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_slug\", columns: [\"slug\"]},\n      {name: \"idx_status_published\", columns: [\"status\", \"publishedAt\"]},\n      {name: \"idx_author\", columns: [\"authorId\"]}\n    ]\n  },\n  \n  Table Categories {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      name: {type: String, unique: true, required: true},\n      slug: {type: String, unique: true, required: true},\n      description: {type: String}\n    }\n  },\n  \n  Table PostCategories {\n    columns: {\n      postId: {type: UUID, foreignKey: \"Posts.id\"},\n      categoryId: {type: UUID, foreignKey: \"Categories.id\"}\n    }\n  },\n  \n  Table Tags {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      name: {type: String, unique: true, required: true},\n      slug: {type: String, unique: true, required: true}\n    }\n  },\n  \n  Table PostTags {\n    columns: {\n      postId: {type: UUID, foreignKey: \"Posts.id\"},\n      tagId: {type: UUID, foreignKey: \"Tags.id\"}\n    }\n  }\n}\n\nType PostInfo {\n  id: PostId,\n  title: string,\n  slug: string,\n  content: string,\n  excerpt: string,\n  author: AuthorInfo,\n  status: string,\n  publishedAt: timestamp,\n  categories: string[],\n  tags: string[]\n}\n\nType SearchCriteria {\n  keyword: string?,\n  category: string?,\n  tag: string?,\n  author: string?,\n  dateRange: DateRange?,\n  status: string?\n}\n</blueprint>"}
{"id": "crud_006", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Build a recipe collection system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to store and organize cooking recipes\n- Should handle ingredients, instructions, cooking times, servings\n- Must support recipe categorization and dietary restrictions\n- Should include search by ingredients and recipe attributes\n\nSTRATEGIC APPROACH:\n- Create recipe management service with detailed recipe storage\n- Include ingredient tracking with quantities and units\n- Support recipe categorization and dietary labeling\n- Add search functionality by ingredients and attributes\n- Include nutritional information and cooking metadata\n\nDESIGN PREPARATION:\n- Recipe entities with ingredients and step-by-step instructions\n- Ingredient database with units and nutritional data\n- Category and dietary restriction classification\n- Search and filtering by multiple criteria\n</thinking>\n\n<blueprint>\nService RecipeManager {\n  description: \"Manages cooking recipes with ingredients and dietary information\",\n  \n  dependencies: {\n    storage: RecipeDatabase,\n    nutrition: NutritionCalculator,\n    search: RecipeSearchEngine\n  },\n  \n  methods: {\n    addRecipe(recipe: RecipeInfo) -> RecipeId {\n      preconditions: [recipe name not empty, valid ingredients, instructions present],\n      postconditions: [recipe stored, nutrition calculated, searchable],\n      errors: [ValidationError, DuplicateRecipe]\n    },\n    \n    updateRecipe(recipeId: RecipeId, updates: RecipeUpdates) -> void {\n      preconditions: [recipe exists, updates valid],\n      postconditions: [recipe updated, nutrition recalculated],\n      errors: [RecipeNotFound, ValidationError]\n    },\n    \n    getRecipe(recipeId: RecipeId) -> RecipeInfo {\n      preconditions: [valid recipe ID],\n      postconditions: [returns complete recipe with ingredients and instructions]\n    },\n    \n    searchRecipes(criteria: RecipeSearchCriteria) -> RecipeInfo[] {\n      preconditions: [search criteria valid],\n      postconditions: [returns matching recipes ranked by relevance],\n      errors: [InvalidSearchCriteria]\n    },\n    \n    findRecipesByIngredient(ingredients: string[]) -> RecipeInfo[] {\n      preconditions: [ingredient list not empty],\n      postconditions: [returns recipes containing specified ingredients]\n    },\n    \n    scaleRecipe(recipeId: RecipeId, servings: int) -> ScaledRecipe {\n      preconditions: [recipe exists, servings positive],\n      postconditions: [returns recipe with scaled ingredient quantities],\n      errors: [RecipeNotFound, InvalidServings]\n    },\n    \n    addToMealPlan(recipeId: RecipeId, date: date) -> void {\n      preconditions: [recipe exists, valid date],\n      postconditions: [recipe added to meal plan, shopping list updated]\n    }\n  }\n}\n\nDatabase RecipeDatabase {\n  Table Recipes {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      name: {type: String, required: true, maxLength: 200},\n      description: {type: Text},\n      servings: {type: Int, required: true, min: 1},\n      prepTimeMinutes: {type: Int, min: 0},\n      cookTimeMinutes: {type: Int, min: 0},\n      totalTimeMinutes: {type: Int, min: 0},\n      difficulty: {type: String, enum: [\"easy\", \"medium\", \"hard\"]},\n      cuisine: {type: String, maxLength: 100},\n      course: {type: String, enum: [\"appetizer\", \"main\", \"dessert\", \"side\", \"snack\"]},\n      imageUrl: {type: String},\n      instructions: {type: Text, required: true},\n      createdBy: {type: UUID, foreignKey: \"Users.id\"},\n      createdAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_name\", columns: [\"name\"]},\n      {name: \"idx_cuisine_course\", columns: [\"cuisine\", \"course\"]},\n      {name: \"idx_difficulty\", columns: [\"difficulty\"]}\n    ]\n  },\n  \n  Table Ingredients {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      name: {type: String, unique: true, required: true},\n      category: {type: String, maxLength: 100},\n      caloriesPerUnit: {type: Decimal, precision: 6, scale: 2},\n      defaultUnit: {type: String, maxLength: 20}\n    }\n  },\n  \n  Table RecipeIngredients {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      recipeId: {type: UUID, foreignKey: \"Recipes.id\"},\n      ingredientId: {type: UUID, foreignKey: \"Ingredients.id\"},\n      quantity: {type: Decimal, precision: 8, scale: 3, required: true},\n      unit: {type: String, required: true, maxLength: 20},\n      notes: {type: String, maxLength: 200}\n    }\n  },\n  \n  Table DietaryRestrictions {\n    columns: {\n      recipeId: {type: UUID, foreignKey: \"Recipes.id\"},\n      restriction: {type: String, enum: [\"vegetarian\", \"vegan\", \"gluten-free\", \"dairy-free\", \"nut-free\", \"keto\", \"paleo\"]}\n    }\n  }\n}\n\nType RecipeInfo {\n  id: RecipeId,\n  name: string,\n  description: string,\n  servings: int,\n  prepTime: int,\n  cookTime: int,\n  totalTime: int,\n  difficulty: string,\n  cuisine: string,\n  course: string,\n  ingredients: RecipeIngredient[],\n  instructions: string,\n  dietaryRestrictions: string[],\n  nutritionInfo: NutritionInfo\n}\n\nType RecipeIngredient {\n  name: string,\n  quantity: decimal,\n  unit: string,\n  notes: string\n}\n\nType RecipeSearchCriteria {\n  keyword: string?,\n  cuisine: string?,\n  course: string?,\n  maxPrepTime: int?,\n  difficulty: string?,\n  dietaryRestrictions: string[]?,\n  includeIngredients: string[]?,\n  excludeIngredients: string[]?\n}\n</blueprint>"}
{"id": "crud_007", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Design a movie rating database", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to store movies and user ratings/reviews\n- Should handle movie metadata, cast, genres, release information\n- Must support user ratings, reviews, and recommendation features\n- Should include search and filtering by multiple criteria\n\nSTRATEGIC APPROACH:\n- Create movie database service with comprehensive metadata\n- Include user rating and review management\n- Support genre classification and cast/crew information\n- Add recommendation engine based on ratings\n- Include search functionality and trending calculations\n\nDESIGN PREPARATION:\n- Movie entities with detailed metadata and cast information\n- User rating and review system with validation\n- Genre and cast relationship management\n- Rating aggregation and recommendation algorithms\n</thinking>\n\n<blueprint>\nService MovieRatingSystem {\n  description: \"Manages movie database with user ratings and recommendations\",\n  \n  dependencies: {\n    storage: MovieDatabase,\n    recommendations: RecommendationEngine,\n    external: MovieMetadataAPI\n  },\n  \n  methods: {\n    addMovie(movie: MovieInfo) -> MovieId {\n      preconditions: [title not empty, valid release date, unique movie],\n      postconditions: [movie added, searchable, metadata indexed],\n      errors: [DuplicateMovie, ValidationError]\n    },\n    \n    updateMovie(movieId: MovieId, updates: MovieUpdates) -> void {\n      preconditions: [movie exists, updates valid],\n      postconditions: [movie updated, search index refreshed],\n      errors: [MovieNotFound, ValidationError]\n    },\n    \n    rateMovie(userId: UserId, movieId: MovieId, rating: Rating, review: string) -> void {\n      preconditions: [user exists, movie exists, rating valid],\n      postconditions: [rating recorded, average updated, recommendations recalculated],\n      errors: [UserNotFound, MovieNotFound, InvalidRating]\n    },\n    \n    getMovie(movieId: MovieId) -> MovieInfo {\n      preconditions: [valid movie ID],\n      postconditions: [returns complete movie information with ratings]\n    },\n    \n    searchMovies(criteria: MovieSearchCriteria) -> MovieInfo[] {\n      preconditions: [search criteria valid],\n      postconditions: [returns matching movies ranked by relevance],\n      errors: [InvalidSearchCriteria]\n    },\n    \n    getRecommendations(userId: UserId, count: int) -> MovieInfo[] {\n      preconditions: [user exists, user has rating history],\n      postconditions: [returns personalized movie recommendations],\n      errors: [UserNotFound, InsufficientData]\n    },\n    \n    getTrendingMovies(period: TimePeriod) -> MovieInfo[] {\n      preconditions: [valid time period],\n      postconditions: [returns trending movies for specified period]\n    }\n  }\n}\n\nDatabase MovieDatabase {\n  Table Movies {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      title: {type: String, required: true, maxLength: 300},\n      originalTitle: {type: String, maxLength: 300},\n      releaseDate: {type: Date, required: true},\n      runtime: {type: Int, min: 1},\n      plot: {type: Text},\n      director: {type: String, maxLength: 200},\n      language: {type: String, maxLength: 50},\n      country: {type: String, maxLength: 100},\n      budget: {type: Decimal, precision: 15, scale: 2},\n      boxOffice: {type: Decimal, precision: 15, scale: 2},\n      posterUrl: {type: String},\n      trailerUrl: {type: String},\n      averageRating: {type: Decimal, precision: 3, scale: 2},\n      totalRatings: {type: Int, default: 0},\n      createdAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_title\", columns: [\"title\"]},\n      {name: \"idx_release_date\", columns: [\"releaseDate\"]},\n      {name: \"idx_average_rating\", columns: [\"averageRating\"]}\n    ]\n  },\n  \n  Table Genres {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      name: {type: String, unique: true, required: true}\n    }\n  },\n  \n  Table MovieGenres {\n    columns: {\n      movieId: {type: UUID, foreignKey: \"Movies.id\"},\n      genreId: {type: UUID, foreignKey: \"Genres.id\"}\n    }\n  },\n  \n  Table Cast {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      movieId: {type: UUID, foreignKey: \"Movies.id\"},\n      actorName: {type: String, required: true, maxLength: 200},\n      characterName: {type: String, maxLength: 200},\n      role: {type: String, enum: [\"actor\", \"director\", \"producer\", \"writer\"]},\n      orderIndex: {type: Int}\n    }\n  },\n  \n  Table UserRatings {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      userId: {type: UUID, foreignKey: \"Users.id\"},\n      movieId: {type: UUID, foreignKey: \"Movies.id\"},\n      rating: {type: Decimal, precision: 2, scale: 1, min: 0.5, max: 5.0},\n      review: {type: Text},\n      helpfulVotes: {type: Int, default: 0},\n      createdAt: {type: Timestamp, default: \"now()\"}\n    },\n    constraints: [\n      {unique: [\"userId\", \"movieId\"]}\n    ]\n  }\n}\n\nType MovieInfo {\n  id: MovieId,\n  title: string,\n  releaseDate: date,\n  runtime: int,\n  plot: string,\n  director: string,\n  genres: string[],\n  cast: CastMember[],\n  averageRating: decimal,\n  totalRatings: int,\n  userRating: decimal?\n}\n\nType CastMember {\n  name: string,\n  characterName: string,\n  role: string\n}\n\nType MovieSearchCriteria {\n  title: string?,\n  genre: string?,\n  year: int?,\n  director: string?,\n  actor: string?,\n  minRating: decimal?,\n  language: string?\n}\n\nValidation RatingRules {\n  minimumRating: {value: 0.5},\n  maximumRating: {value: 5.0},\n  ratingIncrement: {value: 0.5},\n  minimumReviewLength: {characters: 10},\n  maximumReviewLength: {characters: 2000}\n}\n</blueprint>"}
{"id": "crud_008", "category": "basic_systems", "subcategory": "crud_operations", "difficulty": "basic", "user_query": "Create a music playlist manager", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to create and manage music playlists\n- Should handle songs, albums, artists, and playlist organization\n- Must support playlist sharing, collaboration, and discovery\n- Should include music metadata and search capabilities\n\nSTRATEGIC APPROACH:\n- Create playlist management service with song library\n- Include user playlist creation and sharing features\n- Support collaborative playlists and music discovery\n- Add search functionality across songs and playlists\n- Include music metadata and recommendation features\n\nDESIGN PREPARATION:\n- Song and album entities with artist and metadata\n- Playlist management with user ownership and sharing\n- Search capabilities across music library\n- Collaborative features and access control\n</thinking>\n\n<blueprint>\nService PlaylistManager {\n  description: \"Manages music playlists with sharing and collaboration features\",\n  \n  dependencies: {\n    storage: MusicDatabase,\n    metadata: MusicMetadataService,\n    sharing: PlaylistSharingService\n  },\n  \n  methods: {\n    createPlaylist(userId: UserId, playlistInfo: PlaylistInfo) -> PlaylistId {\n      preconditions: [user exists, playlist name not empty],\n      postconditions: [playlist created, user is owner, searchable],\n      errors: [UserNotFound, ValidationError]\n    },\n    \n    addSongToPlaylist(playlistId: PlaylistId, songId: SongId, position: int) -> void {\n      preconditions: [playlist exists, song exists, user has edit permission],\n      postconditions: [song added to playlist, order maintained],\n      errors: [PlaylistNotFound, SongNotFound, PermissionDenied]\n    },\n    \n    removeSongFromPlaylist(playlistId: PlaylistId, songId: SongId) -> void {\n      preconditions: [playlist exists, song in playlist, user has edit permission],\n      postconditions: [song removed, playlist order updated],\n      errors: [PlaylistNotFound, SongNotInPlaylist, PermissionDenied]\n    },\n    \n    sharePlaylist(playlistId: PlaylistId, shareSettings: ShareSettings) -> ShareResult {\n      preconditions: [playlist exists, user is owner],\n      postconditions: [playlist shared according to settings, access granted],\n      errors: [PlaylistNotFound, PermissionDenied]\n    },\n    \n    searchPlaylists(criteria: PlaylistSearchCriteria) -> PlaylistInfo[] {\n      preconditions: [search criteria valid],\n      postconditions: [returns matching public playlists],\n      errors: [InvalidSearchCriteria]\n    },\n    \n    getPlaylistRecommendations(userId: UserId) -> PlaylistInfo[] {\n      preconditions: [user exists, user has listening history],\n      postconditions: [returns personalized playlist recommendations],\n      errors: [UserNotFound, InsufficientData]\n    }\n  }\n}\n\nDatabase MusicDatabase {\n  Table Songs {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      title: {type: String, required: true, maxLength: 300},\n      artistId: {type: UUID, foreignKey: \"Artists.id\"},\n      albumId: {type: UUID, foreignKey: \"Albums.id\"},\n      duration: {type: Int, min: 1},\n      genre: {type: String, maxLength: 100},\n      year: {type: Int, min: 1900, max: 2100},\n      trackNumber: {type: Int, min: 1},\n      explicit: {type: Bool, default: false},\n      fileUrl: {type: String},\n      previewUrl: {type: String},\n      createdAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_title\", columns: [\"title\"]},\n      {name: \"idx_artist_album\", columns: [\"artistId\", \"albumId\"]}\n    ]\n  },\n  \n  Table Playlists {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      name: {type: String, required: true, maxLength: 200},\n      description: {type: Text},\n      ownerId: {type: UUID, foreignKey: \"Users.id\"},\n      isPublic: {type: Bool, default: false},\n      isCollaborative: {type: Bool, default: false},\n      coverImageUrl: {type: String},\n      totalDuration: {type: Int, default: 0},\n      songCount: {type: Int, default: 0},\n      createdAt: {type: Timestamp, default: \"now()\"},\n      updatedAt: {type: Timestamp, default: \"now()\"}\n    },\n    indexes: [\n      {name: \"idx_name\", columns: [\"name\"]},\n      {name: \"idx_owner_public\", columns: [\"ownerId\", \"isPublic\"]}\n    ]\n  },\n  \n  Table PlaylistSongs {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      playlistId: {type: UUID, foreignKey: \"Playlists.id\"},\n      songId: {type: UUID, foreignKey: \"Songs.id\"},\n      position: {type: Int, required: true},\n      addedBy: {type: UUID, foreignKey: \"Users.id\"},\n      addedAt: {type: Timestamp, default: \"now()\"}\n    },\n    constraints: [\n      {unique: [\"playlistId\", \"position\"]}\n    ]\n  },\n  \n  Table PlaylistFollowers {\n    columns: {\n      playlistId: {type: UUID, foreignKey: \"Playlists.id\"},\n      userId: {type: UUID, foreignKey: \"Users.id\"},\n      followedAt: {type: Timestamp, default: \"now()\"}\n    },\n    constraints: [\n      {unique: [\"playlistId\", \"userId\"]}\n    ]\n  }\n}\n\nType PlaylistInfo {\n  id: PlaylistId,\n  name: string,\n  description: string,\n  owner: UserInfo,\n  isPublic: bool,\n  isCollaborative: bool,\n  songs: PlaylistSong[],\n  totalDuration: int,\n  followerCount: int,\n  createdAt: timestamp\n}\n\nType PlaylistSong {\n  song: SongInfo,\n  position: int,\n  addedBy: UserInfo,\n  addedAt: timestamp\n}\n\nType ShareSettings {\n  isPublic: bool,\n  isCollaborative: bool,\n  allowedUsers: UserId[],\n  shareUrl: string?\n}\n</blueprint>"}