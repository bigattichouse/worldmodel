{"id": "blueprint_simcalc_ext_001", "category": "simple_calculations", "difficulty": "basic", "user_query": "Sales Tax Lookup Service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service that returns the applicable sales tax rate for a given US postal code.\n- This is not a calculation service, but a data lookup service.\n- The internal data could be complex, mapping zip codes to state, county, and city tax rates.\n\nSTRATEGIC APPROACH:\n- Design a `SalesTaxService`.\n- It will depend on a `TaxRateRepository` which holds the tax data.\n- Implement a `getRateForPostalCode` method.\n\nDESIGN PREPARATION:\n- A `TaxRateRepository` interface with a `findRateByPostalCode(postalCode: string)` method.\n- A `SalesTaxService` with a `getRateForPostalCode` method.\n- A `TaxRateResult` type to hold the combined rate and a breakdown.\n- Error handling for `PostalCodeNotFound`.\n</thinking>\n\n<blueprint>\nService SalesTaxService {\n  description: \"Looks up the sales tax rate for a given US postal code.\",\n  dependencies: {\n    taxData: TaxRateRepository\n  },\n  methods: {\n    getRateForPostalCode(postalCode: string) -> TaxRateResult {\n      preconditions: [postalCode is a valid 5-digit US postal code],\n      postconditions: [returns the combined sales tax rate and its breakdown],\n      errors: [PostalCodeNotFound, InvalidPostalCodeFormat]\n    }\n  }\n}\n\nService TaxRateRepository {\n  methods: {\n    findRateByPostalCode(postalCode: string) -> TaxRateDetails;\n  }\n}\n\nType TaxRateResult {\n  postalCode: string,\n  combinedRate: float,\n  stateRate: float,\n  countyRate: float,\n  cityRate: float\n}\n\nType TaxRateDetails {\n  // Internal representation of the data source\n  state: string,\n  county: string,\n  city: string,\n  rate: float\n}\n</blueprint>"}{"id": "blueprint_simcalc_ext_002", "category": "simple_calculations", "difficulty": "intermediate", "user_query": "Mortgage Affordability Calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to estimate the maximum mortgage a person can afford.\n- Inputs include annual income, monthly debts (e.g., car payments, student loans), and the desired down payment.\n- The calculation is based on debt-to-income (DTI) ratios, typically a 28% front-end ratio (housing costs) and a 36% back-end ratio (all debts).\n\nSTRATEGIC APPROACH:\n- Design a `MortgageAffordabilityService`.\n- Implement a `calculate` method that takes financial inputs.\n- The service will calculate the maximum affordable monthly payment based on DTI rules, and then work backward to estimate the total mortgage value, assuming a certain interest rate and loan term.\n\nDESIGN PREPARATION:\n- A `MortgageAffordabilityService` with a `calculate` method.\n- Inputs: `annualIncome: float`, `monthlyDebts: float`, `downPayment: float`, `loanTermYears: int`, `estimatedInterestRate: float`.\n- Configuration for DTI ratios (e.g., `maxHousingDti`, `maxTotalDti`).\n- A `AffordabilityResult` type showing the max mortgage and estimated monthly payment.\n</thinking>\n\n<blueprint>\nService MortgageAffordabilityService {\n  description: \"Estimates the maximum mortgage a person can afford based on income and debts.\",\n  configuration: {\n    maxHousingDti: 0.28, // Max percentage of gross income for housing costs\n    maxTotalDti: 0.36 // Max percentage of gross income for all debt payments\n  },\n  methods: {\n    calculate(annualIncome: float, monthlyDebts: float, downPayment: float, loanTermYears: int, estimatedInterestRate: float) -> AffordabilityResult {\n      preconditions: [annualIncome > 0, monthlyDebts >= 0, downPayment >= 0, loanTermYears > 0, estimatedInterestRate > 0],\n      postconditions: [returns the estimated maximum affordable mortgage and monthly payment],\n      errors: [InvalidInput]\n    }\n  }\n}\n\nType AffordabilityResult {\n  estimatedMaxMortgage: float,\n  estimatedMonthlyPayment: float,\n  maxAffordableHomePrice: float\n}\n</blueprint>"}{"id": "blueprint_simcalc_ext_003", "category": "simple_calculations", "difficulty": "basic", "user_query": "Data Transfer Time Calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to estimate the time required to transfer a file of a given size over a network with a specific bandwidth.\n- It needs to handle different units for file size (KB, MB, GB) and bandwidth (Mbps, Gbps).\n\nSTRATEGIC APPROACH:\n- Design a `TransferTimeCalculator` service.\n- The core logic is to convert both file size and bandwidth to a common base unit (e.g., bits) and then perform the division to find the time in seconds.\n- The service should return the time in a human-readable format (e.g., hours, minutes, seconds).\n\nDESIGN PREPARATION:\n- A `TransferTimeCalculator` with a `calculate` method.\n- Inputs: `fileSize: float`, `sizeUnit: string` (e.g., 'MB'), `bandwidth: float`, `bandwidthUnit: string` (e.g., 'Mbps').\n- A `TransferTimeResult` type to hold the result in seconds and as a formatted string.\n- Error handling for invalid units or zero bandwidth.\n</king>\n\n<blueprint>\nService TransferTimeCalculator {\n  description: \"Estimates the time to transfer a file over a network.\",\n  methods: {\n    calculate(fileSize: float, sizeUnit: string, bandwidth: float, bandwidthUnit: string) -> TransferTimeResult {\n      preconditions: [fileSize > 0, bandwidth > 0, units are valid and supported],\n      postconditions: [returns the estimated transfer time in seconds and a human-readable format],\n      errors: [InvalidInput, InvalidUnit, DivisionByZero]\n    }\n  }\n}\n\nType TransferTimeResult {\n  totalSeconds: float,\n  formattedTime: string // e.g., \"1 hour, 15 minutes, 30 seconds\"\n}\n</blueprint>"}{"id": "blueprint_simcalc_ext_004", "category": "simple_calculations", "difficulty": "basic", "user_query": "Fuel Cost Calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate the total fuel cost for a trip.\n- Inputs are the distance of the trip, the vehicle's fuel efficiency (e.g., MPG or KPL), and the price per unit of fuel.\n- Needs to handle different units for distance, efficiency, and volume.\n\nSTRATEGIC APPROACH:\n- Design a `FuelCostCalculator` service.\n- The method will first calculate the total amount of fuel needed for the trip (`distance / efficiency`).\n- Then it will multiply the fuel amount by the price per unit.\n- The service should internally handle unit conversions if necessary, or require standard units as input.\n\nDESIGN PREPARATION:\n- A `FuelCostCalculator` service with a `calculateTripCost` method.\n- Inputs: `distance: float`, `distanceUnit: string` (e.g., 'miles', 'km'), `fuelEfficiency: float`, `efficiencyUnit: string` (e.g., 'mpg', 'kpl'), `pricePerUnit: float`, `volumeUnit: string` (e.g., 'gallon', 'liter').\n- A `TripCostResult` type.\n- Error handling for zero or negative inputs.\n</king>\n\n<blueprint>\nService FuelCostCalculator {\n  description: \"Calculates the total fuel cost for a trip.\",\n  methods: {\n    calculateTripCost(distance: float, distanceUnit: string, fuelEfficiency: float, efficiencyUnit: string, pricePerUnit: float, volumeUnit: string) -> TripCostResult {\n      preconditions: [all inputs > 0, units are valid and compatible],\n      postconditions: [returns the total fuel needed and the total cost of the trip],\n      errors: [InvalidInput, IncompatibleUnits]\n    }\n  }\n}\n\nType TripCostResult {\n  totalFuelNeeded: float,\n  totalCost: float,\n  currency: string\n}\n</blueprint>"}{"id": "blueprint_simcalc_ext_005", "category": "simple_calculations", "difficulty": "basic", "user_query": "Kitchen Measurement Converter", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to convert between common kitchen/cooking measurements.\n- Units include volume (cups, tablespoons, teaspoons, ml, liters, fluid oz) and weight (grams, ounces, pounds).\n- This requires pre-defined conversion factors.\n\nSTRATEGIC APPROACH:\n- Design a `KitchenConverter` service.\n- The service will have an internal registry of conversion factors relative to a base unit for each measurement type (e.g., ml for volume, grams for weight).\n- A `convert` method will take a value and its source/target units, check for compatibility (i.e., volume to volume), and perform the conversion.\n\nDESIGN PREPARATION:\n- A `KitchenUnit` enum covering all supported units.\n- A `KitchenConverter` service with a `convert` method.\n- Inputs: `value: float`, `fromUnit: KitchenUnit`, `toUnit: KitchenUnit`.\n- A `ConvertedMeasurement` result type.\n- Error handling for `IncompatibleUnits` (e.g., trying to convert grams to cups without density).\n</king>\n\n<blueprint>\nService KitchenConverter {\n  description: \"Converts between common kitchen measurements (volume and weight).\",\n  methods: {\n    convert(value: float, fromUnit: KitchenUnit, toUnit: KitchenUnit) -> ConvertedMeasurement {\n      preconditions: [value >= 0, fromUnit and toUnit are compatible types (e.g., both are volume)],\n      postconditions: [returns the value converted to the target unit],\n      errors: [InvalidInput, IncompatibleUnits, UnsupportedUnit]\n    }\n  }\n}\n\nType KitchenUnit {\n  enum: [TEASPOON, TABLESPOON, FLUID_OUNCE, CUP, MILLILITER, LITER, GRAM, OUNCE, POUND]\n}\n\nType ConvertedMeasurement {\n  value: float,\n  unit: KitchenUnit\n}\n</blueprint>"}