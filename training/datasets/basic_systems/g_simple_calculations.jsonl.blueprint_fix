{"id": "blueprint_calc_017", "category": "simple_calculations", "difficulty": "basic", "user_query": "Salary calculator from hourly wages", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to calculate annual salary based on an hourly wage and work schedule.\n- Inputs should be hourly rate, hours per week, and number of weeks worked per year.\n- The output should be the gross annual salary.\n\nSTRATEGIC APPROACH:\n- Create a `SalaryCalculator` service.\n- Implement a method that takes wage and schedule information and returns the calculated annual salary.\n- Ensure inputs are validated for realistic values (e.g., positive numbers).\n\nDESIGN PREPARATION:\n- A `SalaryCalculator` service with a `calculateAnnualGross` method.\n- The method will perform the calculation: `hourlyRate * hoursPerWeek * weeksPerYear`.\n- Input validation for all parameters.\n- A result type to return the calculated amount.\n</thinking>\n\n<blueprint>\nService SalaryCalculator {\n  description: \"Calculates gross annual salary from hourly wage and work schedule.\",\n  methods: {\n    calculateAnnualGross(hourlyRate: float, hoursPerWeek: float, weeksPerYear: int) -> GrossSalary {\n      preconditions: [hourlyRate > 0, hoursPerWeek > 0 and hoursPerWeek <= 168, weeksPerYear > 0 and weeksPerYear <= 52],\n      postconditions: [returns the calculated gross annual salary],\n      errors: [InvalidInput]\n    }\n  }\n}\n\nType GrossSalary {\n  annualAmount: float,\n  currency: string // defaults to 'USD'\n}\n</blueprint>"}
{"id": "blueprint_calc_018", "category": "simple_calculations", "difficulty": "basic", "user_query": "Loan payment calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need to calculate the fixed monthly payment for a loan (e.g., a mortgage or auto loan).\n- The calculation requires the total loan amount (principal), the annual interest rate, and the loan term in years.\n- The service should return the calculated monthly payment.\n\nSTRATEGIC APPROACH:\n- Design a `LoanCalculator` service.\n- Implement a method that calculates the monthly payment using the standard amortization formula.\n- Inputs must be validated (e.g., principal and term must be positive, interest rate cannot be negative).\n\nDESIGN PREPARATION:\n- A `LoanCalculator` service with a `calculateMonthlyPayment` method.\n- The method will require `principal`, `annualInterestRate`, and `loanTermInYears` as inputs.\n- Internally, it will convert the annual rate to a monthly rate and the term to months before applying the formula: M = P * [r(1+r)^n] / [(1+r)^n â€“ 1].\n- A `MonthlyPayment` result type.\n</thinking>\n\n<blueprint>\nService LoanCalculator {\n  description: \"Calculates the fixed monthly payment for an amortized loan.\",\n  methods: {\n    calculateMonthlyPayment(principal: float, annualInterestRate: float, loanTermInYears: int) -> MonthlyPayment {\n      preconditions: [principal > 0, annualInterestRate >= 0, loanTermInYears > 0],\n      postconditions: [returns the calculated fixed monthly payment],\n      errors: [InvalidInput]\n    }\n  }\n}\n\nType MonthlyPayment {\n  amount: float,\n  currency: string\n}\n</blueprint>"}
{"id": "blueprint_calc_019", "category": "simple_calculations", "difficulty": "basic", "user_query": "Currency exchange service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to convert an amount from one currency to another.\n- It needs an amount, a source currency, and a target currency.\n- The exchange rates are dynamic and need to be sourced from a dependency.\n\nSTRATEGIC APPROACH:\n- Design a `CurrencyExchangeService`.\n- It will depend on an `ExchangeRateProvider` service that supplies the current rates.\n- Implement a `convert` method that uses the provider to perform the calculation.\n\nDESIGN PREPARATION:\n- An `ExchangeRateProvider` interface/dependency with a `getRate(from, to)` method.\n- A `CurrencyExchangeService` that takes the provider as a dependency.\n- A `convert` method that takes amount, source currency, and target currency.\n- Errors for `UnsupportedCurrency` or `RateUnavailable`.\n</thinking>\n\n<blueprint>\nService CurrencyExchangeService {\n  description: \"Converts an amount between different currencies using up-to-date exchange rates.\",\n  dependencies: {\n    rateProvider: ExchangeRateProvider\n  },\n  methods: {\n    convert(amount: float, fromCurrency: string, toCurrency: string) -> ConvertedAmount {\n      preconditions: [amount >= 0, fromCurrency and toCurrency are valid ISO 4217 codes],\n      postconditions: [returns the amount converted to the target currency based on the current exchange rate],\n      errors: [UnsupportedCurrency, RateUnavailable]\n    }\n  }\n}\n\nService ExchangeRateProvider {\n  description: \"Provides currency exchange rates. (Interface for dependency)\",\n  methods: {\n    getRate(fromCurrency: string, toCurrency: string) -> float {\n      preconditions: [],\n      postconditions: [returns the conversion rate from source to target currency],\n      errors: [RateUnavailable]\n    }\n  }\n}\n\nType ConvertedAmount {\n  amount: float,\n  currency: string\n}\n</blueprint>"}
{"id": "blueprint_calc_020", "category": "simple_calculations", "difficulty": "basic", "user_query": "BMI calculation system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to calculate Body Mass Index (BMI).\n- It needs a person's weight and height as inputs.\n- It should handle both metric (kg, meters) and imperial (pounds, inches) units.\n\nSTRATEGIC APPROACH:\n- Create a `BmiCalculator` service.\n- Implement a method that accepts weight and height along with their units.\n- The method will first convert inputs to a standard unit system (metric) and then apply the BMI formula (BMI = kg / m^2).\n\nDESIGN PREPARATION:\n- `UnitSystem` enum (METRIC, IMPERIAL).\n- `BmiCalculator` service with a `calculateBmi` method.\n- The method takes weight, height, and unit system.\n- Validation to ensure weight and height are positive.\n- A `BmiResult` type that includes the calculated BMI value and a standard category (e.g., 'Underweight', 'Normal').\n</thinking>\n\n<blueprint>\nService BmiCalculator {\n  description: \"Calculates Body Mass Index (BMI) from weight and height.\",\n  methods: {\n    calculateBmi(weight: float, height: float, units: UnitSystem) -> BmiResult {\n      preconditions: [weight > 0, height > 0],\n      postconditions: [returns the calculated BMI value and its corresponding weight status category],\n      errors: [InvalidInput]\n    }\n  }\n}\n\nType UnitSystem {\n  enum: [METRIC, IMPERIAL]\n}\n\nType BmiResult {\n  value: float,\n  category: string // e.g., 'Underweight', 'Normal', 'Overweight', 'Obese'\n}\n</blueprint>"}
{"id": "blueprint_calc_021", "category": "simple_calculations", "difficulty": "basic", "user_query": "Age calculator from birthdate", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate a person's current age based on their date of birth.\n- The input is a date of birth.\n- The output should be the age in years.\n\nSTRATEGIC APPROACH:\n- Design an `AgeCalculator` service.\n- Implement a method that takes a birthdate.\n- The calculation logic must correctly handle leap years and the current date to determine the full number of years passed.\n\nDESIGN PREPARATION:\n- An `AgeCalculator` service with a `calculateAge` method.\n- The method takes a `birthDate` as a date type.\n- Precondition to ensure the birthdate is in the past.\n- A result type to return the age in years.\n</king>\n\n<blueprint>\nService AgeCalculator {\n  description: \"Calculates a person's age from their date of birth.\",\n  methods: {\n    calculateAge(birthDate: date) -> Age {\n      preconditions: [birthDate is a valid date and is in the past],\n      postconditions: [returns the person's current age in whole years],\n      errors: [InvalidDate, FutureDateNotAllowed]\n    }\n  }\n}\n\nType Age {\n  years: int\n}\n</blueprint>"}
{"id": "blueprint_calc_022", "category": "simple_calculations", "difficulty": "basic", "user_query": "Distance and speed calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A calculator for solving distance, speed, or time given the other two variables.\n- For example, calculate distance given speed and time.\n- The service should be flexible to solve for any of the three variables.\n\nSTRATEGIC APPROACH:\n- Design a `MotionCalculator` service.\n- Create separate methods for each calculation: `calculateDistance`, `calculateSpeed`, `calculateTime`.\n- This is clearer than one complex method.\n- Ensure units are consistent (e.g., km/h, hours).\n\nDESIGN PREPARATION:\n- A `MotionCalculator` service.\n- `calculateDistance(speed: float, time: float)` method.\n- `calculateSpeed(distance: float, time: float)` method.\n- `calculateTime(distance: float, speed: float)` method.\n- Input validation to prevent division by zero or negative values.\n</thinking>\n\n<blueprint>\nService MotionCalculator {\n  description: \"Calculates distance, speed, or time given the other two variables.\",\n  methods: {\n    calculateDistance(speed: float, time: float) -> float {\n      preconditions: [speed >= 0, time >= 0],\n      postconditions: [returns the calculated distance (speed * time)],\n      errors: [InvalidInput]\n    },\n    calculateSpeed(distance: float, time: float) -> float {\n      preconditions: [distance >= 0, time > 0],\n      postconditions: [returns the calculated speed (distance / time)],\n      errors: [InvalidInput, DivisionByZero]\n    },\n    calculateTime(distance: float, speed: float) -> float {\n      preconditions: [distance >= 0, speed > 0],\n      postconditions: [returns the calculated time (distance / speed)],\n      errors: [InvalidInput, DivisionByZero]\n    }\n  }\n}\n</blueprint>"}
{"id": "blueprint_calc_023", "category": "simple_calculations", "difficulty": "basic", "user_query": "Tax calculation service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate the amount of tax on a given income or purchase amount.\n- It needs the base amount and a tax rate (percentage).\n- It should be able to calculate either the tax amount itself or the total amount including tax.\n\nSTRATEGIC APPROACH:\n- Create a `TaxCalculator` service.\n- Implement two distinct methods: `calculateTaxAmount` and `calculateTotalWithTax`.\n- The tax rate should be provided as a decimal (e.g., 0.05 for 5%).\n\nDESIGN PREPARATION:\n- A `TaxCalculator` service.\n- `calculateTaxAmount(baseAmount: float, taxRate: float)` method.\n- `calculateTotalWithTax(baseAmount: float, taxRate: float)` method.\n- Input validation for amounts and rates (must be non-negative).\n</thinking>\n\n<blueprint>\nService TaxCalculator {\n  description: \"Calculates tax amount and total price including tax.\",\n  methods: {\n    calculateTaxAmount(baseAmount: float, taxRate: float) -> float {\n      preconditions: [baseAmount >= 0, taxRate >= 0 and taxRate <= 1],\n      postconditions: [returns the calculated tax amount (baseAmount * taxRate)],\n      errors: [InvalidInput]\n    },\n    calculateTotalWithTax(baseAmount: float, taxRate: float) -> float {\n      preconditions: [baseAmount >= 0, taxRate >= 0 and taxRate <= 1],\n      postconditions: [returns the total amount including tax (baseAmount * (1 + taxRate))] errors: [InvalidInput]\n    }\n  }\n}\n</blueprint>"}
{"id": "blueprint_calc_024", "category": "simple_calculations", "difficulty": "basic", "user_query": "Tip calculator system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to calculate the tip for a meal or service.\n- It needs the bill amount and the desired tip percentage.\n- It should calculate the tip amount and the total bill (including tip).\n- It should also support splitting the total bill among a number of people.\n\nSTRATEGIC APPROACH:\n- Design a `TipCalculator` service.\n- Create a single method that returns a comprehensive result including tip amount, total bill, and per-person cost.\n- Inputs: bill amount, tip percentage, and number of people.\n\nDESIGN PREPARATION:\n- A `TipCalculator` service with a `calculate` method.\n- The method takes `billAmount`, `tipPercentage`, and `numberOfPeople`.\n- A `TipResult` type to hold all calculated values: `tipAmount`, `totalAmount`, `perPersonAmount`.\n- Validation for non-negative inputs and at least one person.\n</thinking>\n\n<blueprint>\nService TipCalculator {\n  description: \"Calculates tip, total bill, and per-person split.\",\n  methods: {\n    calculate(billAmount: float, tipPercentage: float, numberOfPeople: int) -> TipResult {\n      preconditions: [billAmount >= 0, tipPercentage >= 0, numberOfPeople >= 1],\n      postconditions: [returns an object with tip, total, and per-person amounts calculated],\n      errors: [InvalidInput]\n    }\n  }\n}\n\nType TipResult {\n  billAmount: float,\n  tipAmount: float,\n  totalAmount: float,\n  perPersonAmount: float\n}\n</blueprint>"}
{"id": "blueprint_calc_025", "category": "simple_calculations", "difficulty": "basic", "user_query": "Unit conversion service (length, weight, volume)", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A generic service to convert between different units of measurement.\n- It should support multiple types of units, such as length, weight, and volume.\n- The service needs a value, a source unit, and a target unit.\n\nSTRATEGIC APPROACH:\n- Design a `UnitConverter` service that is more generic than the temperature converter.\n- It will need an internal registry or configuration of conversion factors.\n- The core logic will be to convert the input value to a base unit for its category (e.g., meters for length) and then convert from that base unit to the target unit.\n\nDESIGN PREPARATION:\n- `UnitType` enum (LENGTH, WEIGHT, VOLUME).\n- `Unit` enum with all supported units (e.g., METER, KILOMETER, INCH, POUND, KILOGRAM, LITER).\n- A `UnitConverter` service with a `convert` method.\n- The `convert` method takes `value`, `fromUnit`, `toUnit`.\n- The service needs a way to know that `METER` and `INCH` are compatible (both LENGTH) but `METER` and `KILOGRAM` are not.\n- Errors for `IncompatibleUnits`.\n</thinking>\n\n<blueprint>\nService UnitConverter {\n  description: \"Converts between various units of length, weight, and volume.\",\n  methods: {\n    convert(value: float, fromUnit: Unit, toUnit: Unit) -> ConvertedUnit {\n      preconditions: [fromUnit and toUnit are compatible unit types (e.g., both are length)],\n      postconditions: [returns the value converted to the target unit],\n      errors: [IncompatibleUnits, UnsupportedUnit]\n    }\n  }\n}\n\nType Unit {\n  // This would be a comprehensive enum of all supported units\n  enum: [METER, FOOT, INCH, KILOGRAM, POUND, LITER, GALLON, ...] }\n\nType ConvertedUnit {\n  value: float,\n  unit: Unit\n}\n\n// The service implementation will contain the logic for conversion factors and compatibility checks.\n</blueprint>"}
{"id": "blueprint_calc_026", "category": "simple_calculations", "difficulty": "basic", "user_query": "Percentage calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to perform common percentage calculations.\n- Example operations: \"What is X% of Y?\", \"X is what percent of Y?\", and \"What is the percentage increase/decrease from X to Y?\".\n\nSTRATEGIC APPROACH:\n- Create a `PercentageCalculator` service.\n- Implement separate, clearly named methods for each type of calculation to avoid confusion.\n\nDESIGN PREPARATION:\n- `PercentageCalculator` service.\n- Method `calculatePercentageOf(baseValue: float, percentage: float)` returns `(baseValue * percentage / 100)`.\n- Method `calculateWhatPercent(part: float, whole: float)` returns `(part / whole * 100)`.\n- Method `calculatePercentageChange(initialValue: float, finalValue: float)` returns `((finalValue - initialValue) / initialValue * 100)`.\n- Validation to prevent division by zero.\n</thinking>\n\n<blueprint>\nService PercentageCalculator {\n  description: \"Performs various common percentage calculations.\",\n  methods: {\n    calculatePercentageOf(baseValue: float, percentage: float) -> float {\n      preconditions: [baseValue >= 0, percentage >= 0],\n      postconditions: [returns the value corresponding to the percentage of the base value],\n      errors: [InvalidInput]\n    },\n    calculateWhatPercent(part: float, whole: float) -> float {\n      preconditions: [part >= 0, whole > 0],\n      postconditions: [returns what percentage the part is of the whole],\n      errors: [InvalidInput, DivisionByZero]\n    },\n    calculatePercentageChange(initialValue: float, finalValue: float) -> float {\n      preconditions: [initialValue > 0],\n      postconditions: [returns the percentage change from the initial to the final value],\n      errors: [InvalidInput, DivisionByZero]\n    }\n  }\n}\n</blueprint>"}
{"id": "blueprint_calc_027", "category": "simple_calculations", "difficulty": "basic", "user_query": "Compound interest calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to calculate the future value of an investment with compound interest.\n- Required inputs: initial principal, annual interest rate, number of times interest is compounded per year, and the number of years the money is invested for.\n\nSTRATEGIC APPROACH:\n- Design a `CompoundInterestCalculator` service.\n- Implement a single method to calculate the future value using the formula: A = P(1 + r/n)^(nt).\n- Validate all inputs for positive values.\n\nDESIGN PREPARATION:\n- `CompoundInterestCalculator` service with a `calculateFutureValue` method.\n- Inputs: `principal`, `annualRate`, `compoundsPerYear`, `years`.\n- A `FutureValue` result type.\n- Input validation for all parameters.\n</thinking>\n\n<blueprint>\nService CompoundInterestCalculator {\n  description: \"Calculates the future value of an investment with compound interest.\",\n  methods: {\n    calculateFutureValue(principal: float, annualRate: float, compoundsPerYear: int, years: int) -> FutureValue {\n      preconditions: [principal > 0, annualRate >= 0, compoundsPerYear > 0, years > 0],\n      postconditions: [returns the total accumulated value of the investment after the specified term],\n      errors: [InvalidInput]\n    }\n  }\n}\n\nType FutureValue {\n  finalAmount: float,\n  totalInterestEarned: float,\n  currency: string\n}\n</blueprint>"}
{"id": "blueprint_calc_028", "category": "simple_calculations", "difficulty": "basic", "user_query": "Grade point average calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to calculate a Grade Point Average (GPA).\n- It needs a list of courses, where each course has a grade (e.g., 'A', 'B', 'C') and a number of credits or hours.\n- The system must convert letter grades to grade points (e.g., A=4.0, B=3.0) and calculate the weighted average.\n\nSTRATEGIC APPROACH:\n- Design a `GpaCalculator` service.\n- The service will take a list of course results as input.\n- It will have an internal mapping of letter grades to grade points.\n- The calculation is the sum of (grade points * credits) divided by the sum of all credits.\n\nDESIGN PREPARATION:\n- A `CourseResult` type (courseName, letterGrade, credits).\n- A `GpaCalculator` service with a `calculateGpa` method that accepts an array of `CourseResult`.\n- A `GpaResult` type to return the calculated GPA.\n- Error handling for unrecognized letter grades.\n</thinking>\n\n<blueprint>\nService GpaCalculator {\n  description: \"Calculates Grade Point Average (GPA) from a list of courses.\",\n  methods: {\n    calculateGpa(courses: array[CourseResult]) -> GpaResult {\n      preconditions: [courses list is not empty, all courses have valid grades and positive credits],\n      postconditions: [returns the calculated GPA on a 4.0 scale],\n      errors: [InvalidGrade, InvalidCredits]\n    }\n  }\n}\n\nType CourseResult {\n  letterGrade: string, // e.g., 'A', 'B+', 'C-'\n  credits: float\n}\n\nType GpaResult {\n  gpa: float,\n  totalCredits: float\n}\n\n// The service implementation will contain the mapping from letterGrade to grade points (e.g., A=4.0, A-=3.7, B+=3.3, B=3.0, etc.).\n</blueprint>"}
{"id": "blueprint_calc_029", "category": "simple_calculations", "difficulty": "basic", "user_query": "Calorie burn calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A service to estimate the number of calories burned during an activity.\n- The calculation depends on the activity type, the person's body weight, and the duration of the activity.\n- It will use MET (Metabolic Equivalent of Task) values for different activities.\n\nSTRATEGIC APPROACH:\n- Design a `CalorieBurnCalculator` service.\n- The service will have an internal mapping of activities to their MET values.\n- The formula is: Calories Burned = Duration (minutes) * MET * 3.5 * Body Weight (kg) / 200.\n\nDESIGN PREPARATION:\n- `ActivityType` enum or a string with a defined list of supported activities (e.g., RUNNING, WALKING, CYCLING).\n- A `CalorieBurnCalculator` service with a `calculateCaloriesBurned` method.\n- Inputs: `activity`, `durationInMinutes`, `bodyWeightInKg`.\n- Error handling for unsupported activities.\n</king>\n\n<blueprint>\nService CalorieBurnCalculator {\n  description: \"Estimates calories burned based on activity, duration, and body weight.\",\n  methods: {\n    calculateCaloriesBurned(activity: string, durationInMinutes: int, bodyWeightInKg: float) -> CaloriesBurned {\n      preconditions: [activity is supported, duration > 0, bodyWeight > 0],\n      postconditions: [returns the estimated number of calories burned],\n      errors: [UnsupportedActivity, InvalidInput]\n    }\n  }\n}\n\nType CaloriesBurned {\n  estimatedCalories: float\n}\n\n// The service implementation will contain a map of activities to their MET values.\n// e.g., { 'WALKING': 3.5, 'RUNNING': 7.0, 'CYCLING': 8.0 }\n</blueprint>"}
{"id": "blueprint_calc_030", "category": "simple_calculations", "difficulty": "basic", "user_query": "Budget allocation calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A tool to allocate a total budget across several categories based on percentages.\n- For example, given a monthly income of $5000, allocate 50% to housing, 20% to food, 10% to transport, etc.\n- The input is a total budget and a list of categories with their desired allocation percentages.\n\nSTRATEGIC APPROACH:\n- Create a `BudgetAllocator` service.\n- The service will take a total budget and a map or list of category allocations.\n- It should validate that the allocation percentages sum up to 100%.\n- The output will be a breakdown of the allocated amount for each category.\n\nDESIGN PREPARATION:\n- A `CategoryAllocation` type (categoryName, percentage).\n- A `BudgetAllocator` service with an `allocate` method that takes a `totalBudget` and an array of `CategoryAllocation`.\n- A precondition to check if the sum of percentages is 100.\n- A result type that returns a map of category names to their allocated dollar amounts.\n</thinking>\n\n<blueprint>\nService BudgetAllocator {\n  description: \"Allocates a total budget across categories based on percentages.\",\n  methods: {\n    allocate(totalBudget: float, allocations: array[CategoryAllocation]) -> BudgetBreakdown {\n      preconditions: [totalBudget > 0, the sum of percentages in allocations must be 100],\n      postconditions: [returns a breakdown of the budget allocated to each category],\n      errors: [InvalidInput, InvalidAllocationTotal]\n    }\n  }\n}\n\nType CategoryAllocation {\n  categoryName: string,\n  percentage: float\n}\n\nType BudgetBreakdown {\n  breakdown: map<string, float> // Maps categoryName to allocated amount\n}\n</blueprint>"}
