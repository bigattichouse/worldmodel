{"id": "calc_001", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Design a loan payment calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for monthly loan payments\n- Should handle principal amount, interest rate, loan term\n- Must calculate monthly payment, total interest, total cost\n- Should support different loan types and payment frequencies\n\nSTRATEGIC APPROACH:\n- Create loan calculation service with financial formulas\n- Support multiple payment frequencies (monthly, bi-weekly)\n- Include amortization schedule generation\n- Add validation for realistic loan parameters\n- Provide detailed payment breakdown information\n\nDESIGN PREPARATION:\n- Core payment calculation using standard formulas\n- Input validation for loan parameters\n- Payment schedule generation capabilities\n- Result formatting with financial details\n</thinking>\n\n<blueprint>\nService LoanCalculator {\n  description: \"Calculates loan payments and generates amortization schedules\",\n  \n  methods: {\n    calculateMonthlyPayment(principal: decimal, annualRate: decimal, termYears: int) -> PaymentResult {\n      preconditions: [principal > 0, annualRate >= 0, termYears > 0],\n      postconditions: [returns accurate monthly payment with breakdown],\n      errors: [InvalidPrincipal, InvalidRate, InvalidTerm]\n    },\n    \n    generateAmortizationSchedule(loanDetails: LoanDetails) -> AmortizationSchedule {\n      preconditions: [loan details valid],\n      postconditions: [returns complete payment schedule],\n      errors: [InvalidLoanDetails]\n    },\n    \n    calculateTotalCost(principal: decimal, monthlyPayment: decimal, termYears: int) -> CostBreakdown {\n      preconditions: [all parameters positive],\n      postconditions: [returns total cost analysis],\n      errors: [InvalidParameters]\n    },\n    \n    compareLoanOptions(loans: LoanOption[]) -> LoanComparison {\n      preconditions: [at least 2 loan options provided],\n      postconditions: [returns ranked comparison with metrics]\n    }\n  }\n}\n\nType PaymentResult {\n  monthlyPayment: decimal,\n  totalPayments: decimal,\n  totalInterest: decimal,\n  principal: decimal,\n  effectiveRate: decimal\n}\n\nType LoanDetails {\n  principal: decimal,\n  annualInterestRate: decimal,\n  termYears: int,\n  paymentFrequency: PaymentFrequency\n}\n\nType AmortizationSchedule {\n  payments: PaymentEntry[],\n  summary: PaymentSummary\n}\n\nType PaymentEntry {\n  paymentNumber: int,\n  paymentAmount: decimal,\n  principalPortion: decimal,\n  interestPortion: decimal,\n  remainingBalance: decimal,\n  paymentDate: date\n}\n\nType PaymentFrequency {\n  enum: [\"monthly\", \"bi-weekly\", \"weekly\", \"quarterly\"]\n}\n\nValidation LoanLimits {\n  minimumPrincipal: {value: 1000, currency: \"USD\"},\n  maximumPrincipal: {value: 10000000, currency: \"USD\"},\n  minimumRate: {value: 0.0, percentage: true},\n  maximumRate: {value: 50.0, percentage: true},\n  minimumTerm: {value: 1, unit: \"years\"},\n  maximumTerm: {value: 50, unit: \"years\"}\n}\n</blueprint>"}
{"id": "calc_002", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Create a BMI calculation system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to calculate Body Mass Index from height and weight\n- Should support different measurement units (metric, imperial)\n- Must provide BMI classification and health recommendations\n- Should include validation for realistic human measurements\n\nSTRATEGIC APPROACH:\n- Create BMI calculation service with unit conversion\n- Include standard BMI classification categories\n- Add health recommendations based on BMI ranges\n- Support both metric and imperial measurement systems\n- Include measurement validation and error handling\n\nDESIGN PREPARATION:\n- Core BMI calculation formula implementation\n- Unit conversion between metric and imperial\n- BMI classification according to WHO standards\n- Health recommendation database\n</thinking>\n\n<blueprint>\nService BMICalculator {\n  description: \"Calculates BMI with health classifications and recommendations\",\n  \n  dependencies: {\n    recommendations: HealthRecommendationService\n  },\n  \n  methods: {\n    calculateBMI(height: decimal, weight: decimal, units: MeasurementUnits) -> BMIResult {\n      preconditions: [height > 0, weight > 0, realistic measurements],\n      postconditions: [returns BMI with classification and recommendations],\n      errors: [InvalidHeight, InvalidWeight, UnrealisticMeasurement]\n    },\n    \n    convertUnits(measurement: Measurement, fromUnits: MeasurementUnits, toUnits: MeasurementUnits) -> decimal {\n      preconditions: [measurement valid, units supported],\n      postconditions: [returns converted measurement],\n      errors: [UnsupportedUnits, InvalidMeasurement]\n    },\n    \n    getBMIClassification(bmi: decimal) -> BMIClassification {\n      preconditions: [BMI value realistic],\n      postconditions: [returns WHO classification category]\n    },\n    \n    getHealthRecommendations(classification: BMIClassification, age: int, gender: Gender) -> HealthRecommendations {\n      preconditions: [valid classification and demographics],\n      postconditions: [returns personalized health advice]\n    }\n  }\n}\n\nType BMIResult {\n  bmi: decimal,\n  classification: BMIClassification,\n  category: string,\n  healthStatus: string,\n  recommendations: string[],\n  idealWeightRange: WeightRange\n}\n\nType BMIClassification {\n  category: string,\n  range: {min: decimal, max: decimal},\n  riskLevel: string,\n  description: string\n}\n\nType MeasurementUnits {\n  enum: [\"metric\", \"imperial\"]\n}\n\nType WeightRange {\n  minimum: decimal,\n  maximum: decimal,\n  units: string\n}\n\nValidation MeasurementRanges {\n  height: {\n    metric: {min: 0.5, max: 2.5, unit: \"meters\"},\n    imperial: {min: 20, max: 96, unit: \"inches\"}\n  },\n  weight: {\n    metric: {min: 20, max: 500, unit: \"kilograms\"},\n    imperial: {min: 44, max: 1100, unit: \"pounds\"}\n  },\n  age: {min: 2, max: 120, unit: \"years\"}\n}\n\nOperation BMIClassificationLookup {\n  classifications: [\n    {category: \"Underweight\", range: {min: 0, max: 18.4}, riskLevel: \"low-moderate\"},\n    {category: \"Normal\", range: {min: 18.5, max: 24.9}, riskLevel: \"low\"},\n    {category: \"Overweight\", range: {min: 25.0, max: 29.9}, riskLevel: \"moderate\"},\n    {category: \"Obese Class I\", range: {min: 30.0, max: 34.9}, riskLevel: \"high\"},\n    {category: \"Obese Class II\", range: {min: 35.0, max: 39.9}, riskLevel: \"very high\"},\n    {category: \"Obese Class III\", range: {min: 40.0, max: 100}, riskLevel: \"extremely high\"}\n  ]\n}\n</blueprint>"}
{"id": "calc_003", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Build a tip calculator system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for restaurant tips and bill splitting\n- Should handle different tip percentages and custom amounts\n- Must support splitting bills among multiple people\n- Should include tax considerations and rounding options\n\nSTRATEGIC APPROACH:\n- Create tip calculation service with flexible options\n- Support standard tip percentages and custom amounts\n- Include bill splitting functionality\n- Add tax calculation handling\n- Provide rounding options for practical payment\n\nDESIGN PREPARATION:\n- Core tip calculation with percentage and fixed amount options\n- Bill splitting logic with fair distribution\n- Tax handling for pre/post tax tip calculation\n- Rounding strategies for payment convenience\n</thinking>\n\n<blueprint>\nService TipCalculator {\n  description: \"Calculates tips and splits bills with flexible options\",\n  \n  methods: {\n    calculateTip(billAmount: decimal, tipPercentage: decimal, includesTax: bool) -> TipResult {\n      preconditions: [billAmount > 0, tipPercentage >= 0],\n      postconditions: [returns tip amount and total with breakdown],\n      errors: [InvalidBillAmount, InvalidTipPercentage]\n    },\n    \n    calculateCustomTip(billAmount: decimal, tipAmount: decimal) -> TipResult {\n      preconditions: [billAmount > 0, tipAmount >= 0],\n      postconditions: [returns equivalent tip percentage and totals],\n      errors: [InvalidAmount]\n    },\n    \n    splitBill(billAmount: decimal, tipPercentage: decimal, numberOfPeople: int, roundingOption: RoundingOption) -> BillSplit {\n      preconditions: [billAmount > 0, numberOfPeople > 0, tipPercentage >= 0],\n      postconditions: [returns per-person amounts with fair distribution],\n      errors: [InvalidParameters]\n    },\n    \n    calculateWithTax(subtotal: decimal, taxRate: decimal, tipPercentage: decimal, tipOnSubtotal: bool) -> TaxTipResult {\n      preconditions: [all amounts positive, taxRate reasonable],\n      postconditions: [returns complete breakdown with tax and tip],\n      errors: [InvalidTaxRate]\n    },\n    \n    suggestTipPercentages(serviceQuality: ServiceQuality, billAmount: decimal) -> TipSuggestions {\n      preconditions: [valid service quality rating],\n      postconditions: [returns appropriate tip percentage suggestions]\n    }\n  }\n}\n\nType TipResult {\n  originalAmount: decimal,\n  tipAmount: decimal,\n  tipPercentage: decimal,\n  totalAmount: decimal,\n  roundedTotal: decimal\n}\n\nType BillSplit {\n  totalBill: decimal,\n  totalTip: decimal,\n  grandTotal: decimal,\n  numberOfPeople: int,\n  perPersonSubtotal: decimal,\n  perPersonTip: decimal,\n  perPersonTotal: decimal,\n  roundingAdjustment: decimal\n}\n\nType TaxTipResult {\n  subtotal: decimal,\n  taxAmount: decimal,\n  tipAmount: decimal,\n  grandTotal: decimal,\n  effectiveTipRate: decimal\n}\n\nType ServiceQuality {\n  enum: [\"poor\", \"fair\", \"good\", \"excellent\", \"exceptional\"]\n}\n\nType RoundingOption {\n  enum: [\"none\", \"nearest_quarter\", \"nearest_dollar\", \"round_up\"]\n}\n\nType TipSuggestions {\n  serviceQuality: ServiceQuality,\n  suggestions: [\n    {percentage: decimal, description: string, amount: decimal}\n  ]\n}\n\nValidation TipCalculatorLimits {\n  minimumBill: {value: 0.01, currency: \"USD\"},\n  maximumBill: {value: 100000, currency: \"USD\"},\n  minimumTip: {value: 0, percentage: true},\n  maximumTip: {value: 100, percentage: true},\n  maximumPeople: {value: 100},\n  standardTipRates: {\n    poor: {min: 0, max: 10},\n    fair: {min: 10, max: 15},\n    good: {min: 15, max: 20},\n    excellent: {min: 20, max: 25},\n    exceptional: {min: 25, max: 30}\n  }\n}\n</blueprint>"}{"id": "calc_004", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Create a currency exchange calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need system to calculate currency exchanges between different currencies\n- Should support real-time or stored exchange rates\n- Must handle conversion fees and rate fluctuations\n- Should provide historical rate tracking\n\nSTRATEGIC APPROACH:\n- Create currency exchange service with rate management\n- Support multiple currency pairs and rate sources\n- Include fee calculation and rate markup handling\n- Add conversion history and rate tracking\n- Provide rate alerts and monitoring capabilities\n\nDESIGN PREPARATION:\n- Core exchange calculation with rate lookup\n- Rate provider integration for current rates\n- Fee structure for different exchange types\n- Historical data storage for rate tracking\n</thinking>\n\n<blueprint>\nService CurrencyExchangeCalculator {\n  description: \"Calculates currency exchanges with real-time rates and fees\",\n  \n  dependencies: {\n    rates: ExchangeRateProvider,\n    storage: CurrencyDatabase\n  },\n  \n  methods: {\n    convertCurrency(amount: decimal, fromCurrency: CurrencyCode, toCurrency: CurrencyCode, rateType: RateType) -> ConversionResult {\n      preconditions: [amount > 0, currencies valid, rate available],\n      postconditions: [returns accurate conversion with fees],\n      errors: [InvalidCurrency, RateUnavailable, InvalidAmount]\n    },\n    \n    calculateWithFees(amount: decimal, exchangeRate: decimal, feeStructure: FeeStructure) -> FeeBreakdown {\n      preconditions: [amount positive, rate valid],\n      postconditions: [returns total cost with fee breakdown],\n      errors: [InvalidFeeStructure]\n    },\n    \n    getHistoricalRates(fromCurrency: CurrencyCode, toCurrency: CurrencyCode, dateRange: DateRange) -> RateHistory {\n      preconditions: [currencies valid, date range reasonable],\n      postconditions: [returns historical rate data],\n      errors: [DataUnavailable]\n    },\n    \n    compareCurrencyRates(baseCurrency: CurrencyCode, targetCurrencies: CurrencyCode[]) -> RateComparison {\n      preconditions: [base currency valid, targets provided],\n      postconditions: [returns current rates for comparison]\n    }\n  }\n}\n\nType ConversionResult {\n  originalAmount: decimal,\n  convertedAmount: decimal,\n  exchangeRate: decimal,\n  totalFees: decimal,\n  netAmount: decimal,\n  rateTimestamp: timestamp\n}\n\nType CurrencyCode {\n  enum: [\"USD\", \"EUR\", \"GBP\", \"JPY\", \"CAD\", \"AUD\", \"CHF\", \"CNY\"]\n}\n\nType RateType {\n  enum: [\"spot\", \"buy\", \"sell\", \"mid\"]\n}\n\nType FeeStructure {\n  percentageFee: decimal,\n  fixedFee: decimal,\n  minimumFee: decimal,\n  maximumFee: decimal\n}\n\nValidation CurrencyLimits {\n  minimumExchange: {value: 1, currency: \"USD\"},\n  maximumExchange: {value: 1000000, currency: \"USD\"},\n  maxFeePercentage: {value: 10, percentage: true},\n  rateValidityPeriod: {value: 5, unit: \"minutes\"}\n}\n</blueprint>"}
{"id": "calc_005", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Design an age calculator from birthdate", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator to determine age from birthdate\n- Should support different date formats and time zones\n- Must calculate exact age in years, months, days\n- Should handle leap years and edge cases\n\nSTRATEGIC APPROACH:\n- Create age calculation service with precise date handling\n- Support multiple output formats (years, months, days, total days)\n- Include birthday detection and anniversary calculation\n- Add validation for realistic birthdates\n- Provide age-related calculations (retirement, milestones)\n\nDESIGN PREPARATION:\n- Core age calculation with date arithmetic\n- Date format parsing and validation\n- Leap year handling and edge case management\n- Age milestone and anniversary tracking\n</thinking>\n\n<blueprint>\nService AgeCalculator {\n  description: \"Calculates precise age and age-related information from birthdate\",\n  \n  methods: {\n    calculateAge(birthDate: date, referenceDate: date) -> AgeResult {\n      preconditions: [birthDate valid, birthDate <= referenceDate],\n      postconditions: [returns precise age breakdown],\n      errors: [InvalidBirthDate, FutureBirthDate]\n    },\n    \n    calculateAgeInDays(birthDate: date, referenceDate: date) -> int {\n      preconditions: [dates valid, birthDate <= referenceDate],\n      postconditions: [returns total days lived],\n      errors: [InvalidDates]\n    },\n    \n    getNextBirthday(birthDate: date, referenceDate: date) -> BirthdayInfo {\n      preconditions: [dates valid],\n      postconditions: [returns next birthday details],\n      errors: [InvalidDates]\n    },\n    \n    calculateMilestones(birthDate: date, milestoneAges: int[]) -> MilestoneInfo[] {\n      preconditions: [birthDate valid, milestones provided],\n      postconditions: [returns milestone dates and status]\n    },\n    \n    isLeapYearBaby(birthDate: date) -> bool {\n      preconditions: [birthDate valid],\n      postconditions: [returns true if born on Feb 29]\n    }\n  }\n}\n\nType AgeResult {\n  years: int,\n  months: int,\n  days: int,\n  totalDays: int,\n  totalMonths: int,\n  nextBirthdayDays: int\n}\n\nType BirthdayInfo {\n  nextBirthdayDate: date,\n  daysUntilBirthday: int,\n  turningAge: int,\n  dayOfWeek: string,\n  zodiacSign: string\n}\n\nType MilestoneInfo {\n  milestoneAge: int,\n  milestoneDate: date,\n  hasReached: bool,\n  daysRemaining: int,\n  description: string\n}\n\nValidation AgeLimits {\n  minimumBirthYear: {value: 1900},\n  maximumBirthYear: {value: 2030},\n  maximumAge: {value: 150, unit: \"years\"},\n  commonMilestones: [16, 18, 21, 30, 40, 50, 65, 100]\n}\n</blueprint>"}
{"id": "calc_006", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Build a unit conversion service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need comprehensive unit conversion for length, weight, volume, temperature\n- Should support metric, imperial, and other measurement systems\n- Must handle precision and rounding appropriately\n- Should include common conversions and scientific units\n\nSTRATEGIC APPROACH:\n- Create modular conversion service with category support\n- Include conversion factor database for accuracy\n- Support both direct conversions and base unit calculations\n- Add input validation and precision handling\n- Provide conversion history and favorite conversions\n\nDESIGN PREPARATION:\n- Conversion factor matrix for all supported units\n- Category-based organization (length, mass, volume, etc.)\n- Precision and rounding configuration\n- Validation for reasonable input ranges\n</thinking>\n\n<blueprint>\nService UnitConversionService {\n  description: \"Comprehensive unit conversion service for multiple measurement categories\",\n  \n  dependencies: {\n    factors: ConversionFactorDatabase\n  },\n  \n  methods: {\n    convertUnit(value: decimal, fromUnit: Unit, toUnit: Unit, precision: int) -> ConversionResult {\n      preconditions: [value >= 0, units compatible, precision reasonable],\n      postconditions: [returns accurate conversion with metadata],\n      errors: [IncompatibleUnits, InvalidValue, UnsupportedUnit]\n    },\n    \n    getSupportedUnits(category: UnitCategory) -> Unit[] {\n      preconditions: [category valid],\n      postconditions: [returns list of supported units in category],\n      errors: [InvalidCategory]\n    },\n    \n    convertMultiple(value: decimal, fromUnit: Unit, targetUnits: Unit[]) -> ConversionResult[] {\n      preconditions: [value valid, units compatible],\n      postconditions: [returns conversions to all target units]\n    },\n    \n    findBestUnit(value: decimal, unit: Unit, category: UnitCategory) -> Unit {\n      preconditions: [value positive, unit valid],\n      postconditions: [returns most appropriate unit for display]\n    },\n    \n    validateConversion(fromUnit: Unit, toUnit: Unit) -> bool {\n      preconditions: [units provided],\n      postconditions: [returns true if conversion is possible]\n    }\n  }\n}\n\nType ConversionResult {\n  originalValue: decimal,\n  convertedValue: decimal,\n  fromUnit: Unit,\n  toUnit: Unit,\n  conversionFactor: decimal,\n  precision: int,\n  formula: string\n}\n\nType Unit {\n  name: string,\n  symbol: string,\n  category: UnitCategory,\n  baseUnit: bool,\n  conversionFactor: decimal\n}\n\nType UnitCategory {\n  enum: [\"length\", \"mass\", \"volume\", \"temperature\", \"area\", \"speed\", \"pressure\", \"energy\"]\n}\n\nDatabase ConversionFactorDatabase {\n  Table ConversionFactors {\n    columns: {\n      id: {type: UUID, primaryKey: true},\n      category: {type: String, required: true},\n      unitName: {type: String, required: true},\n      symbol: {type: String, required: true},\n      toBaseMultiplier: {type: Decimal, precision: 20, scale: 10},\n      baseUnit: {type: Bool, default: false}\n    },\n    indexes: [\n      {name: \"idx_category\", columns: [\"category\"]},\n      {name: \"idx_unit_name\", columns: [\"unitName\"]}\n    ]\n  }\n}\n\nValidation ConversionLimits {\n  maxValue: {value: 1e20},\n  minValue: {value: 1e-20},\n  maxPrecision: {value: 15},\n  supportedCategories: [\"length\", \"mass\", \"volume\", \"temperature\", \"area\", \"speed\"]\n}\n</blueprint>"}
{"id": "calc_007", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Create a percentage calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for various percentage operations\n- Should handle percentage of numbers, percentage increase/decrease\n- Must calculate what percentage one number is of another\n- Should support percentage change calculations\n\nSTRATEGIC APPROACH:\n- Create percentage calculation service with multiple operation types\n- Support common percentage scenarios (discounts, tips, taxes, growth)\n- Include percentage change and difference calculations\n- Add validation for realistic percentage ranges\n- Provide formatted output for different use cases\n\nDESIGN PREPARATION:\n- Core percentage calculation formulas\n- Operation type classification and handling\n- Input validation for different calculation types\n- Result formatting for various contexts\n</thinking>\n\n<blueprint>\nService PercentageCalculator {\n  description: \"Comprehensive percentage calculations for various scenarios\",\n  \n  methods: {\n    calculatePercentageOf(number: decimal, percentage: decimal) -> decimal {\n      preconditions: [number >= 0, percentage >= 0],\n      postconditions: [returns percentage amount of number],\n      errors: [InvalidNumber, InvalidPercentage]\n    },\n    \n    calculateWhatPercentage(part: decimal, whole: decimal) -> decimal {\n      preconditions: [part >= 0, whole > 0],\n      postconditions: [returns what percentage part is of whole],\n      errors: [InvalidPart, InvalidWhole, DivisionByZero]\n    },\n    \n    calculatePercentageChange(originalValue: decimal, newValue: decimal) -> PercentageChange {\n      preconditions: [originalValue > 0, newValue >= 0],\n      postconditions: [returns percentage increase or decrease],\n      errors: [InvalidOriginalValue, InvalidNewValue]\n    },\n    \n    addPercentage(number: decimal, percentage: decimal) -> decimal {\n      preconditions: [number >= 0, percentage >= -100],\n      postconditions: [returns number after percentage increase/decrease],\n      errors: [InvalidInputs, ResultNegative]\n    },\n    \n    calculateDiscount(originalPrice: decimal, discountPercentage: decimal) -> DiscountResult {\n      preconditions: [originalPrice > 0, discountPercentage between 0 and 100],\n      postconditions: [returns discount amount and final price],\n      errors: [InvalidPrice, InvalidDiscount]\n    },\n    \n    calculateMarkup(cost: decimal, markupPercentage: decimal) -> MarkupResult {\n      preconditions: [cost > 0, markupPercentage >= 0],\n      postconditions: [returns markup amount and selling price],\n      errors: [InvalidCost, InvalidMarkup]\n    }\n  }\n}\n\nType PercentageChange {\n  originalValue: decimal,\n  newValue: decimal,\n  changeAmount: decimal,\n  changePercentage: decimal,\n  changeType: string,\n  isIncrease: bool\n}\n\nType DiscountResult {\n  originalPrice: decimal,\n  discountPercentage: decimal,\n  discountAmount: decimal,\n  finalPrice: decimal,\n  savingsAmount: decimal\n}\n\nType MarkupResult {\n  cost: decimal,\n  markupPercentage: decimal,\n  markupAmount: decimal,\n  sellingPrice: decimal,\n  profitMargin: decimal\n}\n\nValidation PercentageLimits {\n  maxPercentage: {value: 10000, unit: \"percent\"},\n  minPercentage: {value: -100, unit: \"percent\"},\n  maxValue: {value: 1000000000, currency: \"USD\"},\n  precisionDigits: {value: 4}\n}\n</blueprint>"}
{"id": "calc_008", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Design a compound interest calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for compound interest with various compounding periods\n- Should handle different compounding frequencies (daily, monthly, annually)\n- Must calculate future value with principal, rate, and time inputs\n- Should support additional contributions and withdrawals\n\nSTRATEGIC APPROACH:\n- Create compound interest service with flexible parameters\n- Support different compounding frequencies and calculation methods\n- Include additional deposit and withdrawal scenarios\n- Add comparison tools for different investment options\n- Provide growth visualization and milestone tracking\n\nDESIGN PREPARATION:\n- Core compound interest formula implementation\n- Compounding frequency handling\n- Additional contribution calculation logic\n- Investment comparison and optimization tools\n</thinking>\n\n<blueprint>\nService CompoundInterestCalculator {\n  description: \"Calculates compound interest with flexible parameters and scenarios\",\n  \n  methods: {\n    calculateFutureValue(principal: decimal, annualRate: decimal, years: decimal, compoundingFrequency: CompoundingFrequency) -> FutureValueResult {\n      preconditions: [principal > 0, annualRate >= 0, years > 0, frequency valid],\n      postconditions: [returns future value with interest breakdown],\n      errors: [InvalidPrincipal, InvalidRate, InvalidTime]\n    },\n    \n    calculateWithRegularContributions(initialPrincipal: decimal, monthlyContribution: decimal, annualRate: decimal, years: decimal) -> ContributionResult {\n      preconditions: [all amounts positive, realistic parameters],\n      postconditions: [returns total value with contribution impact],\n      errors: [InvalidParameters]\n    },\n    \n    calculateRequiredRate(principal: decimal, targetAmount: decimal, years: decimal, compoundingFrequency: CompoundingFrequency) -> decimal {\n      preconditions: [principal > 0, targetAmount > principal, years > 0],\n      postconditions: [returns required annual interest rate],\n      errors: [ImpossibleTarget]\n    },\n    \n    calculateTimeToTarget(principal: decimal, targetAmount: decimal, annualRate: decimal, compoundingFrequency: CompoundingFrequency) -> decimal {\n      preconditions: [principal > 0, targetAmount > principal, rate > 0],\n      postconditions: [returns years needed to reach target],\n      errors: [ImpossibleTarget]\n    },\n    \n    compareInvestmentOptions(investments: Investment[]) -> InvestmentComparison {\n      preconditions: [at least 2 investments provided],\n      postconditions: [returns ranked comparison with metrics]\n    }\n  }\n}\n\nType FutureValueResult {\n  principal: decimal,\n  interestEarned: decimal,\n  futureValue: decimal,\n  effectiveAnnualRate: decimal,\n  totalGrowthPercentage: decimal\n}\n\nType ContributionResult {\n  initialPrincipal: decimal,\n  totalContributions: decimal,\n  interestEarned: decimal,\n  finalValue: decimal,\n  contributionImpact: decimal\n}\n\nType CompoundingFrequency {\n  enum: [\"daily\", \"weekly\", \"monthly\", \"quarterly\", \"annually\", \"continuous\"]\n}\n\nType Investment {\n  name: string,\n  principal: decimal,\n  annualRate: decimal,\n  compoundingFrequency: CompoundingFrequency,\n  term: decimal\n}\n\nValidation CompoundInterestLimits {\n  minimumPrincipal: {value: 1, currency: \"USD\"},\n  maximumPrincipal: {value: 100000000, currency: \"USD\"},\n  minimumRate: {value: 0.0, percentage: true},\n  maximumRate: {value: 100.0, percentage: true},\n  minimumTerm: {value: 0.1, unit: \"years\"},\n  maximumTerm: {value: 100, unit: \"years\"}\n}\n</blueprint>"}
{"id": "calc_009", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Build a calorie burn calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for calories burned during various activities\n- Should account for body weight, activity type, and duration\n- Must provide accurate calorie estimates for different exercises\n- Should include metabolic rate calculations and activity intensity\n\nSTRATEGIC APPROACH:\n- Create calorie calculation service with activity database\n- Support different activity intensities and MET values\n- Include personal factors (weight, age, gender) in calculations\n- Add workout planning and calorie goal tracking\n- Provide activity recommendations for calorie targets\n\nDESIGN PREPARATION:\n- MET (Metabolic Equivalent) database for activities\n- Personal factor integration for accurate calculations\n- Activity intensity classification system\n- Calorie goal and workout planning tools\n</thinking>\n\n<blueprint>\nService CalorieBurnCalculator {\n  description: \"Calculates calories burned for various activities and personal factors\",\n  \n  dependencies: {\n    activities: ActivityDatabase,\n    metabolic: MetabolicCalculator\n  },\n  \n  methods: {\n    calculateCaloriesBurned(activity: Activity, duration: int, bodyWeight: decimal, intensity: Intensity) -> CalorieResult {\n      preconditions: [activity exists, duration > 0, weight > 0, intensity valid],\n      postconditions: [returns calories burned with breakdown],\n      errors: [InvalidActivity, InvalidDuration, InvalidWeight]\n    },\n    \n    calculateBasalMetabolicRate(age: int, gender: Gender, weight: decimal, height: decimal) -> BMRResult {\n      preconditions: [realistic age/weight/height, gender specified],\n      postconditions: [returns BMR and daily calorie needs],\n      errors: [InvalidDemographics]\n    },\n    \n    planWorkoutForCalories(targetCalories: decimal, availableTime: int, preferredActivities: Activity[]) -> WorkoutPlan {\n      preconditions: [target > 0, time > 0, activities provided],\n      postconditions: [returns optimized workout plan],\n      errors: [ImpossibleTarget]\n    },\n    \n    compareActivities(activities: Activity[], duration: int, bodyWeight: decimal) -> ActivityComparison {\n      preconditions: [activities provided, duration > 0, weight > 0],\n      postconditions: [returns calorie comparison for activities]\n    },\n    \n    trackDailyCalories(activities: ActivitySession[], bmr: decimal) -> DailyCalorieReport {\n      preconditions: [sessions logged, BMR calculated],\n      postconditions: [returns daily calorie expenditure summary]\n    }\n  }\n}\n\nType CalorieResult {\n  activity: string,\n  duration: int,\n  caloriesBurned: decimal,\n  caloriesPerMinute: decimal,\n  metValue: decimal,\n  intensityLevel: string\n}\n\nType BMRResult {\n  basalMetabolicRate: decimal,\n  dailyCalorieNeeds: decimal,\n  restingEnergyExpenditure: decimal,\n  metabolicAge: int\n}\n\nType Activity {\n  name: string,\n  category: ActivityCategory,\n  metValue: decimal,\n  description: string,\n  equipment: string[]\n}\n\nType Intensity {\n  enum: [\"light\", \"moderate\", \"vigorous\", \"high\"]\n}\n\nType ActivityCategory {\n  enum: [\"cardio\", \"strength\", \"sports\", \"household\", \"occupational\", \"recreational\"]\n}\n\nType WorkoutPlan {\n  totalCalories: decimal,\n  totalDuration: int,\n  activities: PlannedActivity[],\n  efficiency: decimal\n}\n\nValidation CalorieLimits {\n  minimumWeight: {value: 30, unit: \"kg\"},\n  maximumWeight: {value: 300, unit: \"kg\"},\n  minimumDuration: {value: 1, unit: \"minutes\"},\n  maximumDuration: {value: 480, unit: \"minutes\"},\n  ageRange: {min: 10, max: 100}\n}\n</blueprint>"}
{"id": "calc_010", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Create a grade point average calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for GPA based on grades and credit hours\n- Should support different grading scales (4.0, 5.0, 100-point)\n- Must handle weighted and unweighted GPA calculations\n- Should track cumulative GPA across semesters\n\nSTRATEGIC APPROACH:\n- Create GPA calculation service with multiple scale support\n- Include credit hour weighting for accurate calculations\n- Support semester-based and cumulative GPA tracking\n- Add grade conversion between different scales\n- Provide academic planning and target GPA tools\n\nDESIGN PREPARATION:\n- Grade scale conversion matrix\n- Credit hour weighting calculations\n- Cumulative GPA tracking across terms\n- Academic planning and goal-setting tools\n</thinking>\n\n<blueprint>\nService GPACalculator {\n  description: \"Calculates GPA with support for multiple grading scales and credit weighting\",\n  \n  methods: {\n    calculateSemesterGPA(courses: Course[], gradingScale: GradingScale) -> GPAResult {\n      preconditions: [courses provided, valid grades and credit hours],\n      postconditions: [returns semester GPA with breakdown],\n      errors: [InvalidGrade, InvalidCreditHours]\n    },\n    \n    calculateCumulativeGPA(semesters: Semester[]) -> CumulativeGPAResult {\n      preconditions: [at least one semester provided],\n      postconditions: [returns overall GPA across all semesters],\n      errors: [InconsistentGradingScale]\n    },\n    \n    convertGrade(grade: Grade, fromScale: GradingScale, toScale: GradingScale) -> Grade {\n      preconditions: [grade valid in from scale, scales supported],\n      postconditions: [returns equivalent grade in target scale],\n      errors: [UnsupportedScale, InvalidGrade]\n    },\n    \n    calculateTargetGrades(currentGPA: decimal, targetGPA: decimal, remainingCredits: decimal) -> TargetGradeResult {\n      preconditions: [GPAs valid, credits positive],\n      postconditions: [returns required average for remaining courses],\n      errors: [ImpossibleTarget]\n    },\n    \n    analyzeAcademicStanding(gpaHistory: GPAHistory[], requirements: AcademicRequirements) -> AcademicStanding {\n      preconditions: [history provided, requirements defined],\n      postconditions: [returns academic status and recommendations]\n    }\n  }\n}\n\nType Course {\n  name: string,\n  grade: Grade,\n  creditHours: decimal,\n  courseType: CourseType\n}\n\nType GPAResult {\n  semesterGPA: decimal,\n  totalCreditHours: decimal,\n  qualityPoints: decimal,\n  courseBreakdown: CourseGPA[]\n}\n\nType CumulativeGPAResult {\n  cumulativeGPA: decimal,\n  totalCreditHours: decimal,\n  totalQualityPoints: decimal,\n  semesterGPAs: decimal[],\n  academicStanding: string\n}\n\nType GradingScale {\n  enum: [\"four_point\", \"five_point\", \"hundred_point\", \"letter_plus_minus\"]\n}\n\nType Grade {\n  value: string,\n  numericValue: decimal,\n  qualityPoints: decimal\n}\n\nType CourseType {\n  enum: [\"regular\", \"honors\", \"ap\", \"dual_enrollment\"]\n}\n\nValidation GPALimits {\n  minimumCreditHours: {value: 0.5},\n  maximumCreditHours: {value: 12},\n  fourPointScale: {min: 0.0, max: 4.0},\n  fivePointScale: {min: 0.0, max: 5.0},\n  hundredPointScale: {min: 0, max: 100}\n}\n</blueprint>"}
{"id": "calc_011", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Design a budget allocation calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator to allocate income across budget categories\n- Should support percentage-based and fixed amount allocations\n- Must handle essential vs discretionary spending priorities\n- Should provide budget recommendations based on income levels\n\nSTRATEGIC APPROACH:\n- Create budget allocation service with flexible distribution methods\n- Support popular budgeting methods (50/30/20, zero-based, envelope)\n- Include priority-based allocation and overflow handling\n- Add budget optimization and adjustment recommendations\n- Provide spending tracking and variance analysis\n\nDESIGN PREPARATION:\n- Budget category classification system\n- Allocation method implementations\n- Priority-based distribution algorithms\n- Variance tracking and adjustment tools\n</thinking>\n\n<blueprint>\nService BudgetAllocationCalculator {\n  description: \"Calculates budget allocations using various budgeting methodologies\",\n  \n  methods: {\n    allocateByPercentage(income: decimal, allocations: CategoryAllocation[]) -> BudgetAllocation {\n      preconditions: [income > 0, allocations sum to 100%],\n      postconditions: [returns complete budget breakdown],\n      errors: [InvalidIncome, InvalidAllocations]\n    },\n    \n    allocateByPriority(income: decimal, expenses: Expense[], priorities: Priority[]) -> PriorityBudget {\n      preconditions: [income positive, expenses and priorities provided],\n      postconditions: [returns priority-based allocation],\n      errors: [InsufficientIncome]\n    },\n    \n    apply502020Rule(income: decimal) -> BudgetAllocation {\n      preconditions: [income > 0],\n      postconditions: [returns 50/30/20 budget allocation],\n      errors: [InvalidIncome]\n    },\n    \n    calculateBudgetVariance(plannedBudget: BudgetAllocation, actualSpending: Spending[]) -> VarianceReport {\n      preconditions: [budget and spending data provided],\n      postconditions: [returns variance analysis with recommendations],\n      errors: [MismatchedCategories]\n    },\n    \n    optimizeBudget(currentBudget: BudgetAllocation, goals: FinancialGoal[], constraints: BudgetConstraint[]) -> OptimizedBudget {\n      preconditions: [budget and goals provided],\n      postconditions: [returns optimized allocation for goals]\n    }\n  }\n}\n\nType CategoryAllocation {\n  category: BudgetCategory,\n  percentage: decimal,\n  minimumAmount: decimal,\n  maximumAmount: decimal\n}\n\nType BudgetAllocation {\n  totalIncome: decimal,\n  categories: CategoryBudget[],\n  remainingAmount: decimal,\n  allocationMethod: string\n}\n\nType BudgetCategory {\n  enum: [\"housing\", \"transportation\", \"food\", \"utilities\", \"insurance\", \"savings\", \"entertainment\", \"debt_payment\", \"healthcare\", \"other\"]\n}\n\nType Priority {\n  level: int,\n  category: BudgetCategory,\n  description: string\n}\n\nType VarianceReport {\n  totalVariance: decimal,\n  categoryVariances: CategoryVariance[],\n  overspentCategories: string[],\n  underspentCategories: string[],\n  recommendations: string[]\n}\n\nValidation BudgetLimits {\n  minimumIncome: {value: 100, currency: \"USD\"},\n  maximumIncome: {value: 1000000, currency: \"USD\"},\n  percentageRange: {min: 0, max: 100},\n  recommendedSavingsRate: {min: 10, max: 30, unit: \"percentage\"}\n}\n</blueprint>"}
{"id": "calc_012", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Build a distance and speed calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for distance, speed, and time relationships\n- Should support different units (metric, imperial, nautical)\n- Must handle D=SÃ—T calculations in all permutations\n- Should include fuel consumption and efficiency calculations\n\nSTRATEGIC APPROACH:\n- Create physics calculation service with unit conversions\n- Support solving for any variable given the other two\n- Include advanced calculations like acceleration and fuel economy\n- Add unit conversion between measurement systems\n- Provide travel time estimation and route planning\n\nDESIGN PREPARATION:\n- Core physics formulas for distance/speed/time\n- Unit conversion matrix for all measurement types\n- Fuel efficiency and consumption calculations\n- Travel planning with multiple segment support\n</thinking>\n\n<blueprint>\nService DistanceSpeedCalculator {\n  description: \"Calculates distance, speed, time relationships with unit conversions\",\n  \n  methods: {\n    calculateDistance(speed: decimal, time: decimal, speedUnit: SpeedUnit, timeUnit: TimeUnit) -> DistanceResult {\n      preconditions: [speed > 0, time > 0, units valid],\n      postconditions: [returns distance in multiple units],\n      errors: [InvalidSpeed, InvalidTime]\n    },\n    \n    calculateSpeed(distance: decimal, time: decimal, distanceUnit: DistanceUnit, timeUnit: TimeUnit) -> SpeedResult {\n      preconditions: [distance > 0, time > 0, units valid],\n      postconditions: [returns speed in multiple units],\n      errors: [InvalidDistance, InvalidTime]\n    },\n    \n    calculateTime(distance: decimal, speed: decimal, distanceUnit: DistanceUnit, speedUnit: SpeedUnit) -> TimeResult {\n      preconditions: [distance > 0, speed > 0, units valid],\n      postconditions: [returns time in multiple units],\n      errors: [InvalidParameters]\n    },\n    \n    convertUnits(value: decimal, fromUnit: Unit, toUnit: Unit) -> decimal {\n      preconditions: [value >= 0, units compatible],\n      postconditions: [returns converted value],\n      errors: [IncompatibleUnits]\n    },\n    \n    calculateFuelConsumption(distance: decimal, fuelEfficiency: decimal, fuelPrice: decimal) -> FuelCalculation {\n      preconditions: [all values positive],\n      postconditions: [returns fuel needed and cost]\n    }\n  }\n}\n\nType DistanceResult {\n  distance: decimal,\n  units: DistanceUnit,\n  conversions: {\n    kilometers: decimal,\n    miles: decimal,\n    meters: decimal,\n    feet: decimal\n  }\n}\n\nType SpeedResult {\n  speed: decimal,\n  units: SpeedUnit,\n  conversions: {\n    kmh: decimal,\n    mph: decimal,\n    mps: decimal,\n    knots: decimal\n  }\n}\n\nType TimeResult {\n  time: decimal,\n  units: TimeUnit,\n  conversions: {\n    hours: decimal,\n    minutes: decimal,\n    seconds: decimal\n  }\n}\n\nType DistanceUnit {\n  enum: [\"km\", \"miles\", \"meters\", \"feet\", \"yards\", \"nautical_miles\"]\n}\n\nType SpeedUnit {\n  enum: [\"kmh\", \"mph\", \"mps\", \"fps\", \"knots\"]\n}\n\nType TimeUnit {\n  enum: [\"seconds\", \"minutes\", \"hours\", \"days\"]\n}\n\nValidation PhysicsLimits {\n  maxSpeed: {value: 1000000, unit: \"kmh\"},\n  maxDistance: {value: 1000000000, unit: \"km\"},\n  maxTime: {value: 1000000, unit: \"hours\"}\n}\n</blueprint>"}
{"id": "calc_013", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Create a tax calculation service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need tax calculator for various income levels and tax systems\n- Should support different tax brackets and progressive rates\n- Must handle deductions, credits, and exemptions\n- Should calculate federal, state, and local taxes\n\nSTRATEGIC APPROACH:\n- Create tax calculation service with bracket management\n- Support multiple tax jurisdictions and filing statuses\n- Include deduction optimization and credit application\n- Add tax planning and estimation capabilities\n- Provide detailed breakdown of tax calculations\n\nDESIGN PREPARATION:\n- Progressive tax bracket calculation engine\n- Deduction and credit management system\n- Tax jurisdiction configuration\n- Tax planning and optimization tools\n</thinking>\n\n<blueprint>\nService TaxCalculationService {\n  description: \"Calculates taxes with progressive rates, deductions, and credits\",\n  \n  dependencies: {\n    brackets: TaxBracketService,\n    deductions: DeductionService\n  },\n  \n  methods: {\n    calculateIncomeTax(income: decimal, filingStatus: FilingStatus, jurisdiction: TaxJurisdiction) -> TaxResult {\n      preconditions: [income >= 0, status valid, jurisdiction supported],\n      postconditions: [returns complete tax calculation with breakdown],\n      errors: [InvalidIncome, UnsupportedJurisdiction]\n    },\n    \n    applyDeductions(grossIncome: decimal, deductions: Deduction[], deductionType: DeductionType) -> DeductionResult {\n      preconditions: [income positive, deductions valid],\n      postconditions: [returns taxable income after deductions],\n      errors: [InvalidDeduction]\n    },\n    \n    calculateCredits(taxLiability: decimal, credits: TaxCredit[]) -> CreditResult {\n      preconditions: [tax liability calculated, credits valid],\n      postconditions: [returns final tax after credits],\n      errors: [InvalidCredit]\n    },\n    \n    estimateQuarterlyTax(annualIncome: decimal, filingStatus: FilingStatus) -> QuarterlyEstimate {\n      preconditions: [income positive, status valid],\n      postconditions: [returns quarterly payment estimates]\n    },\n    \n    compareTaxScenarios(scenarios: TaxScenario[]) -> TaxComparison {\n      preconditions: [at least 2 scenarios provided],\n      postconditions: [returns comparative analysis]\n    }\n  }\n}\n\nType TaxResult {\n  grossIncome: decimal,\n  taxableIncome: decimal,\n  federalTax: decimal,\n  stateTax: decimal,\n  totalTax: decimal,\n  effectiveRate: decimal,\n  marginalRate: decimal,\n  afterTaxIncome: decimal\n}\n\nType FilingStatus {\n  enum: [\"single\", \"married_filing_jointly\", \"married_filing_separately\", \"head_of_household\"]\n}\n\nType DeductionType {\n  enum: [\"standard\", \"itemized\"]\n}\n\nType Deduction {\n  type: string,\n  amount: decimal,\n  description: string,\n  eligible: bool\n}\n\nType TaxCredit {\n  name: string,\n  amount: decimal,\n  refundable: bool,\n  phaseOutIncome: decimal\n}\n\nValidation TaxLimits {\n  minimumIncome: {value: 0, currency: \"USD\"},\n  maximumIncome: {value: 100000000, currency: \"USD\"},\n  maximumDeduction: {value: 1000000, currency: \"USD\"},\n  standardDeductions2024: {\n    single: 14600,\n    marriedJoint: 29200,\n    marriedSeparate: 14600,\n    headOfHousehold: 21900\n  }\n}\n</blueprint>"}
{"id": "calc_014", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Design a salary calculator from hourly wages", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator to convert hourly wages to various salary periods\n- Should account for overtime, holidays, and different work schedules\n- Must calculate gross and net income with tax considerations\n- Should support different pay frequencies and work arrangements\n\nSTRATEGIC APPROACH:\n- Create salary calculation service with flexible work schedule support\n- Include overtime calculations and holiday pay handling\n- Support various pay periods and tax withholding estimates\n- Add benefits cost integration and total compensation tracking\n- Provide salary comparison and negotiation tools\n\nDESIGN PREPARATION:\n- Work schedule and pay period calculation logic\n- Overtime and premium pay rate handling\n- Tax estimation and withholding calculations\n- Benefits integration and total compensation analysis\n</thinking>\n\n<blueprint>\nService SalaryCalculator {\n  description: \"Converts hourly wages to salary with overtime, benefits, and tax calculations\",\n  \n  dependencies: {\n    tax: TaxCalculationService,\n    benefits: BenefitsCalculator\n  },\n  \n  methods: {\n    calculateAnnualSalary(hourlyRate: decimal, hoursPerWeek: decimal, weeksPerYear: decimal) -> SalaryResult {\n      preconditions: [hourlyRate > 0, hours reasonable, weeks valid],\n      postconditions: [returns annual salary with breakdown],\n      errors: [InvalidRate, UnrealisticHours]\n    },\n    \n    calculateWithOvertime(regularRate: decimal, regularHours: decimal, overtimeHours: decimal, overtimeMultiplier: decimal) -> OvertimeResult {\n      preconditions: [rates positive, hours realistic, multiplier >= 1.0],\n      postconditions: [returns total pay with overtime breakdown],\n      errors: [InvalidParameters]\n    },\n    \n    calculatePayByPeriod(annualSalary: decimal, payFrequency: PayFrequency) -> PayPeriodResult {\n      preconditions: [salary positive, frequency valid],\n      postconditions: [returns pay amount for specified period],\n      errors: [InvalidSalary, UnsupportedFrequency]\n    },\n    \n    estimateNetPay(grossPay: decimal, filingStatus: FilingStatus, deductions: Deduction[]) -> NetPayResult {\n      preconditions: [gross pay positive, status valid],\n      postconditions: [returns net pay after taxes and deductions],\n      errors: [InvalidGrossPay]\n    },\n    \n    compareSalaryOffers(offers: SalaryOffer[]) -> OfferComparison {\n      preconditions: [at least 2 offers provided],\n      postconditions: [returns comprehensive offer analysis]\n    }\n  }\n}\n\nType SalaryResult {\n  hourlyRate: decimal,\n  annualSalary: decimal,\n  monthlyPay: decimal,\n  biweeklyPay: decimal,\n  weeklyPay: decimal,\n  workingHoursPerYear: decimal\n}\n\nType OvertimeResult {\n  regularPay: decimal,\n  overtimePay: decimal,\n  totalGrossPay: decimal,\n  effectiveHourlyRate: decimal,\n  overtimePercentage: decimal\n}\n\nType PayFrequency {\n  enum: [\"weekly\", \"biweekly\", \"semi_monthly\", \"monthly\", \"annually\"]\n}\n\nType NetPayResult {\n  grossPay: decimal,\n  federalTax: decimal,\n  stateTax: decimal,\n  socialSecurity: decimal,\n  medicare: decimal,\n  otherDeductions: decimal,\n  netPay: decimal,\n  takeHomePercentage: decimal\n}\n\nType SalaryOffer {\n  baseSalary: decimal,\n  bonusStructure: BonusStructure,\n  benefits: BenefitsPackage,\n  workSchedule: WorkSchedule,\n  location: string\n}\n\nValidation SalaryLimits {\n  minimumWage: {value: 7.25, currency: \"USD\"},\n  maximumRate: {value: 1000, currency: \"USD\"},\n  standardWorkWeek: {value: 40, unit: \"hours\"},\n  maximumWorkWeek: {value: 80, unit: \"hours\"},\n  weeksPerYear: {standard: 52, withVacation: 50}\n}\n</blueprint>"}
{"id": "calc_015", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Build a temperature conversion calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for temperature conversions between different scales\n- Should support Celsius, Fahrenheit, Kelvin, and other scales\n- Must provide accurate conversions with proper precision\n- Should include validation for realistic temperature ranges\n\nSTRATEGIC APPROACH:\n- Create temperature conversion service with multiple scale support\n- Include all major temperature scales and conversion formulas\n- Add temperature range validation and scientific applications\n- Support bulk conversions and temperature monitoring\n- Provide weather-related temperature calculations\n\nDESIGN PREPARATION:\n- Temperature scale conversion formulas\n- Range validation for different applications\n- Precision handling for scientific vs everyday use\n- Weather and climate-related calculations\n</thinking>\n\n<blueprint>\nService TemperatureConverter {\n  description: \"Converts temperatures between different scales with validation\",\n  \n  methods: {\n    convertTemperature(temperature: decimal, fromScale: TemperatureScale, toScale: TemperatureScale) -> ConversionResult {\n      preconditions: [temperature within valid range for scale],\n      postconditions: [returns accurate conversion with metadata],\n      errors: [InvalidTemperature, UnsupportedScale]\n    },\n    \n    convertToAllScales(temperature: decimal, fromScale: TemperatureScale) -> MultiScaleResult {\n      preconditions: [temperature and scale valid],\n      postconditions: [returns temperature in all supported scales],\n      errors: [InvalidInput]\n    },\n    \n    validateTemperature(temperature: decimal, scale: TemperatureScale, context: TemperatureContext) -> ValidationResult {\n      preconditions: [temperature and scale provided],\n      postconditions: [returns validation status with warnings if needed],\n      errors: [InvalidScale]\n    },\n    \n    calculateTemperatureDifference(temp1: decimal, temp2: decimal, scale: TemperatureScale) -> TemperatureDelta {\n      preconditions: [both temperatures valid in given scale],\n      postconditions: [returns temperature difference in multiple scales]\n    },\n    \n    findComfortZone(preferences: ComfortPreferences) -> ComfortZone {\n      preconditions: [preferences provided],\n      postconditions: [returns optimal temperature ranges]\n    }\n  }\n}\n\nType ConversionResult {\n  originalTemperature: decimal,\n  convertedTemperature: decimal,\n  fromScale: TemperatureScale,\n  toScale: TemperatureScale,\n  precision: int,\n  conversionFormula: string\n}\n\nType MultiScaleResult {\n  celsius: decimal,\n  fahrenheit: decimal,\n  kelvin: decimal,\n  rankine: decimal,\n  reaumur: decimal\n}\n\nType TemperatureScale {\n  enum: [\"celsius\", \"fahrenheit\", \"kelvin\", \"rankine\", \"reaumur\"]\n}\n\nType TemperatureContext {\n  enum: [\"weather\", \"cooking\", \"scientific\", \"medical\", \"industrial\"]\n}\n\nType ComfortZone {\n  optimalRange: TemperatureRange,\n  comfortableRange: TemperatureRange,\n  recommendations: string[]\n}\n\nValidation TemperatureLimits {\n  absoluteZero: {\n    celsius: -273.15,\n    fahrenheit: -459.67,\n    kelvin: 0\n  },\n  practicalLimits: {\n    weatherMin: -100,\n    weatherMax: 60,\n    cookingMax: 300,\n    unit: \"celsius\"\n  },\n  conversionPrecision: {digits: 2}\n}\n</blueprint>"}
{"id": "calc_015", "category": "basic_systems", "subcategory": "simple_calculations", "difficulty": "basic", "user_query": "Build a temperature conversion calculator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- Need calculator for temperature conversions between different scales\n- Should support Celsius, Fahrenheit, Kelvin, and other scales\n- Must provide accurate conversions with proper precision\n- Should include validation for realistic temperature ranges\n\nSTRATEGIC APPROACH:\n- Create temperature conversion service with multiple scale support\n- Include all major temperature scales and conversion formulas\n- Add temperature range validation and scientific applications\n- Support bulk conversions and temperature monitoring\n- Provide weather-related temperature calculations\n\nDESIGN PREPARATION:\n- Temperature scale conversion formulas\n- Range validation for different applications\n- Precision handling for scientific vs everyday use\n- Weather and climate-related calculations\n</thinking>\n\n<blueprint>\nService TemperatureConverter {\n  description: \"Converts temperatures between different scales with validation\",\n  \n  methods: {\n    convertTemperature(temperature: decimal, fromScale: TemperatureScale, toScale: TemperatureScale) -> ConversionResult {\n      preconditions: [temperature within valid range for scale],\n      postconditions: [returns accurate conversion with metadata],\n      errors: [InvalidTemperature, UnsupportedScale]\n    },\n    \n    convertToAllScales(temperature: decimal, fromScale: TemperatureScale) -> MultiScaleResult {\n      preconditions: [temperature and scale valid],\n      postconditions: [returns temperature in all supported scales],\n      errors: [InvalidInput]\n    },\n    \n    validateTemperature(temperature: decimal, scale: TemperatureScale, context: TemperatureContext) -> ValidationResult {\n      preconditions: [temperature and scale provided],\n      postconditions: [returns validation status with warnings if needed],\n      errors: [InvalidScale]\n    },\n    \n    calculateTemperatureDifference(temp1: decimal, temp2: decimal, scale: TemperatureScale) -> TemperatureDelta {\n      preconditions: [both temperatures valid in given scale],\n      postconditions: [returns temperature difference in multiple scales]\n    },\n    \n    findComfortZone(preferences: ComfortPreferences) -> ComfortZone {\n      preconditions: [preferences provided],\n      postconditions: [returns optimal temperature ranges]\n    }\n  }\n}\n\nType ConversionResult {\n  originalTemperature: decimal,\n  convertedTemperature: decimal,\n  fromScale: TemperatureScale,\n  toScale: TemperatureScale,\n  precision: int,\n  conversionFormula: string\n}\n\nType MultiScaleResult {\n  celsius: decimal,\n  fahrenheit: decimal,\n  kelvin: decimal,\n  rankine: decimal,\n  reaumur: decimal\n}\n\nType TemperatureScale {\n  enum: [\"celsius\", \"fahrenheit\", \"kelvin\", \"rankine\", \"reaumur\"]\n}\n\nType TemperatureContext {\n  enum: [\"weather\", \"cooking\", \"scientific\", \"medical\", \"industrial\"]\n}\n\nType ComfortZone {\n  optimalRange: TemperatureRange,\n  comfortableRange: TemperatureRange,\n  recommendations: string[]\n}\n\nValidation TemperatureLimits {\n  absoluteZero: {\n    celsius: -273.15,\n    fahrenheit: -459.67,\n    kelvin: 0\n  },\n  practicalLimits: {\n    weatherMin: -100,\n    weatherMax: 60,\n    cookingMax: 300,\n    unit: \"celsius\"\n  },\n  conversionPrecision: {digits: 2}\n}\n</blueprint>"}
