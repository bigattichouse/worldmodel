{"id": "blueprint_biz_101", "category": "hr_management", "difficulty": "intermediate", "user_query": "Employee onboarding workflow", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to manage the onboarding process for new employees.\n- This includes tasks like setting up accounts, assigning equipment, training modules, and collecting necessary paperwork.\n- It's a multi-step workflow involving different departments.\n\nSTRATEGIC APPROACH:\n- Design an `OnboardingService`.\n- Define an `OnboardingCase` entity with a state reflecting its current stage in the workflow.\n- Implement methods for advancing the case through its states, with preconditions for each transition.\n\nDESIGN PREPARATION:\n- `OnboardingCase` data model (employeeId, managerId, status: Initiated/DocumentsComplete/ITSetup/Training/Completed).\n- `OnboardingTask` data model (taskId, caseId, description, assignedTo, dueDate, completedDate, status).\n- `OnboardingService` with methods: `initiateOnboarding`, `completeTask`, `updateCaseStatus`, `getOnboardingProgress`.\n- `OnboardingRepository` for persistence.\n- Error handling for `EmployeeNotFound`, `CaseNotFound`, `InvalidWorkflowState`.\n</thinking>\n\n<blueprint>\nService OnboardingService {\n  description: \"Manages the multi-step onboarding process for new employees.\",\n  dependencies: {\n    onboardingRepo: OnboardingRepository,\n    userService: UserService,\n    itService: ITSetupService,\n    assetService: AssetManagementService\n  },\n  methods: {\n    initiateOnboarding(employeeId: UUID, managerId: UUID) -> OnboardingCase {\n      preconditions: [employeeId and managerId exist],\n      postconditions: [a new onboarding case is created with 'Initiated' status],\n      errors: [UserNotFound]\n    },\n    completeTask(caseId: UUID, taskId: UUID, completedBy: UUID) -> OnboardingTask {\n      preconditions: [caseId exists, taskId exists, task is assigned to or can be completed by completedBy],\n      postconditions: [task status is marked 'Completed', case status may advance],\n      errors: [CaseNotFound, TaskNotFound, UnauthorizedAccess]\n    },\n    updateCaseStatus(caseId: UUID, newStatus: OnboardingStatus, adminId: UUID) -> OnboardingCase {\n      preconditions: [caseId exists, adminId has authority, newStatus is a valid transition],\n      postconditions: [onboarding case status is updated],\n      errors: [CaseNotFound, UnauthorizedAccess, InvalidStatusTransition]\n    },\n    getOnboardingProgress(employeeId: UUID) -> OnboardingProgress {\n      preconditions: [employeeId exists],\n      postconditions: [returns the current status and pending tasks for an employee's onboarding],\n      errors: [EmployeeNotFound, CaseNotFound]\n    }\n  }\n}\n\nService OnboardingRepository {\n  methods: {\n    save(onboardingCase: OnboardingCase) -> OnboardingCase;\n    findById(caseId: UUID) -> OnboardingCase;\n    findTasksByCaseId(caseId: UUID) -> array[OnboardingTask];\n  }\n}\n\nType OnboardingStatus {\n  enum: [INITIATED, DOCUMENTS_PENDING, DOCUMENTS_COMPLETE, IT_SETUP_PENDING, IT_SETUP_COMPLETE, TRAINING_PENDING, TRAINING_COMPLETE, COMPLETED, CANCELED]\n}\n\nType OnboardingCase {\n  id: UUID,\n  employeeId: UUID,\n  managerId: UUID,\n  status: OnboardingStatus,\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType OnboardingTask {\n  id: UUID,\n  caseId: UUID,\n  description: string,\n  assignedTo: UUID,\n  dueDate: date,\n  completedDate: date | null,\n  status: string // PENDING, COMPLETED\n}\n\nType OnboardingProgress {\n  caseId: UUID,\n  employeeId: UUID,\n  currentStatus: OnboardingStatus,\n  completedTasks: int,\n  totalTasks: int,\n  pendingTasks: array[OnboardingTask]\n}\n</blueprint>"}
{"id": "blueprint_biz_102", "category": "hr_management", "difficulty": "intermediate", "user_query": "Performance review system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to facilitate and track employee performance reviews.\n- It needs to allow managers to create reviews, set goals, provide feedback, and track progress over time.\n- Involves self-assessments, manager assessments, and peer feedback.\n\nSTRATEGIC APPROACH:\n- Design a `PerformanceReviewService`.\n- Define `PerformanceReview`, `Goal`, and `Feedback` entities.\n- Implement a workflow for review cycles, including creation, submission, and finalization.\n\nDESIGN PREPARATION:\n- `PerformanceReview` data model (reviewId, employeeId, managerId, cycle: string, status: Draft/Submitted/ManagerReview/Finalized).\n- `Goal` data model (goalId, reviewId, description, targetDate, status).\n- `Feedback` data model (feedbackId, reviewId, fromUserId, toUserId, content, type: Peer/Manager/Self).\n- `PerformanceReviewService` with methods: `createReview`, `setGoal`, `submitFeedback`, `finalizeReview`.\n- `ReviewRepository` for persistence.\n- Error handling for `ReviewNotFound`, `UnauthorizedAccess`, `InvalidStatusTransition`.\n</thinking>\n\n<blueprint>\nService PerformanceReviewService {\n  description: \"Facilitates and tracks employee performance reviews, goals, and feedback.\",\n  dependencies: {\n    reviewRepo: PerformanceReviewRepository,\n    userService: UserService\n  },\n  methods: {\n    createReview(employeeId: UUID, managerId: UUID, reviewCycle: string) -> PerformanceReview {\n      preconditions: [employeeId exists, managerId exists and is employee's manager],\n      postconditions: [a new performance review is created with 'Draft' status],\n      errors: [UserNotFound, NotManager]\n    },\n    setGoal(reviewId: UUID, description: string, targetDate: date) -> Goal {\n      preconditions: [reviewId exists, review status is 'Draft' or 'ManagerReview'],\n      postconditions: [a new goal is added to the review],\n      errors: [ReviewNotFound, InvalidStatusTransition]\n    },\n    submitFeedback(reviewId: UUID, fromUserId: UUID, toUserId: UUID, content: string, type: string) -> Feedback {\n      preconditions: [reviewId exists, fromUserId and toUserId exist, content is not empty],\n      postconditions: [feedback is recorded for the review],\n      errors: [ReviewNotFound, UserNotFound, InvalidInput]\n    },\n    finalizeReview(reviewId: UUID, managerId: UUID) -> PerformanceReview {\n      preconditions: [reviewId exists, managerId is authorized, review status is 'ManagerReview'],\n      postconditions: [review status changes to 'Finalized', review is locked for editing],\n      errors: [ReviewNotFound, UnauthorizedAccess, InvalidStatusTransition]\n    }\n  }\n}\n\nService PerformanceReviewRepository {\n  methods: {\n    save(review: PerformanceReview) -> PerformanceReview;\n    findById(reviewId: UUID) -> PerformanceReview;\n    findGoalsByReviewId(reviewId: UUID) -> array[Goal];\n    findFeedbackByReviewId(reviewId: UUID) -> array[Feedback];\n  }\n}\n\nType ReviewStatus {\n  enum: [DRAFT, EMPLOYEE_SUBMITTED, MANAGER_REVIEW, FINALIZED]\n}\n\nType PerformanceReview {\n  id: UUID,\n  employeeId: UUID,\n  managerId: UUID,\n  reviewCycle: string,\n  status: ReviewStatus,\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType Goal {\n  id: UUID,\n  reviewId: UUID,\n  description: string,\n  targetDate: date,\n  status: string // e.g., 'OPEN', 'COMPLETED', 'ON_TRACK'\n}\n\nType Feedback {\n  id: UUID,\n  reviewId: UUID,\n  fromUserId: UUID,\n  toUserId: UUID,\n  content: string,\n  type: string, // e.g., 'SELF', 'MANAGER', 'PEER'\n  timestamp: timestamp\n}\n</blueprint>"}
{"id": "blueprint_biz_103", "category": "hr_management", "difficulty": "intermediate", "user_query": "Leave request management", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to allow employees to request time off (vacation, sick leave) and for managers to approve or deny these requests.\n- Needs to track leave balances and ensure requests adhere to company policies.\n\nSTRATEGIC APPROACH:\n- Design a `LeaveService`.\n- Define a `LeaveRequest` entity with type, dates, status, and associated employee/manager.\n- Implement a workflow for request submission, approval, and balance updates.\n\nDESIGN PREPARATION:\n- `LeaveRequest` data model (requestId, employeeId, type: Vacation/Sick/Paternity, startDate, endDate, status: Pending/Approved/Rejected, managerId, rejectionReason).\n- `LeaveBalance` data model (employeeId, leaveType, accruedDays, usedDays).\n- `LeaveService` with methods: `submitRequest`, `approveRequest`, `denyRequest`, `getLeaveBalance`.\n- `LeaveRepository` for persistence.\n- Error handling for `EmployeeNotFound`, `InsufficientLeaveBalance`, `InvalidDates`.\n</thinking>\n\n<blueprint>\nService LeaveService {\n  description: \"Manages employee leave requests, approvals, and balances.\",\n  dependencies: {\n    leaveRepo: LeaveRequestRepository,\n    balanceRepo: LeaveBalanceRepository,\n    policyService: LeavePolicyService,\n    userService: UserService\n  },\n  methods: {\n    submitRequest(employeeId: UUID, type: LeaveType, startDate: date, endDate: date) -> LeaveRequest {\n      preconditions: [employeeId exists, startDate before or equal to endDate, dates are in future],\n      postconditions: [a new leave request is created with 'Pending' status, checks against policy],\n      errors: [EmployeeNotFound, InvalidDates, PolicyViolation, InsufficientLeaveBalance]\n    },\n    approveRequest(requestId: UUID, managerId: UUID) -> LeaveRequest {\n      preconditions: [requestId exists, request is 'Pending', managerId is authorized],\n      postconditions: [request status changes to 'Approved', employee's leave balance updated],\n      errors: [LeaveRequestNotFound, UnauthorizedAccess, InvalidStatusTransition]\n    },\n    denyRequest(requestId: UUID, managerId: UUID, reason: string) -> LeaveRequest {\n      preconditions: [requestId exists, request is 'Pending', managerId is authorized],\n      postconditions: [request status changes to 'Rejected', rejection reason recorded],\n      errors: [LeaveRequestNotFound, UnauthorizedAccess, InvalidStatusTransition]\n    },\n    getLeaveBalance(employeeId: UUID, leaveType: LeaveType) -> LeaveBalance {\n      preconditions: [employeeId exists],\n      postconditions: [returns the current accrued and used days for a specific leave type],\n      errors: [EmployeeNotFound, LeaveTypeNotFound]\n    }\n  }\n}\n\nService LeaveRequestRepository {\n  methods: {\n    save(request: LeaveRequest) -> LeaveRequest;\n    findById(requestId: UUID) -> LeaveRequest;\n  }\n}\n\nService LeaveBalanceRepository {\n  methods: {\n    save(balance: LeaveBalance) -> LeaveBalance;\n    findByEmployeeIdAndType(employeeId: UUID, type: LeaveType) -> LeaveBalance;\n  }\n}\n\nType LeaveType {\n  enum: [VACATION, SICK, PATERNITY, MATERNITY, BEREAVEMENT, UNPAID]\n}\n\nType LeaveRequest {\n  id: UUID,\n  employeeId: UUID,\n  type: LeaveType,\n  startDate: date,\n  endDate: date,\n  status: LeaveStatus,\n  managerId: UUID | null,\n  rejectionReason: string | null,\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType LeaveStatus {\n  enum: [PENDING, APPROVED, REJECTED, CANCELED]\n}\n\nType LeaveBalance {\n  id: UUID,\n  employeeId: UUID,\n  leaveType: LeaveType,\n  accruedDays: float,\n  usedDays: float\n}\n</blueprint>"}
{"id": "blueprint_biz_104", "category": "hr_management", "difficulty": "intermediate", "user_query": "Payroll processing system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to calculate employee salaries, wages, deductions, and generate pay stubs.\n- It needs to handle different pay frequencies, tax jurisdictions, and benefits deductions.\n\nSTRATEGIC APPROACH:\n- Design a `PayrollService`.\n- It will depend on `EmployeeDataService` (for employee details) and `TaxRuleEngine` (for tax calculations).\n- Implement methods for calculating payroll and generating pay stubs for a given period.\n\nDESIGN PREPARATION:\n- `PayrollRun` data model (runId, payPeriod: DateRange, status: Draft/Processed/Paid).\n- `Paycheck` data model (paycheckId, employeeId, grossPay, netPay, deductions: array[Deduction], taxes: array[Tax], payStubUrl).\n- `PayrollService` with methods: `calculatePayroll`, `processPayroll`, `generatePayStub`.\n- `PayrollRepository` to store payroll runs and paychecks.\n- Error handling for `EmployeeDataMissing`, `TaxRulesUnavailable`, `ProcessingError`.\n</thinking>\n\n<blueprint>\nService PayrollService {\n  description: \"Calculates employee salaries, wages, deductions, and generates pay stubs.\",\n  dependencies: {\n    employeeData: EmployeeDataService,\n    taxEngine: TaxRuleEngine,\n    benefitService: BenefitService,\n    bankService: BankingService // For actual payouts\n  },\n  methods: {\n    calculatePayroll(payPeriod: DateRange) -> PayrollRun {\n      preconditions: [payPeriod is valid, employee data is complete],\n      postconditions: [a draft payroll run is created with calculated paychecks for all active employees],\n      errors: [InvalidPayPeriod, IncompleteEmployeeData]\n    },\n    processPayroll(runId: UUID, adminId: UUID) -> PayrollRun {\n      preconditions: [runId exists, run status is 'Draft', adminId has authority],\n      postconditions: [payroll run status changes to 'Processed', funds transferred (simulated)],\n      errors: [PayrollRunNotFound, UnauthorizedAccess, ProcessingError]\n    },\n    generatePayStub(paycheckId: UUID) -> PayStub {\n      preconditions: [paycheckId exists],\n      postconditions: [returns a structured pay stub with earnings, deductions, and taxes],\n      errors: [PaycheckNotFound]\n    }\n  }\n}\n\nService PayrollRepository {\n  methods: {\n    save(payrollRun: PayrollRun) -> PayrollRun;\n    findById(runId: UUID) -> PayrollRun;\n    savePaycheck(paycheck: Paycheck) -> Paycheck;\n  }\n}\n\nService EmployeeDataService {\n  methods: {\n    getActiveEmployees() -> array[Employee];\n    getEmployeeById(employeeId: UUID) -> Employee;\n  }\n}\n\nType DateRange {\n  startDate: date,\n  endDate: date\n}\n\nType PayrollRun {\n  id: UUID,\n  payPeriod: DateRange,\n  status: PayrollRunStatus,\n  paychecks: array[Paycheck],\n  createdAt: timestamp\n}\n\nType PayrollRunStatus {\n  enum: [DRAFT, PROCESSED, PAID, REVERSED]\n}\n\nType Paycheck {\n  id: UUID,\n  employeeId: UUID,\n  payrollRunId: UUID,\n  grossPay: float,\n  netPay: float,\n  earnings: map<string, float>,\n  deductions: map<string, float>,\n  taxes: map<string, float>,\n  payDate: date,\n  payStubUrl: string // URL to the generated pay stub document\n}\n\nType PayStub {\n  paycheck: Paycheck,\n  details: map<string, any> // Detailed breakdown for display\n}\n</blueprint>"}
{"id": "blueprint_biz_105", "category": "hr_management", "difficulty": "intermediate", "user_query": "Recruitment tracking system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to track job applications, candidate statuses, and hiring process progress.\n- Needs to manage job openings, applicants, interview stages, and feedback.\n\nSTRATEGIC APPROACH:\n- Design a `RecruitmentService`.\n- Define `JobOpening`, `Applicant`, and `Interview` entities.\n- Implement a workflow for managing job applications from submission to hiring/rejection.\n\nDESIGN PREPARATION:\n- `JobOpening` data model (jobId, title, department, status: Open/Closed).\n- `Applicant` data model (applicantId, jobId, name, email, resumeUrl, status: Applied/Interviewing/Offer/Hired).\n- `Interview` data model (interviewId, applicantId, interviewerId, date, feedback).\n- `RecruitmentService` with methods: `createJobOpening`, `applyForJob`, `scheduleInterview`, `updateApplicantStatus`.\n- `RecruitmentRepository` for persistence.\n- Error handling for `JobNotFound`, `ApplicantNotFound`, `InvalidStatusTransition`.\n</thinking>\n\n<blueprint>\nService RecruitmentService {\n  description: \"Tracks job applications, candidate statuses, and hiring process progress.\",\n  dependencies: {\n    jobRepo: JobOpeningRepository,\n    applicantRepo: ApplicantRepository,\n    interviewRepo: InterviewRepository,\n    userService: UserService\n  },\n  methods: {\n    createJobOpening(title: string, department: string, description: string) -> JobOpening {\n      preconditions: [title and department are not empty],\n      postconditions: [a new job opening is created with 'Open' status],\n      errors: [InvalidInput]\n    },\n    applyForJob(jobId: UUID, name: string, email: string, resumeUrl: string) -> Applicant {\n      preconditions: [jobId exists and is 'Open', email is unique for job],\n      postconditions: [a new applicant record is created with 'Applied' status],\n      errors: [JobOpeningNotFound, JobClosed, DuplicateApplication]\n    },\n    scheduleInterview(applicantId: UUID, interviewerId: UUID, date: timestamp, type: string) -> Interview {\n      preconditions: [applicantId exists, interviewerId exists, date is in future],\n      postconditions: [a new interview is scheduled and linked to applicant],\n      errors: [ApplicantNotFound, InterviewerNotFound, InvalidDate]\n    },\n    updateApplicantStatus(applicantId: UUID, newStatus: ApplicantStatus, updaterId: UUID) -> Applicant {\n      preconditions: [applicantId exists, newStatus is a valid transition, updaterId has authority],\n      postconditions: [applicant's status is updated, triggers next workflow steps],\n      errors: [ApplicantNotFound, InvalidStatusTransition, UnauthorizedAccess]\n    }\n  }\n}\n\nService JobOpeningRepository {\n  methods: {\n    save(job: JobOpening) -> JobOpening;\n    findById(jobId: UUID) -> JobOpening;\n  }\n}\n\nService ApplicantRepository {\n  methods: {\n    save(applicant: Applicant) -> Applicant;\n    findById(applicantId: UUID) -> Applicant;\n  }\n}\n\nType JobOpening {\n  id: UUID,\n  title: string,\n  department: string,\n  description: string,\n  status: JobStatus,\n  createdAt: timestamp\n}\n\nType JobStatus {\n  enum: [OPEN, CLOSED]\n}\n\nType ApplicantStatus {\n  enum: [APPLIED, INTERVIEWING, OFFER_EXTENDED, HIRED, REJECTED, WITHDRAWN]\n}\n\nType Applicant {\n  id: UUID,\n  jobId: UUID,\n  name: string,\n  email: string,\n  resumeUrl: string,\n  status: ApplicantStatus,\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType Interview {\n  id: UUID,\n  applicantId: UUID,\n  interviewerId: UUID,\n  date: timestamp,\n  type: string, // e.g., 'PHONE_SCREEN', 'TECHNICAL', 'HR'\n  feedback: string | null,\n  rating: int | null\n}\n</blueprint>"}
{"id": "blueprint_biz_106", "category": "hr_management", "difficulty": "intermediate", "user_query": "Training program manager", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to manage employee training programs, courses, and certifications.\n- Needs to track employee enrollment, completion, and notify about upcoming training.\n\nSTRATEGIC APPROACH:\n- Design a `TrainingService`.\n- Define `TrainingProgram`, `Course`, `Enrollment`, and `Certification` entities.\n- Implement methods for creating programs, enrolling employees, and tracking progress.\n\nDESIGN PREPARATION:\n- `TrainingProgram` data model (programId, name, description, requiredForRoles: array[string]).\n- `Course` data model (courseId, programId, title, duration, completionCriteria).\n- `Enrollment` data model (enrollmentId, employeeId, courseId, status: Enrolled/Completed, completionDate).\n- `TrainingService` with methods: `createProgram`, `enrollEmployee`, `markCourseCompleted`, `getEmployeeTrainingStatus`.\n- `TrainingRepository` for persistence.\n- Error handling for `ProgramNotFound`, `EmployeeNotFound`, `CourseNotFound`.\n</thinking>\n\n<blueprint>\nService TrainingService {\n  description: \"Manages employee training programs, courses, and certifications.\",\n  dependencies: {\n    programRepo: TrainingProgramRepository,\n    courseRepo: CourseRepository,\n    enrollmentRepo: EnrollmentRepository,\n    userService: UserService\n  },\n  methods: {\n    createProgram(name: string, description: string, requiredForRoles: array[string]) -> TrainingProgram {\n      preconditions: [name is not empty],\n      postconditions: [a new training program is created],\n      errors: [InvalidInput]\n    },\n    createCourse(programId: UUID, title: string, description: string, durationHours: int) -> Course {\n      preconditions: [programId exists, title is not empty],\n      postconditions: [a new course is added to the program],\n      errors: [TrainingProgramNotFound, InvalidInput]\n    },\n    enrollEmployee(employeeId: UUID, courseId: UUID) -> Enrollment {\n      preconditions: [employeeId exists, courseId exists, employee not already enrolled],\n      postconditions: [employee is enrolled in the course with 'Enrolled' status],\n      errors: [EmployeeNotFound, CourseNotFound, AlreadyEnrolled]\n    },\n    markCourseCompleted(enrollmentId: UUID, employeeId: UUID, completionDate: date) -> Enrollment {\n      preconditions: [enrollmentId exists, belongs to employeeId, status is 'Enrolled'],\n      postconditions: [enrollment status changes to 'Completed', completion date recorded],\n      errors: [EnrollmentNotFound, UnauthorizedAccess, InvalidStatusTransition]\n    },\n    getEmployeeTrainingStatus(employeeId: UUID) -> array[Enrollment] {\n      preconditions: [employeeId exists],\n      postconditions: [returns all courses the employee is enrolled in and their status],\n      errors: [EmployeeNotFound]\n    }\n  }\n}\n\nService TrainingProgramRepository {\n  methods: {\n    save(program: TrainingProgram) -> TrainingProgram;\n    findById(programId: UUID) -> TrainingProgram;\n  }\n}\n\nService CourseRepository {\n  methods: {\n    save(course: Course) -> Course;\n    findById(courseId: UUID) -> Course;\n    findByProgramId(programId: UUID) -> array[Course];\n  }\n}\n\nType TrainingProgram {\n  id: UUID,\n  name: string,\n  description: string,\n  requiredForRoles: array[string]\n}\n\nType Course {\n  id: UUID,\n  programId: UUID,\n  title: string,\n  description: string,\n  durationHours: int\n}\n\nType EnrollmentStatus {\n  enum: [ENROLLED, COMPLETED, DROPPED]\n}\n\nType Enrollment {\n  id: UUID,\n  employeeId: UUID,\n  courseId: UUID,\n  status: EnrollmentStatus,\n  enrollmentDate: timestamp,\n  completionDate: date | null\n}\n</blueprint>"}
{"id": "blueprint_biz_108", "category": "hr_management", "difficulty": "intermediate", "user_query": "Time and attendance tracking", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to track employee work hours, including clock-in/out times, breaks, and overtime.\n- Needs to support different work schedules and generate time sheets.\n\nSTRATEGIC APPROACH:\n- Design a `TimeTrackingService`.\n- Define a `TimeEntry` entity (employeeId, clockIn, clockOut, breakDuration, totalHours).\n- Implement methods for employees to clock in/out and for managers to review time sheets.\n\nDESIGN PREPARATION:\n- `TimeEntry` data model.\n- `TimeTrackingService` with methods: `clockIn`, `clockOut`, `getEmployeeTimesheet`, `approveTimesheet`.\n- `TimeEntryRepository` for persistence.\n- Integration with `EmployeeDataService`.\n- Error handling for `EmployeeNotFound`, `AlreadyClockedIn`, `NotClockedIn`.\n</thinking>\n\n<blueprint>\nService TimeTrackingService {\n  description: \"Tracks employee work hours, including clock-in/out, breaks, and overtime.\",\n  dependencies: {\n    timeRepo: TimeEntryRepository,\n    employeeService: EmployeeDataService\n  },\n  methods: {\n    clockIn(employeeId: UUID) -> TimeEntry {\n      preconditions: [employeeId exists, employee not currently clocked in],\n      postconditions: [a new time entry is created with a clock-in timestamp],\n      errors: [EmployeeNotFound, AlreadyClockedIn]\n    },\n    clockOut(employeeId: UUID) -> TimeEntry {\n      preconditions: [employeeId exists, employee is currently clocked in],\n      postconditions: [the current time entry's clock-out timestamp is recorded, total hours calculated],\n      errors: [EmployeeNotFound, NotClockedIn]\n    },\n    startBreak(employeeId: UUID) -> TimeEntry {\n      preconditions: [employeeId exists, employee is clocked in, not on break],\n      postconditions: [records start of break for current time entry],\n      errors: [EmployeeNotFound, NotClockedIn, AlreadyOnBreak]\n    },\n    endBreak(employeeId: UUID) -> TimeEntry {\n      preconditions: [employeeId exists, employee is on break],\n      postconditions: [records end of break, updates break duration for current time entry],\n      errors: [EmployeeNotFound, NotOnBreak]\n    },\n    getEmployeeTimesheet(employeeId: UUID, payPeriod: DateRange) -> Timesheet {\n      preconditions: [employeeId exists, payPeriod is valid],\n      postconditions: [returns a summary of work hours for the specified period],\n      errors: [EmployeeNotFound]\n    }\n  }\n}\n\nService TimeEntryRepository {\n  methods: {\n    save(timeEntry: TimeEntry) -> TimeEntry;\n    findCurrentByEmployeeId(employeeId: UUID) -> TimeEntry;\n    findByEmployeeIdAndPeriod(employeeId: UUID, payPeriod: DateRange) -> array[TimeEntry];\n  }\n}\n\nType TimeEntry {\n  id: UUID,\n  employeeId: UUID,\n  clockIn: timestamp,\n  clockOut: timestamp | null,\n  breakStart: timestamp | null,\n  breakEnd: timestamp | null,\n  totalBreakDurationMinutes: int,\n  totalHours: float | null\n}\n\nType Timesheet {\n  employeeId: UUID,\n  payPeriod: DateRange,\n  totalRegularHours: float,\n  totalOvertimeHours: float,\n  totalGrossPay: float,\n  entries: array[TimeEntry]\n}\n</blueprint>"}
{"id": "blueprint_biz_109", "category": "hr_management", "difficulty": "intermediate", "user_query": "Organizational chart manager", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to manage the hierarchical structure of an organization.\n- Needs to store employees and their reporting lines (who reports to whom).\n- Should be able to visualize or query the reporting structure.\n\nSTRATEGIC APPROACH:\n- Design an `OrgChartService`.\n- Define an `Employee` entity with a reference to their `managerId`.\n- Implement methods to assign managers, get direct reports, and trace reporting lines up/down the hierarchy.\n\nDESIGN PREPARATION:\n- `Employee` data model (employeeId, name, position, managerId: UUID | null).\n- `OrgChartService` with methods: `assignManager`, `getDirectReports`, `getManagementChain`.\n- `EmployeeRepository` for persistence.\n- Error handling for `EmployeeNotFound`, `ManagerNotFound`, `CircularReporting`.\n</thinking>\n\n<blueprint>\nService OrgChartService {\n  description: \"Manages the hierarchical organizational chart and reporting lines.\",\n  dependencies: {\n    employeeRepo: EmployeeRepository\n  },\n  methods: {\n    assignManager(employeeId: UUID, managerId: UUID | null) -> Employee {\n      preconditions: [employeeId exists, managerId exists or is null, not creating circular reference],\n      postconditions: [employee's manager is updated],\n      errors: [EmployeeNotFound, ManagerNotFound, CircularReportingError]\n    },\n    getDirectReports(managerId: UUID) -> array[Employee] {\n      preconditions: [managerId exists],\n      postconditions: [returns a list of employees who directly report to the manager],\n      errors: [UserNotFound]\n    },\n    getManagementChain(employeeId: UUID) -> array[Employee] {\n      preconditions: [employeeId exists],\n      postconditions: [returns an ordered list of managers from the employee up to the top of the hierarchy],\n      errors: [EmployeeNotFound]\n    }\n  }\n}\n\nService EmployeeRepository {\n  methods: {\n    save(employee: Employee) -> Employee;\n    findById(employeeId: UUID) -> Employee;\n    findByManagerId(managerId: UUID) -> array[Employee];\n  }\n}\n\nType Employee {\n  id: UUID,\n  name: string,\n  position: string,\n  managerId: UUID | null,\n  // other employee data\n}\n</blueprint>"}
{"id": "blueprint_biz_110", "category": "hr_management", "difficulty": "intermediate", "user_query": "Skill assessment system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to assess and track employee skills.\n- Needs to define skills, record employee proficiency levels, and identify skill gaps.\n\nSTRATEGIC APPROACH:\n- Design a `SkillAssessmentService`.\n- Define `Skill`, `EmployeeSkill`, and `Assessment` entities.\n- Implement methods for adding skills, recording assessments, and querying employee skill profiles.\n\nDESIGN PREPARATION:\n- `Skill` data model (skillId, name, description).\n- `EmployeeSkill` data model (employeeId, skillId, proficiencyLevel: Novice/Intermediate/Expert, lastAssessedDate).\n- `Assessment` data model (assessmentId, employeeId, skillId, assessedBy, score, comments).\n- `SkillAssessmentService` with methods: `addSkill`, `recordSkillAssessment`, `getEmployeeSkills`, `getEmployeesBySkill`.\n- `SkillRepository` for persistence.\n- Error handling for `SkillNotFound`, `EmployeeNotFound`, `InvalidProficiency`.\n</thinking>\n\n<blueprint>\nService SkillAssessmentService {\n  description: \"Assesses and tracks employee skills and proficiency levels.\",\n  dependencies: {\n    skillRepo: SkillRepository,\n    employeeSkillRepo: EmployeeSkillRepository,\n    userService: UserService\n  },\n  methods: {\n    addSkill(name: string, description: string) -> Skill {\n      preconditions: [name is unique],\n      postconditions: [a new skill is added to the system],\n      errors: [DuplicateSkillName]\n    },\n    recordSkillAssessment(employeeId: UUID, skillId: UUID, proficiency: ProficiencyLevel, assessedBy: UUID) -> EmployeeSkill {\n      preconditions: [employeeId exists, skillId exists, proficiency is valid],\n      postconditions: [employee's proficiency for the skill is recorded/updated],\n      errors: [EmployeeNotFound, SkillNotFound, InvalidProficiency]\n    },\n    getEmployeeSkills(employeeId: UUID) -> array[EmployeeSkill] {\n      preconditions: [employeeId exists],\n      postconditions: [returns a list of all skills and their proficiency levels for the employee],\n      errors: [EmployeeNotFound]\n    },\n    getEmployeesBySkill(skillId: UUID, minProficiency: ProficiencyLevel | null) -> array[Employee] {\n      preconditions: [skillId exists],\n      postconditions: [returns a list of employees possessing the skill, optionally filtered by minimum proficiency],\n      errors: [SkillNotFound]\n    }\n  }\n}\n\nService SkillRepository {\n  methods: {\n    save(skill: Skill) -> Skill;\n    findById(skillId: UUID) -> Skill;\n  }\n}\n\nService EmployeeSkillRepository {\n  methods: {\n    save(employeeSkill: EmployeeSkill) -> EmployeeSkill;\n    findByEmployeeId(employeeId: UUID) -> array[EmployeeSkill];\n    findBySkillId(skillId: UUID, minProficiency: ProficiencyLevel | null) -> array[EmployeeSkill];\n  }\n}\n\nType ProficiencyLevel {\n  enum: [NOVICE, INTERMEDIATE, EXPERT]\n}\n\nType Skill {\n  id: UUID,\n  name: string,\n  description: string\n}\n\nType EmployeeSkill {\n  id: UUID,\n  employeeId: UUID,\n  skillId: UUID,\n  proficiencyLevel: ProficiencyLevel,\n  lastAssessedDate: date\n}\n</blueprint>"}
{"id": "blueprint_biz_111", "category": "hr_management", "difficulty": "intermediate", "user_query": "Career development planner", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to help employees plan their career development, setting goals, identifying required skills, and recommending training.\n- Needs to track career paths and map skills to roles.\n\nSTRATEGIC APPROACH:\n- Design a `CareerDevelopmentService`.\n- Define `CareerPath`, `DevelopmentGoal`, and `LearningResource` entities.\n- Implement methods for creating development plans, linking goals to skills/courses, and tracking progress.\n\nDESIGN PREPARATION:\n- `CareerPath` data model (pathId, name, targetRoles: array[string], requiredSkills: array[SkillId]).\n- `DevelopmentGoal` data model (goalId, employeeId, description, targetDate, status: Open/Achieved).\n- `LearningResource` data model (resourceId, title, type: Course/Book/Mentor, associatedSkills: array[SkillId]).\n- `CareerDevelopmentService` with methods: `createDevelopmentPlan`, `addDevelopmentGoal`, `recommendResources`, `getEmployeeDevelopmentPlan`.\n- Integrations with `SkillAssessmentService`, `TrainingService`.\n- Error handling for `EmployeeNotFound`, `GoalNotFound`.\n</thinking>\n\n<blueprint>\nService CareerDevelopmentService {\n  description: \"Helps employees plan career development, set goals, and find learning resources.\",\n  dependencies: {\n    planRepo: CareerPlanRepository,\n    goalRepo: DevelopmentGoalRepository,\n    skillService: SkillAssessmentService,\n    trainingService: TrainingService,\n    resourceRepo: LearningResourceRepository\n  },\n  methods: {\n    createDevelopmentPlan(employeeId: UUID, targetRole: string) -> DevelopmentPlan {\n      preconditions: [employeeId exists, targetRole is a known career path target],\n      postconditions: [a new development plan is created for the employee, linked to target role's skills],\n      errors: [EmployeeNotFound, UnknownRole]\n    },\n    addDevelopmentGoal(planId: UUID, description: string, targetDate: date, associatedSkillId: UUID | null) -> DevelopmentGoal {\n      preconditions: [planId exists, description not empty, targetDate in future],\n      postconditions: [a new development goal is added to the plan],\n      errors: [DevelopmentPlanNotFound, InvalidInput]\n    },\n    recommendResources(employeeId: UUID, skillId: UUID) -> array[LearningResource] {\n      preconditions: [employeeId exists, skillId exists],\n      postconditions: [returns a list of learning resources relevant to the employee's current skill level and target skill],\n      errors: [EmployeeNotFound, SkillNotFound]\n    },\n    getEmployeeDevelopmentPlan(employeeId: UUID) -> DevelopmentPlanSummary {\n      preconditions: [employeeId exists],\n      postconditions: [returns the employee's development plan, goals, and recommended resources],\n      errors: [EmployeeNotFound, DevelopmentPlanNotFound]\n    }\n  }\n}\n\nService CareerPlanRepository {\n  methods: {\n    save(plan: DevelopmentPlan) -> DevelopmentPlan;\n    findByEmployeeId(employeeId: UUID) -> DevelopmentPlan;\n  }\n}\n\nType DevelopmentPlan {\n  id: UUID,\n  employeeId: UUID,\n  targetRole: string,\n  goals: array[DevelopmentGoal],\n  createdAt: timestamp\n}\n\nType DevelopmentGoal {\n  id: UUID,\n  planId: UUID,\n  description: string,\n  targetDate: date,\n  status: string, // 'OPEN', 'IN_PROGRESS', 'ACHIEVED', 'DROPPED'\n  associatedSkillId: UUID | null\n}\n\nType LearningResource {\n  id: UUID,\n  title: string,\n  type: string, // 'COURSE', 'BOOK', 'MENTORSHIP', 'CERTIFICATION'\n  link: string,\n  associatedSkills: array[UUID]\n}\n\nType DevelopmentPlanSummary {\n  employeeId: UUID,\n  plan: DevelopmentPlan,\n  currentSkills: array[EmployeeSkill],\n  recommendedLearning: array[LearningResource]\n}\n</blueprint>"}
{"id": "blueprint_biz_112", "category": "hr_management", "difficulty": "intermediate", "user_query": "Employee feedback system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system for employees to give and receive feedback (peer-to-peer, manager-to-employee).\n- Needs to track feedback submissions, allow for private or public feedback, and integrate with performance reviews.\n\nSTRATEGIC APPROACH:\n- Design a `FeedbackService`.\n- Define a `FeedbackEntry` entity with sender, receiver, content, and type (private/public).\n- Implement methods for submitting feedback, retrieving received feedback, and linking to performance reviews.\n\nDESIGN PREPARATION:\n- `FeedbackEntry` data model (feedbackId, senderId, receiverId, content, type: Private/Public, timestamp).\n- `FeedbackService` with methods: `submitFeedback`, `getReceivedFeedback`, `getGivenFeedback`.\n- `FeedbackRepository` for persistence.\n- Integration with `UserService` and `PerformanceReviewService`.\n- Error handling for `UserNotFound`, `InvalidAccess`.\n</thinking>\n\n<blueprint>\nService FeedbackService {\n  description: \"Manages peer-to-peer and manager-to-employee feedback within an organization.\",\n  dependencies: {\n    feedbackRepo: FeedbackRepository,\n    userService: UserService\n  },\n  methods: {\n    submitFeedback(senderId: UUID, receiverId: UUID, content: string, type: FeedbackType, performanceReviewId: UUID | null) -> FeedbackEntry {\n      preconditions: [senderId and receiverId exist, content is not empty],\n      postconditions: [new feedback entry is recorded, potentially linked to a performance review],\n      errors: [UserNotFound, InvalidInput, PerformanceReviewNotFound]\n    },\n    getReceivedFeedback(receiverId: UUID, filterType: FeedbackType | null) -> array[FeedbackEntry] {\n      preconditions: [receiverId exists],\n      postconditions: [returns a list of feedback entries received by the user, optionally filtered by type],\n      errors: [UserNotFound]\n    },\n    getGivenFeedback(senderId: UUID) -> array[FeedbackEntry] {\n      preconditions: [senderId exists],\n      postconditions: [returns a list of feedback entries submitted by the user],\n      errors: [UserNotFound]\n    }\n  }\n}\n\nService FeedbackRepository {\n  methods: {\n    save(feedback: FeedbackEntry) -> FeedbackEntry;\n    findByReceiverId(receiverId: UUID, filterType: FeedbackType | null) -> array[FeedbackEntry];\n    findBySenderId(senderId: UUID) -> array[FeedbackEntry];\n  }\n}\n\nType FeedbackType {\n  enum: [PRIVATE, PUBLIC, PERFORMANCE_REVIEW]\n}\n\nType FeedbackEntry {\n  id: UUID,\n  senderId: UUID,\n  receiverId: UUID,\n  content: string,\n  type: FeedbackType,\n  performanceReviewId: UUID | null,\n  timestamp: timestamp\n}\n</blueprint>"}
{"id": "blueprint_biz_113", "category": "hr_management", "difficulty": "intermediate", "user_query": "Compliance training tracker", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to track mandatory compliance training for employees.\n- Needs to assign training, track completion status, send reminders, and report on compliance rates.\n\nSTRATEGIC APPROACH:\n- Design a `ComplianceTrainingService`.\n- Define `ComplianceCourse`, `TrainingAssignment`, and `CompletionRecord` entities.\n- Implement methods for assigning training, marking completion, and generating compliance reports.\n\nDESIGN PREPARATION:\n- `ComplianceCourse` data model (courseId, name, description, requiredByRoles: array[string], dueDate).\n- `TrainingAssignment` data model (assignmentId, employeeId, courseId, assignedDate, dueDate, status: Assigned/InProgress/Completed).\n- `ComplianceTrainingService` with methods: `assignTraining`, `markTrainingCompleted`, `getEmployeeComplianceStatus`, `getComplianceReport`.\n- `TrainingRepository` for persistence.\n- Error handling for `CourseNotFound`, `EmployeeNotFound`, `AssignmentNotFound`.\n</thinking>\n\n<blueprint>\nService ComplianceTrainingService {\n  description: \"Tracks mandatory compliance training for employees and reports compliance rates.\",\n  dependencies: {\n    courseRepo: ComplianceCourseRepository,\n    assignmentRepo: TrainingAssignmentRepository,\n    userService: UserService\n  },\n  methods: {\n    assignTraining(courseId: UUID, employeeId: UUID) -> TrainingAssignment {\n      preconditions: [courseId exists, employeeId exists, employee not already assigned],\n      postconditions: [a new training assignment is created with 'Assigned' status],\n      errors: [CourseNotFound, EmployeeNotFound, AlreadyAssigned]\n    },\n    markTrainingCompleted(assignmentId: UUID, employeeId: UUID) -> TrainingAssignment {\n      preconditions: [assignmentId exists, belongs to employeeId, status is 'Assigned' or 'InProgress'],\n      postconditions: [assignment status changes to 'Completed', completion date recorded],\n      errors: [AssignmentNotFound, UnauthorizedAccess, InvalidStatusTransition]\n    },\n    getEmployeeComplianceStatus(employeeId: UUID) -> array[TrainingAssignment] {\n      preconditions: [employeeId exists],\n      postconditions: [returns a list of all assigned compliance trainings and their status for the employee],\n      errors: [EmployeeNotFound]\n    },\n    getComplianceReport(courseId: UUID | null) -> ComplianceReport {\n      preconditions: [],\n      postconditions: [returns a report on compliance rates, optionally for a specific course],\n      errors: [CourseNotFound]\n    }\n  }\n}\n\nService ComplianceCourseRepository {\n  methods: {\n    save(course: ComplianceCourse) -> ComplianceCourse;\n    findById(courseId: UUID) -> ComplianceCourse;\n  }\n}\n\nService TrainingAssignmentRepository {\n  methods: {\n    save(assignment: TrainingAssignment) -> TrainingAssignment;\n    findById(assignmentId: UUID) -> TrainingAssignment;\n    findByEmployeeId(employeeId: UUID) -> array[TrainingAssignment];\n  }\n}\n\nType ComplianceCourse {\n  id: UUID,\n  name: string,\n  description: string,\n  requiredByRoles: array[string],\n  dueDate: date\n}\n\nType TrainingAssignment {\n  id: UUID,\n  employeeId: UUID,\n  courseId: UUID,\n  assignedDate: timestamp,\n  dueDate: date,\n  completionDate: date | null,\n  status: TrainingStatus\n}\n\nType TrainingStatus {\n  enum: [ASSIGNED, IN_PROGRESS, COMPLETED, OVERDUE]\n}\n\nType ComplianceReport {\n  totalEmployees: int,\n  employeesInCompliance: int,\n  complianceRate: float,\n  nonCompliantEmployees: array[UUID]\n}\n</blueprint>"}
{"id": "blueprint_biz_114", "category": "hr_management", "difficulty": "intermediate", "user_query": "Expense report management", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- This is a HR-centric view of expense reimbursement, focusing on the employee and manager side.\n- A system to allow employees to submit expense reports and for managers to approve them.\n- Needs to track report status, manage receipts, and integrate with payroll for reimbursement.\n\nSTRATEGIC APPROACH:\n- Design an `ExpenseReportService`.\n- Define an `ExpenseReport` entity with items, total, status, and approval workflow.\n- Implement methods for submitting, reviewing, and approving reports.\n- This service primarily manages the workflow and data entry.\n\nDESIGN PREPARATION:\n- `ExpenseReport` data model (reportId, employeeId, submissionDate, items: array[ExpenseItem], totalAmount, status: Draft/Submitted/Approved/Rejected, approverId).\n- `ExpenseItem` data model (description, amount, category, receiptUrl).\n- `ExpenseReportService` with methods: `createReport`, `addItemToReport`, `submitReport`, `reviewReport`.\n- `ExpenseReportRepository` for persistence.\n- Integration with `UserService` and potentially `PayrollService` for payout.\n- Error handling for `ReportNotFound`, `InvalidStatusTransition`.\n</thinking>\n\n<blueprint>\nService ExpenseReportService {\n  description: \"Manages employee expense reports, their submission, and approval workflow.\",\n  dependencies: {\n    reportRepo: ExpenseReportRepository,\n    userService: UserService\n  },\n  methods: {\n    createReport(employeeId: UUID, title: string) -> ExpenseReport {\n      preconditions: [employeeId exists, title not empty],\n      postconditions: [a new expense report is created with 'Draft' status],\n      errors: [EmployeeNotFound, InvalidInput]\n    },\n    addItemToReport(reportId: UUID, description: string, amount: float, category: string, receiptUrl: string | null) -> ExpenseReport {\n      preconditions: [reportId exists, report status is 'Draft', amount > 0],\n      postconditions: [an item is added to the report, report total recalculated],\n      errors: [ExpenseReportNotFound, InvalidStatusTransition, InvalidAmount]\n    },\n    submitReport(reportId: UUID) -> ExpenseReport {\n      preconditions: [reportId exists, report status is 'Draft', has at least one item],\n      postconditions: [report status changes to 'Submitted', sent for manager review],\n      errors: [ExpenseReportNotFound, InvalidStatusTransition, EmptyReport]\n    },\n    reviewReport(reportId: UUID, managerId: UUID, action: string, reason: string | null) -> ExpenseReport {\n      preconditions: [reportId exists, report status is 'Submitted', managerId is authorized, action is 'APPROVE' or 'REJECT'],\n      postconditions: [report status updated based on action],\n      errors: [ExpenseReportNotFound, InvalidStatusTransition, UnauthorizedAccess]\n    }\n  }\n}\n\nService ExpenseReportRepository {\n  methods: {\n    save(report: ExpenseReport) -> ExpenseReport;\n    findById(reportId: UUID) -> ExpenseReport;\n    findByEmployeeId(employeeId: UUID) -> array[ExpenseReport];\n  }\n}\n\nType ExpenseReportStatus {\n  enum: [DRAFT, SUBMITTED, APPROVED, REJECTED, PAID]\n}\n\nType ExpenseReport {\n  id: UUID,\n  employeeId: UUID,\n  title: string,\n  submissionDate: date | null,\n  items: array[ExpenseItem],\n  totalAmount: float,\n  status: ExpenseReportStatus,\n  approverId: UUID | null,\n  reviewDate: timestamp | null,\n  rejectionReason: string | null\n}\n\nType ExpenseItem {\n  id: UUID,\n  description: string,\n  amount: float,\n  category: string,\n  receiptUrl: string | null\n}\n</blueprint>"}
{"id": "blueprint_biz_115", "category": "hr_management", "difficulty": "intermediate", "user_query": "Employee directory service", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to maintain a directory of all employees, including their contact information, department, and job title.\n- Needs to support searching and retrieving employee profiles.\n\nSTRATEGIC APPROACH:\n- Design an `EmployeeDirectoryService`.\n- Define an `EmployeeProfile` entity.\n- Implement methods for adding/updating employees and searching the directory.\n\nDESIGN PREPARATION:\n- `EmployeeProfile` data model (employeeId, name, email, phone, department, jobTitle, managerId).\n- `EmployeeDirectoryService` with methods: `addEmployee`, `updateEmployeeProfile`, `getEmployeeProfile`, `searchEmployees`.\n- `EmployeeProfileRepository` for persistence.\n- Error handling for `EmployeeNotFound`, `DuplicateEmail`.\n</thinking>\n\n<blueprint>\nService EmployeeDirectoryService {\n  description: \"Maintains a directory of all employees and their profiles.\",\n  dependencies: {\n    employeeProfileRepo: EmployeeProfileRepository\n  },\n  methods: {\n    addEmployee(name: string, email: string, department: string, jobTitle: string, managerId: UUID | null) -> EmployeeProfile {\n      preconditions: [email is unique, name and jobTitle not empty],\n      postconditions: [a new employee profile is created],\n      errors: [DuplicateEmail, InvalidInput]\n    },\n    updateEmployeeProfile(employeeId: UUID, updates: map<string, any>) -> EmployeeProfile {\n      preconditions: [employeeId exists, updates are valid],\n      postconditions: [employee profile is updated with the provided fields],\n      errors: [EmployeeNotFound, InvalidUpdate]\n    },\n    getEmployeeProfile(employeeId: UUID) -> EmployeeProfile {\n      preconditions: [employeeId exists],\n      postconditions: [returns the full profile details for the employee],\n      errors: [EmployeeNotFound]\n    },\n    searchEmployees(query: string, departmentFilter: string | null) -> array[EmployeeProfile] {\n      preconditions: [],\n      postconditions: [returns a list of employee profiles matching the search query and filters],\n      errors: []\n    }\n  }\n}\n\nService EmployeeProfileRepository {\n  methods: {\n    save(profile: EmployeeProfile) -> EmployeeProfile;\n    findById(employeeId: UUID) -> EmployeeProfile;\n    search(query: string, departmentFilter: string | null) -> array[EmployeeProfile];\n  }\n}\n\nType EmployeeProfile {\n  id: UUID,\n  name: string,\n  email: string,\n  phone: string | null,\n  department: string,\n  jobTitle: string,\n  managerId: UUID | null,\n  status: string // e.g., 'ACTIVE', 'INACTIVE'\n}\n</blueprint>"}
{"id": "blueprint_biz_116", "category": "hr_management", "difficulty": "intermediate", "user_query": "Performance goal tracking", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to track individual and team performance goals.\n- Needs to allow employees and managers to set, update, and monitor progress against goals.\n- Integrates with performance review cycles.\n\nSTRATEGIC APPROACH:\n- Design a `GoalTrackingService`.\n- Define a `Goal` entity (ownerId, description, targetDate, metric, currentProgress, status: NotStarted/InProgress/Achieved).\n- Implement methods for goal management and progress updates.\n\nDESIGN PREPARATION:\n- `Goal` data model.\n- `GoalTrackingService` with methods: `createGoal`, `updateGoalProgress`, `getEmployeeGoals`, `getGoalsByManager`.\n- `GoalRepository` for persistence.\n- Error handling for `GoalNotFound`, `UnauthorizedAccess`, `InvalidProgress`.\n</thinking>\n\n<blueprint>\nService GoalTrackingService {\n  description: \"Tracks individual and team performance goals, and monitors progress.\",\n  dependencies: {\n    goalRepo: GoalRepository,\n    userService: UserService\n  },\n  methods: {\n    createGoal(ownerId: UUID, description: string, targetDate: date, metric: string) -> Goal {\n      preconditions: [ownerId exists, description not empty, targetDate in future],\n      postconditions: [a new performance goal is created with 'NotStarted' status],\n      errors: [UserNotFound, InvalidInput]\n    },\n    updateGoalProgress(goalId: UUID, updaterId: UUID, progressPercentage: float, status: GoalStatus | null, notes: string | null) -> Goal {\n      preconditions: [goalId exists, updaterId is owner or manager, progressPercentage between 0 and 100],\n      postconditions: [goal progress and status are updated],\n      errors: [GoalNotFound, UnauthorizedAccess, InvalidProgress]\n    },\n    getEmployeeGoals(employeeId: UUID, statusFilter: GoalStatus | null) -> array[Goal] {\n      preconditions: [employeeId exists],\n      postconditions: [returns a list of goals for the employee, optionally filtered by status],\n      errors: [UserNotFound]\n    },\n    getGoalsByManager(managerId: UUID, statusFilter: GoalStatus | null) -> array[Goal] {\n      preconditions: [managerId exists],\n      postconditions: [returns a list of goals for employees managed by the manager],\n      errors: [UserNotFound]\n    }\n  }\n}\n\nService GoalRepository {\n  methods: {\n    save(goal: Goal) -> Goal;\n    findById(goalId: UUID) -> Goal;\n    findByOwnerId(ownerId: UUID, statusFilter: GoalStatus | null) -> array[Goal];\n  }\n}\n\nType GoalStatus {\n  enum: [NOT_STARTED, IN_PROGRESS, ACHIEVED, MISSED, CANCELED]\n}\n\nType Goal {\n  id: UUID,\n  ownerId: UUID,\n  description: string,\n  targetDate: date,\n  metric: string, // e.g., \"Increase sales by 10%\", \"Complete training course\"\n  currentProgress: float, // Percentage completed (0-100)\n  status: GoalStatus,\n  createdAt: timestamp,\n  updatedAt: timestamp,\n  notes: string | null\n}\n</blueprint>"}
{"id": "blueprint_biz_117", "category": "hr_management", "difficulty": "intermediate", "user_query": "Succession planning system", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to identify and develop potential successors for key roles within an organization.\n- Needs to track high-potential employees, critical roles, and development plans for succession.\n\nSTRATEGIC APPROACH:\n- Design a `SuccessionPlanningService`.\n- Define `KeyRole`, `PotentialSuccessor`, and `SuccessionPlan` entities.\n- Implement methods for identifying critical roles, nominating successors, and tracking their readiness.\n\nDESIGN PREPARATION:\n- `KeyRole` data model (roleId, title, department, criticalLevel: High/Medium/Low, incumbentId: UUID).\n- `PotentialSuccessor` data model (employeeId, roleId, readinessLevel: ReadyNow/ReadySoon/DevelopmentNeeded, developmentPlanId).\n- `SuccessionPlan` data model (planId, roleId, incumbents: array[UUID], successors: array[UUID]).\n- `SuccessionPlanningService` with methods: `identifyKeyRole`, `nominateSuccessor`, `updateSuccessorReadiness`, `getSuccessionPlan`.\n- `SuccessionRepository` for persistence.\n- Integration with `PerformanceReviewService`, `SkillAssessmentService`, `CareerDevelopmentService`.\n- Error handling for `RoleNotFound`, `EmployeeNotFound`.\n</thinking>\n\n<blueprint>\nService SuccessionPlanningService {\n  description: \"Identifies and develops potential successors for key roles within an organization.\",\n  dependencies: {\n    keyRoleRepo: KeyRoleRepository,\n    successorRepo: PotentialSuccessorRepository,\n    planRepo: SuccessionPlanRepository,\n    userService: UserService\n  },\n  methods: {\n    identifyKeyRole(title: string, department: string, criticalLevel: string, incumbentId: UUID | null) -> KeyRole {\n      preconditions: [title not empty, criticalLevel is valid],\n      postconditions: [a new key role is identified and recorded],\n      errors: [InvalidInput, UserNotFound]\n    },\n    nominateSuccessor(roleId: UUID, employeeId: UUID, readiness: ReadinessLevel) -> PotentialSuccessor {\n      preconditions: [roleId exists, employeeId exists, readiness is valid],\n      postconditions: [employee is nominated as a potential successor for the role],\n      errors: [KeyRoleNotFound, EmployeeNotFound, InvalidReadinessLevel]\n    },\n    updateSuccessorReadiness(successorId: UUID, newReadiness: ReadinessLevel, adminId: UUID) -> PotentialSuccessor {\n      preconditions: [successorId exists, adminId has authority, newReadiness is valid],\n      postconditions: [successor's readiness level is updated],\n      errors: [SuccessorNotFound, UnauthorizedAccess, InvalidReadinessLevel]\n    },\n    getSuccessionPlan(roleId: UUID) -> SuccessionPlanSummary {\n      preconditions: [roleId exists],\n      postconditions: [returns the succession plan for a key role, including current incumbent and potential successors],\n      errors: [KeyRoleNotFound]\n    }\n  }\n}\n\nService KeyRoleRepository {\n  methods: {\n    save(role: KeyRole) -> KeyRole;\n    findById(roleId: UUID) -> KeyRole;\n  }\n}\n\nService PotentialSuccessorRepository {\n  methods: {\n    save(successor: PotentialSuccessor) -> PotentialSuccessor;\n    findById(successorId: UUID) -> PotentialSuccessor;\n    findByRoleId(roleId: UUID) -> array[PotentialSuccessor];\n  }\n}\n\nType ReadinessLevel {\n  enum: [READY_NOW, READY_SOON, DEVELOPMENT_NEEDED]\n}\n\nType KeyRole {\n  id: UUID,\n  title: string,\n  department: string,\n  criticalLevel: string,\n  incumbentId: UUID | null\n}\n\nType PotentialSuccessor {\n  id: UUID,\n  roleId: UUID,\n  employeeId: UUID,\n  readinessLevel: ReadinessLevel,\n  developmentPlanId: UUID | null\n}\n\nType SuccessionPlanSummary {\n  role: KeyRole,\n  incumbent: EmployeeProfile | null,\n  successors: array[PotentialSuccessor]\n}\n</blueprint>"}
{"id": "blueprint_biz_118", "category": "hr_management", "difficulty": "intermediate", "user_query": "Employee survey platform", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to create, distribute, and analyze employee surveys.\n- Needs to manage survey questions, collect responses, and provide analytical insights.\n\nSTRATEGIC APPROACH:\n- Design a `SurveyService`.\n- Define `Survey`, `Question`, and `Response` entities.\n- Implement methods for creating surveys, submitting responses, and generating reports.\n\nDESIGN PREPARATION:\n- `Survey` data model (surveyId, title, description, status: Draft/Active/Closed).\n- `Question` data model (questionId, surveyId, text, type: MultipleChoice/OpenText).\n- `Response` data model (responseId, surveyId, employeeId, answers: map<QuestionId, string>).\n- `SurveyService` with methods: `createSurvey`, `addQuestion`, `activateSurvey`, `submitResponse`, `getSurveyResults`.\n- `SurveyRepository` and `ResponseRepository` for persistence.\n- Error handling for `SurveyNotFound`, `QuestionNotFound`, `SurveyInactive`.\n</thinking>\n\n<blueprint>\nService SurveyService {\n  description: \"Creates, distributes, and analyzes employee surveys.\",\n  dependencies: {\n    surveyRepo: SurveyRepository,\n    questionRepo: QuestionRepository,\n    responseRepo: SurveyResponseRepository,\n    userService: UserService\n  },\n  methods: {\n    createSurvey(title: string, description: string) -> Survey {\n      preconditions: [title not empty],\n      postconditions: [a new survey is created with 'Draft' status],\n      errors: [InvalidInput]\n    },\n    addQuestion(surveyId: UUID, text: string, type: QuestionType, options: array[string] | null) -> Question {\n      preconditions: [surveyId exists, survey status is 'Draft', text not empty],\n      postconditions: [a new question is added to the survey],\n      errors: [SurveyNotFound, InvalidStatusTransition, InvalidInput]\n    },\n    activateSurvey(surveyId: UUID) -> Survey {\n      preconditions: [surveyId exists, survey status is 'Draft', has at least one question],\n      postconditions: [survey status changes to 'Active', becomes available for responses],\n      errors: [SurveyNotFound, InvalidStatusTransition, EmptySurvey]\n    },\n    submitResponse(surveyId: UUID, employeeId: UUID, answers: map<UUID, string>) -> SurveyResponse {\n      preconditions: [surveyId exists, survey status is 'Active', employeeId exists, all required questions answered],\n      postconditions: [employee's responses are recorded],\n      errors: [SurveyNotFound, SurveyInactive, EmployeeNotFound, IncompleteResponse]\n    },\n    getSurveyResults(surveyId: UUID) -> SurveyResults {\n      preconditions: [surveyId exists, survey status is 'Closed' or 'Active' (for partial results)],\n      postconditions: [returns aggregated results and statistics for the survey],\n      errors: [SurveyNotFound]\n    }\n  }\n}\n\nService SurveyRepository {\n  methods: {\n    save(survey: Survey) -> Survey;\n    findById(surveyId: UUID) -> Survey;\n  }\n}\n\nService QuestionRepository {\n  methods: {\n    save(question: Question) -> Question;\n    findBySurveyId(surveyId: UUID) -> array[Question];\n  }\n}\n\nType QuestionType {\n  enum: [MULTIPLE_CHOICE, OPEN_TEXT, RATING_SCALE]\n}\n\nType SurveyStatus {\n  enum: [DRAFT, ACTIVE, CLOSED]\n}\n\nType Survey {\n  id: UUID,\n  title: string,\n  description: string,\n  status: SurveyStatus,\n  startDate: timestamp | null,\n  endDate: timestamp | null,\n  questions: array[Question]\n}\n\nType Question {\n  id: UUID,\n  surveyId: UUID,\n  text: string,\n  type: QuestionType,\n  options: array[string] | null\n}\n\nType SurveyResponse {\n  id: UUID,\n  surveyId: UUID,\n  employeeId: UUID,\n  answers: map<UUID, string>,\n  submissionDate: timestamp\n}\n\nType SurveyResults {\n  surveyId: UUID,\n  totalResponses: int,\n  questionAnalysis: map<UUID, QuestionStats>\n}\n\nType QuestionStats {\n  questionText: string,\n  type: QuestionType,\n  // For MultipleChoice: option -> count\n  // For OpenText: array of responses\n  // For RatingScale: average, distribution\n  aggregatedData: map<string, any>\n}\n</blueprint>"}
{"id": "blueprint_biz_119", "category": "hr_management", "difficulty": "intermediate", "user_query": "Background check coordinator", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to coordinate and track background checks for new hires.\n- Involves submitting requests to external providers, receiving results, and updating candidate status.\n\nSTRATEGIC APPROACH:\n- Design a `BackgroundCheckService`.\n- Define a `CheckRequest` entity with candidate info, check types, and status.\n- Implement methods for initiating checks, receiving results, and updating status.\n\nDESIGN PREPARATION:\n- `CheckRequest` data model (requestId, candidateId, checkTypes: array[string], providerId, status: Initiated/InProgress/Completed/Failed).\n- `BackgroundCheckService` with methods: `initiateCheck`, `receiveResult`, `getCheckStatus`.\n- `CheckRequestRepository` for persistence.\n- Integration with `CandidateService` and `ExternalProviderClient` (e.g., Sterling, HireRight).\n- Error handling for `CandidateNotFound`, `ProviderError`.\n</thinking>\n\n<blueprint>\nService BackgroundCheckService {\n  description: \"Coordinates and tracks background checks for new hires.\",\n  dependencies: {\n    checkRepo: BackgroundCheckRepository,\n    candidateService: CandidateService, // From Recruitment\n    providerClient: ExternalBackgroundCheckProvider\n  },\n  methods: {\n    initiateCheck(candidateId: UUID, checkTypes: array[string]) -> CheckRequest {\n      preconditions: [candidateId exists, checkTypes are valid],\n      postconditions: [a new background check request is initiated with an external provider],\n      errors: [CandidateNotFound, InvalidCheckType, ProviderError]\n    },\n    receiveResult(requestId: UUID, resultDetails: map<string, any>) -> CheckRequest {\n      preconditions: [requestId exists, resultDetails contain necessary info],\n      postconditions: [background check status is updated, results recorded],\n      errors: [CheckRequestNotFound, InvalidResultFormat]\n    },\n    getCheckStatus(requestId: UUID) -> CheckRequestStatus {\n      preconditions: [requestId exists],\n      postconditions: [returns the current status and summary of the background check],\n      errors: [CheckRequestNotFound]\n    }\n  }\n}\n\nService BackgroundCheckRepository {\n  methods: {\n    save(request: CheckRequest) -> CheckRequest;\n    findById(requestId: UUID) -> CheckRequest;\n  }\n}\n\nService ExternalBackgroundCheckProvider {\n  methods: {\n    submitCheck(candidateDetails: map<string, any>, checkTypes: array[string]) -> ProviderCheckReference;\n    retrieveResult(providerReference: string) -> map<string, any>;\n  }\n}\n\nType CheckRequestStatus {\n  enum: [INITIATED, IN_PROGRESS, COMPLETED_PASS, COMPLETED_FAIL, CANCELED, ERROR]\n}\n\nType CheckRequest {\n  id: UUID,\n  candidateId: UUID,\n  checkTypes: array[string],\n  providerReferenceId: string,\n  status: CheckRequestStatus,\n  results: map<string, any>,\n  initiatedAt: timestamp,\n  completedAt: timestamp | null\n}\n\nType ProviderCheckReference {\n  providerName: string,\n  referenceId: string\n}\n</blueprint>"}
{"id": "blueprint_biz_120", "category": "hr_management", "difficulty": "intermediate", "user_query": "Termination process manager", "response": "<thinking>\nPROBLEM UNDERSTANDING:\n- A system to manage the offboarding process for employees.\n- Involves tasks like revoking access, collecting company assets, final pay calculation, and exit interviews.\n- It's a sensitive and multi-step workflow.\n\nSTRATEGIC APPROACH:\n- Design a `TerminationService`.\n- Define an `OffboardingCase` entity with employee info and a status reflecting its current stage.\n- Implement methods for initiating offboarding, completing tasks, and managing finalization.\n\nDESIGN PREPARATION:\n- `OffboardingCase` data model (employeeId, terminationDate, reason, status: Initiated/TasksPending/Completed).\n- `OffboardingTask` data model (taskId, caseId, description, assignedTo, dueDate, completedDate, status).\n- `TerminationService` with methods: `initiateOffboarding`, `completeOffboardingTask`, `getOffboardingStatus`.\n- `OffboardingRepository` for persistence.\n- Integrations with `ITService`, `PayrollService`, `AssetManagementService`.\n- Error handling for `EmployeeNotFound`, `CaseNotFound`, `InvalidWorkflowState`.\n</thinking>\n\n<blueprint>\nService TerminationService {\n  description: \"Manages the offboarding process for employees, including task coordination and finalization.\",\n  dependencies: {\n    offboardingRepo: OffboardingRepository,\n    taskRepo: OffboardingTaskRepository,\n    userService: UserService,\n    itService: ITSetupService, // For access revocation\n    payrollService: PayrollService // For final pay calculation\n  },\n  methods: {\n    initiateOffboarding(employeeId: UUID, terminationDate: date, reason: string) -> OffboardingCase {\n      preconditions: [employeeId exists, terminationDate is in future or today],\n      postconditions: [a new offboarding case is created with 'Initiated' status, standard tasks are generated],\n      errors: [EmployeeNotFound, InvalidDate]\n    },\n    completeOffboardingTask(caseId: UUID, taskId: UUID, completedBy: UUID) -> OffboardingTask {\n      preconditions: [caseId exists, taskId exists, task is assigned to or can be completed by completedBy],\n      postconditions: [task status is marked 'Completed', case status may advance],\n      errors: [OffboardingCaseNotFound, TaskNotFound, UnauthorizedAccess]\n    },\n    getOffboardingStatus(employeeId: UUID) -> OffboardingProgress {\n      preconditions: [employeeId exists],\n      postconditions: [returns the current status and pending tasks for an employee's offboarding],\n      errors: [EmployeeNotFound, OffboardingCaseNotFound]\n    },\n    finalizeOffboarding(caseId: UUID, adminId: UUID) -> OffboardingCase {\n      preconditions: [caseId exists, all tasks are completed, adminId has authority],\n      postconditions: [offboarding case status changes to 'Completed', final checks are performed],\n      errors: [OffboardingCaseNotFound, PendingTasksExist, UnauthorizedAccess]\n    }\n  }\n}\n\nService OffboardingRepository {\n  methods: {\n    save(offboardingCase: OffboardingCase) -> OffboardingCase;\n    findByEmployeeId(employeeId: UUID) -> OffboardingCase;\n  }\n}\n\nType OffboardingStatus {\n  enum: [INITIATED, TASKS_PENDING, COMPLETED, CANCELED]\n}\n\nType OffboardingCase {\n  id: UUID,\n  employeeId: UUID,\n  terminationDate: date,\n  reason: string,\n  status: OffboardingStatus,\n  createdAt: timestamp,\n  updatedAt: timestamp\n}\n\nType OffboardingTask {\n  id: UUID,\n  caseId: UUID,\n  description: string,\n  assignedTo: UUID,\n  dueDate: date,\n  completedDate: date | null,\n  status: string // PENDING, COMPLETED\n}\n\nType OffboardingProgress {\n  caseId: UUID,\n  employeeId: UUID,\n  currentStatus: OffboardingStatus,\n  completedTasks: int,\n  totalTasks: int,\n  pendingTasks: array[OffboardingTask]\n}\n</blueprint>"}
